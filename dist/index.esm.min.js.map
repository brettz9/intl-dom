{"version":3,"file":"index.esm.min.js","sources":["../node_modules/json-6/dist/index.mjs","../src/utils.js","../src/shared.js","../src/collation.js","../src/defaultAllSubstitutions.js","../src/Formatter.js","../src/promiseChainForValues.js","../src/defaultLocaleResolver.js","../src/defaultInsertNodes.js","../src/getMessageForKeyByStyle.js","../src/getStringFromMessageAndDefaults.js","../src/getDOMForLocaleString.js","../src/findLocaleStrings.js","../src/i18n.js"],"sourcesContent":["function createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar json6 = createCommonjsModule(function (module, exports) {\n\n  const VALUE_UNDEFINED = -1;\n  const VALUE_UNSET = 0;\n  const VALUE_NULL = 1;\n  const VALUE_TRUE = 2;\n  const VALUE_FALSE = 3;\n  const VALUE_STRING = 4;\n  const VALUE_NUMBER = 5;\n  const VALUE_OBJECT = 6;\n  const VALUE_ARRAY = 7;\n  const VALUE_NEG_NAN = 8;\n  const VALUE_NAN = 9;\n  const VALUE_NEG_INFINITY = 10;\n  const VALUE_INFINITY = 11; // const VALUE_DATE = 12  // unused yet\n\n  const VALUE_EMPTY = 13; // [,] makes an array with 'empty item'\n\n  const WORD_POS_RESET = 0;\n  const WORD_POS_TRUE_1 = 1;\n  const WORD_POS_TRUE_2 = 2;\n  const WORD_POS_TRUE_3 = 3;\n  const WORD_POS_FALSE_1 = 5;\n  const WORD_POS_FALSE_2 = 6;\n  const WORD_POS_FALSE_3 = 7;\n  const WORD_POS_FALSE_4 = 8;\n  const WORD_POS_NULL_1 = 9;\n  const WORD_POS_NULL_2 = 10;\n  const WORD_POS_NULL_3 = 11;\n  const WORD_POS_UNDEFINED_1 = 12;\n  const WORD_POS_UNDEFINED_2 = 13;\n  const WORD_POS_UNDEFINED_3 = 14;\n  const WORD_POS_UNDEFINED_4 = 15;\n  const WORD_POS_UNDEFINED_5 = 16;\n  const WORD_POS_UNDEFINED_6 = 17;\n  const WORD_POS_UNDEFINED_7 = 18;\n  const WORD_POS_UNDEFINED_8 = 19;\n  const WORD_POS_NAN_1 = 20;\n  const WORD_POS_NAN_2 = 21;\n  const WORD_POS_INFINITY_1 = 22;\n  const WORD_POS_INFINITY_2 = 23;\n  const WORD_POS_INFINITY_3 = 24;\n  const WORD_POS_INFINITY_4 = 25;\n  const WORD_POS_INFINITY_5 = 26;\n  const WORD_POS_INFINITY_6 = 27;\n  const WORD_POS_INFINITY_7 = 28;\n  const WORD_POS_FIELD = 29;\n  const WORD_POS_AFTER_FIELD = 30;\n  const WORD_POS_END = 31;\n  const CONTEXT_UNKNOWN = 0;\n  const CONTEXT_IN_ARRAY = 1; // const CONTEXT_IN_OBJECT = 2\n\n  const CONTEXT_OBJECT_FIELD = 3;\n  const CONTEXT_OBJECT_FIELD_VALUE = 4;\n  const contexts = [];\n\n  function getContext() {\n    return contexts.pop() || {\n      context: CONTEXT_UNKNOWN,\n      elements: null,\n      element_array: null\n    };\n  }\n\n  function dropContext(ctx) {\n    contexts.push(ctx);\n  }\n\n  const buffers = [];\n\n  function getBuffer() {\n    let buf = buffers.pop();\n    if (!buf) buf = {\n      buf: null,\n      n: 0\n    };else buf.n = 0;\n    return buf;\n  }\n\n  function dropBuffer(buf) {\n    buffers.push(buf);\n  }\n\n  const JSON6 =  exports // istanbul ignore next\n  ;\n  /*\n  let _DEBUG_LL = true;\n  let _DEBUG_PARSING = true;\n  let _DEBUG_PARSING_STACK = true;\n  \n  const log = function(type) {\n  \tif (type === '_DEBUG_PARSING' && !_DEBUG_PARSING) {\n  \t\treturn;\n  \t}\n  \tif (type === '_DEBUG_PARSING_STACK' && !_DEBUG_PARSING_STACK) {\n  \t\treturn;\n  \t}\n  \tif (type === '_DEBUG_LL' && !_DEBUG_LL) {\n  \t\treturn;\n  \t}\n  \tconsole.log.apply(console, [].slice.call(arguments, 1));\n  };\n  */\n\n  JSON6.escape = function (string) {\n    let output = '';\n    if (!string) return string;\n\n    for (let n = 0; n < string.length; n++) {\n      if (string[n] == '\"' || string[n] == '\\\\' || string[n] == '`' || string[n] == '\\'') {\n        output += '\\\\';\n      }\n\n      output += string[n];\n    }\n\n    return output;\n  };\n\n  JSON6.begin = function (cb, reviver) {\n    const val = {\n      name: null,\n      // name of this value (if it's contained in an object)\n      value_type: VALUE_UNSET,\n      // value from above indiciating the type of this value\n      string: '',\n      // the string value of this value (strings and number types only)\n      contains: null\n    };\n    const pos = {\n      line: 1,\n      col: 1\n    };\n    let n = 0;\n    let word = WORD_POS_RESET,\n        status = true,\n        negative = false,\n        result = null,\n        elements = undefined,\n        element_array = [],\n        parse_context = CONTEXT_UNKNOWN,\n        comment = 0,\n        fromHex = false,\n        decimal = false,\n        exponent = false,\n        exponent_sign = false,\n        exponent_digit = false,\n        gatheringStringFirstChar = null,\n        gatheringString = false,\n        gatheringNumber = false,\n        stringEscape = false,\n        cr_escaped = false,\n        unicodeWide = false,\n        stringUnicode = false,\n        stringHex = false,\n        hex_char = 0,\n        hex_char_len = 0,\n        completed = false;\n    const context_stack = {\n      first: null,\n      last: null,\n      saved: null,\n\n      push(node) {\n        let recover = this.saved;\n\n        if (recover) {\n          this.saved = recover.next;\n          recover.node = node;\n          recover.next = null;\n          recover.prior = this.last;\n        } else {\n          recover = {\n            node: node,\n            next: null,\n            prior: this.last\n          };\n        }\n\n        if (!this.last) this.first = recover;\n        this.last = recover;\n      },\n\n      pop() {\n        const result = this.last;\n        if (!(this.last = result.prior)) this.first = null;\n        result.next = this.saved;\n        this.saved = result;\n        return result.node;\n      }\n\n    };\n    const inQueue = {\n      first: null,\n      last: null,\n      saved: null,\n\n      push(node) {\n        let recover = this.saved;\n\n        if (recover) {\n          this.saved = recover.next;\n          recover.node = node;\n          recover.next = null;\n          recover.prior = this.last;\n        } else {\n          recover = {\n            node: node,\n            next: null,\n            prior: this.last\n          };\n        }\n\n        if (!this.last) this.first = recover;else this.last.next = recover;\n        this.last = recover;\n      },\n\n      shift() {\n        const result = this.first;\n        if (!result) return null;\n        this.first = result.next;\n        if (!this.first) this.last = null;\n        result.next = this.saved;\n        this.saved = result; // node is in saved...\n\n        return result.node;\n      },\n\n      unshift(node) {\n        // usage in this module, recover will ALWAYS have a saved to use.\n        const recover = this.saved; //if( recover ) {\n\n        this.saved = recover.next;\n        recover.node = node;\n        recover.next = this.first;\n        recover.prior = null; //} else { recover = { node : node, next : this.first, prior : null }; }\n\n        if (!this.first) this.last = recover;\n        this.first = recover;\n      }\n\n    };\n\n    function throwEndError(leader\n    /* , c */\n    ) {\n      throw new Error(`${leader} at ${n} [${pos.line}:${pos.col}]`);\n    }\n\n    return {\n      finalError() {\n        if (comment !== 0) {\n          // most of the time everything's good.\n          switch (comment) {\n            case 1:\n              return throwEndError(\"Comment began at end of document\");\n\n            case 2:\n              console.log(\"Warning: '//' comment without end of line ended document\");\n              break;\n\n            case 3:\n              return throwEndError(\"Open comment '/*' is missing close at end of document\");\n\n            case 4:\n              return throwEndError(\"Incomplete '/* *' close at end of document\");\n          }\n        }\n\n        if (gatheringString) throwEndError(\"Incomplete string\");\n      },\n\n      value() {\n        this.finalError();\n        const r = result;\n        result = undefined;\n        return r;\n      },\n\n      reset() {\n        word = WORD_POS_RESET;\n        status = true;\n        if (inQueue.last) inQueue.last.next = inQueue.save;\n        inQueue.save = inQueue.first;\n        inQueue.first = inQueue.last = null;\n        if (context_stack.last) context_stack.last.next = context_stack.save;\n        context_stack.save = inQueue.first;\n        context_stack.first = context_stack.last = null; //= [];\n\n        element_array = null;\n        elements = undefined;\n        parse_context = CONTEXT_UNKNOWN;\n        val.value_type = VALUE_UNSET;\n        val.name = null;\n        val.string = '';\n        pos.line = 1;\n        pos.col = 1;\n        negative = false;\n        comment = 0;\n        completed = false;\n        gatheringString = false;\n        stringEscape = false; // string stringEscape intro\n\n        cr_escaped = false; // carraige return escaped\n        //stringUnicode = false;  // reading \\u\n        //unicodeWide = false;  // reading \\u{} in string\n        //stringHex = false;  // reading \\x in string\n      },\n\n      write(msg) {\n        let retcode;\n        if (msg !== undefined && typeof msg !== \"string\") msg = String(msg);\n\n        for (retcode = this._write(msg, false); retcode > 0; retcode = this._write()) {\n          this.finalError();\n          if (typeof reviver === 'function') (function walk(holder, key) {\n            const value = holder[key];\n\n            if (value && typeof value === 'object') {\n              for (const k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                  const v = walk(value, k);\n\n                  if (v !== undefined) {\n                    value[k] = v;\n                  } else {\n                    delete value[k];\n                  }\n                }\n              }\n            }\n\n            return reviver.call(holder, key, value);\n          })({\n            '': result\n          }, '');\n          cb(result);\n          result = undefined;\n          if (retcode < 2) break;\n        }\n\n        if (retcode) this.finalError();\n      },\n\n      _write(msg, complete_at_end) {\n        let input;\n        let buf;\n        let retval = 0;\n\n        function throwError(leader, c) {\n          throw new Error(`${leader} '${String.fromCodePoint(c)}' unexpected at ${n} (near '${buf.substr(n > 4 ? n - 4 : 0, n > 4 ? 3 : n - 1)}[${String.fromCodePoint(c)}]${buf.substr(n, 10)}') [${pos.line}:${pos.col}]`);\n        }\n\n        function RESET_VAL() {\n          val.value_type = VALUE_UNSET;\n          val.string = '';\n        }\n\n        function arrayPush() {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              element_array.push((negative ? -1 : 1) * Number(val.string));\n              break;\n\n            case VALUE_STRING:\n              element_array.push(val.string);\n              break;\n\n            case VALUE_TRUE:\n              element_array.push(true);\n              break;\n\n            case VALUE_FALSE:\n              element_array.push(false);\n              break;\n\n            case VALUE_NEG_NAN:\n              element_array.push(-NaN);\n              break;\n\n            case VALUE_NAN:\n              element_array.push(NaN);\n              break;\n\n            case VALUE_NEG_INFINITY:\n              element_array.push(-Infinity);\n              break;\n\n            case VALUE_INFINITY:\n              element_array.push(Infinity);\n              break;\n\n            case VALUE_NULL:\n              element_array.push(null);\n              break;\n\n            case VALUE_UNDEFINED:\n              element_array.push(undefined);\n              break;\n\n            case VALUE_EMPTY:\n              element_array.push(undefined);\n              delete element_array[element_array.length - 1];\n              break;\n\n            case VALUE_OBJECT:\n              element_array.push(val.contains);\n              break;\n\n            case VALUE_ARRAY:\n              element_array.push(val.contains);\n              break;\n          }\n        }\n\n        function objectPush() {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              elements[val.name] = (negative ? -1 : 1) * Number(val.string);\n              break;\n\n            case VALUE_STRING:\n              elements[val.name] = val.string;\n              break;\n\n            case VALUE_TRUE:\n              elements[val.name] = true;\n              break;\n\n            case VALUE_FALSE:\n              elements[val.name] = false;\n              break;\n\n            case VALUE_NEG_NAN:\n              elements[val.name] = -NaN;\n              break;\n\n            case VALUE_NAN:\n              elements[val.name] = NaN;\n              break;\n\n            case VALUE_NEG_INFINITY:\n              elements[val.name] = -Infinity;\n              break;\n\n            case VALUE_INFINITY:\n              elements[val.name] = Infinity;\n              break;\n\n            case VALUE_NULL:\n              elements[val.name] = null;\n              break;\n\n            case VALUE_UNDEFINED:\n              elements[val.name] = undefined;\n              break;\n\n            case VALUE_OBJECT:\n              elements[val.name] = val.contains;\n              break;\n\n            case VALUE_ARRAY:\n              elements[val.name] = val.contains;\n              break;\n          }\n        }\n\n        function gatherString(start_c) {\n          let retval = 0;\n\n          while (retval == 0 && n < buf.length) {\n            let str = buf.charAt(n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              str += buf.charAt(n);\n              n++;\n            } //console.log( \"gathering....\", stringEscape, str, cInt, unicodeWide, stringHex, stringUnicode, hex_char_len );\n\n\n            pos.col++;\n\n            if (cInt == start_c) {\n              //( cInt == 34/*'\"'*/ ) || ( cInt == 39/*'\\''*/ ) || ( cInt == 96/*'`'*/ ) )\n              if (stringEscape) {\n                if (stringHex) throwError(\"Incomplete hexidecimal sequence\", cInt);else if (unicodeWide) throwError(\"Incomplete long unicode sequence\", cInt);else if (stringUnicode) throwError(\"Incomplete unicode sequence\", cInt);\n\n                if (cr_escaped) {\n                  cr_escaped = false; // \\\\ \\r  '  :end string, the backslash was used for \\r\n\n                  retval = 1; // complete string.\n                } else val.string += str; // escaped start quote\n\n\n                stringEscape = false;\n              } else {\n                // quote matches, not escaped, and not processing escape...\n                retval = 1;\n              }\n            } else if (stringEscape) {\n              if (unicodeWide) {\n                if (cInt == 125\n                /*'}'*/\n                ) {\n                    val.string += String.fromCodePoint(hex_char);\n                    unicodeWide = false;\n                    stringUnicode = false;\n                    stringEscape = false;\n                    continue;\n                  }\n\n                hex_char *= 16;\n                if (cInt >= 48\n                /*'0'*/\n                && cInt <= 57\n                /*'9'*/\n                ) hex_char += cInt - 0x30;else if (cInt >= 65\n                /*'A'*/\n                && cInt <= 70\n                /*'F'*/\n                ) hex_char += cInt - 65 + 10;else if (cInt >= 97\n                /*'a'*/\n                && cInt <= 102\n                /*'f'*/\n                ) hex_char += cInt - 97 + 10;else {\n                  throwError(\"(escaped character, parsing hex of \\\\u)\", cInt);\n                }\n                continue;\n              } else if (stringHex || stringUnicode) {\n                if (hex_char_len === 0 && cInt === 123\n                /*'{'*/\n                ) {\n                    unicodeWide = true;\n                    continue;\n                  }\n\n                hex_char *= 16;\n                if (cInt >= 48\n                /*'0'*/\n                && cInt <= 57\n                /*'9'*/\n                ) hex_char += cInt - 0x30;else if (cInt >= 65\n                /*'A'*/\n                && cInt <= 70\n                /*'F'*/\n                ) hex_char += cInt - 65 + 10;else if (cInt >= 97\n                /*'a'*/\n                && cInt <= 102\n                /*'f'*/\n                ) hex_char += cInt - 97 + 10;else {\n                  throwError(stringUnicode ? \"(escaped character, parsing hex of \\\\u)\" : \"(escaped character, parsing hex of \\\\x)\", cInt);\n                }\n                hex_char_len++;\n\n                if (stringUnicode) {\n                  if (hex_char_len == 4) {\n                    val.string += String.fromCodePoint(hex_char);\n                    stringUnicode = false;\n                    stringEscape = false;\n                  }\n                } else if (hex_char_len == 2) {\n                  val.string += String.fromCodePoint(hex_char);\n                  stringHex = false;\n                  stringEscape = false;\n                }\n\n                continue;\n              }\n\n              switch (cInt) {\n                case 13\n                /*'\\r'*/\n                :\n                  cr_escaped = true;\n                  pos.col = 1;\n                  continue;\n\n                case 0x2028: // LS (Line separator)\n\n                case 0x2029:\n                  // PS (paragraph separator)\n                  pos.col = 1;\n                // no return to get newline reset, so reset line pos.\n                // Fallthrough\n\n                case 10\n                /*'\\n'*/\n                :\n                  if (cr_escaped) {\n                    // \\\\ \\r \\n\n                    cr_escaped = false;\n                  } else {\n                    // \\\\ \\n\n                    pos.col = 1;\n                  }\n\n                  pos.line++;\n                  break;\n\n                case 116\n                /*'t'*/\n                :\n                  val.string += '\\t';\n                  break;\n\n                case 98\n                /*'b'*/\n                :\n                  val.string += '\\b';\n                  break;\n\n                case 48\n                /*'0'*/\n                :\n                  val.string += '\\0';\n                  break;\n\n                case 110\n                /*'n'*/\n                :\n                  val.string += '\\n';\n                  break;\n\n                case 114\n                /*'r'*/\n                :\n                  val.string += '\\r';\n                  break;\n\n                case 102\n                /*'f'*/\n                :\n                  val.string += '\\f';\n                  break;\n\n                case 120\n                /*'x'*/\n                :\n                  stringHex = true;\n                  hex_char_len = 0;\n                  hex_char = 0;\n                  continue;\n\n                case 117\n                /*'u'*/\n                :\n                  stringUnicode = true;\n                  hex_char_len = 0;\n                  hex_char = 0;\n                  continue;\n\n                default:\n                  val.string += str;\n                  break;\n              } //console.log( \"other...\" );\n\n\n              stringEscape = false;\n            } else if (cInt === 92\n            /*'\\\\'*/\n            ) {\n                stringEscape = true;\n              } else {\n              if (cr_escaped) {\n                cr_escaped = false; // \\\\ \\r <any other character>\n\n                pos.line++;\n                pos.col = 2; // newline, plus one character.\n              }\n\n              val.string += str;\n            }\n          }\n\n          return retval;\n        }\n\n        function collectNumber() {\n          let _n;\n\n          while ((_n = n) < buf.length) {\n            const str = buf.charAt(_n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              throwError(\"fault while parsing number;\", cInt);\n            } //log('_DEBUG_PARSING', \"in getting number:\", n, cInt, String.fromCodePoint(cInt) );\n\n\n            if (cInt == 95\n            /*_*/\n            ) continue;\n            pos.col++; // leading zeros should be forbidden.\n\n            if (cInt >= 48\n            /*'0'*/\n            && cInt <= 57\n            /*'9'*/\n            ) {\n                if (exponent) {\n                  exponent_digit = true;\n                }\n\n                val.string += str;\n              } else if (cInt == 45\n            /*'-'*/\n            || cInt == 43\n            /*'+'*/\n            ) {\n                if (val.string.length == 0 || exponent && !exponent_sign && !exponent_digit) {\n                  val.string += str;\n                  exponent_sign = true;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 46\n            /*'.'*/\n            ) {\n                if (!decimal && !fromHex && !exponent) {\n                  val.string += str;\n                  decimal = true;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 120\n            /*'x'*/\n            || cInt == 98\n            /*'b'*/\n            || cInt == 111\n            /*'o'*/\n            || cInt == 88\n            /*'X'*/\n            || cInt == 66\n            /*'B'*/\n            || cInt == 79\n            /*'O'*/\n            ) {\n                // hex conversion.\n                if (!fromHex && val.string == '0') {\n                  fromHex = true;\n                  val.string += str;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 101\n            /*'e'*/\n            || cInt == 69\n            /*'E'*/\n            ) {\n              if (!exponent) {\n                val.string += str;\n                exponent = true;\n              } else {\n                status = false;\n                throwError(\"fault while parsing number;\", cInt); // break;\n              }\n            } else {\n              if (cInt == 32\n              /*' '*/\n              || cInt == 160\n              /* &nbsp */\n              || cInt == 13 || cInt == 10 || cInt == 9 || cInt == 0xFEFF || cInt == 44\n              /*','*/\n              || cInt == 125\n              /*'}'*/\n              || cInt == 93\n              /*']'*/\n              || cInt == 58\n              /*':'*/\n              ) {\n                  break;\n                } else {\n                if (complete_at_end) {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt);\n                }\n\n                break;\n              }\n            }\n          }\n\n          n = _n;\n\n          if (!complete_at_end && n == buf.length) {\n            gatheringNumber = true;\n          } else {\n            gatheringNumber = false;\n            val.value_type = VALUE_NUMBER;\n\n            if (parse_context == CONTEXT_UNKNOWN) {\n              completed = true;\n            }\n          }\n        }\n\n        if (!status) return -1;\n\n        if (msg && msg.length) {\n          input = getBuffer();\n          input.buf = msg;\n          inQueue.push(input);\n        } else {\n          if (gatheringNumber) {\n            //console.log( \"Force completed.\")\n            gatheringNumber = false;\n            val.value_type = VALUE_NUMBER;\n\n            if (parse_context == CONTEXT_UNKNOWN) {\n              completed = true;\n            } else {\n              throw new Error(\"context stack is not empty at flush\");\n            }\n\n            retval = 1; // if returning buffers, then obviously there's more in this one.\n          }\n        }\n\n        while (status && (input = inQueue.shift())) {\n          n = input.n;\n          buf = input.buf;\n\n          if (gatheringString) {\n            const string_status = gatherString(gatheringStringFirstChar);\n\n            if (string_status > 0) {\n              gatheringString = false;\n              val.value_type = VALUE_STRING;\n            }\n          }\n\n          if (gatheringNumber) {\n            collectNumber();\n          }\n\n          while (!completed && status && n < buf.length) {\n            let str = buf.charAt(n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              str += buf.charAt(n);\n              n++;\n            } //// log('_DEBUG_PARSING', \"parsing at \", cInt, str );\n            //log('_DEBUG_LL', \"processing: \", cInt, str, pos, comment, parse_context, word, val );\n\n\n            pos.col++;\n\n            if (comment) {\n              // '/'\n              if (comment == 1) {\n                // '/'\n                if (cInt == 42\n                /*'*'*/\n                ) {\n                    comment = 3;\n                  } // '/*'\n                else if (cInt != 47\n                  /*'/'*/\n                  ) {\n                      // '//'(NOT)\n                      throwError(\"fault while parsing;\", cInt);\n                    } else comment = 2; // '//' (valid)\n\n              } else if (comment == 2) {\n                // '// ...'\n                if (cInt == 10\n                /*'\\n'*/\n                || cInt == 13\n                /*'\\r'*/\n                ) comment = 0;\n              } else if (comment == 3) {\n                // '/*... '\n                if (cInt == 42\n                /*'*'*/\n                ) comment = 4;\n              } else {\n                // if( comment == 4 ) { // '/* ... *'\n                if (cInt == 47\n                /*'/'*/\n                ) comment = 0;else comment = 3; // any other char, goto expect * to close */\n              }\n\n              continue;\n            }\n\n            switch (cInt) {\n              case 47\n              /*'/'*/\n              :\n                comment = 1;\n                break;\n\n              case 123\n              /*'{'*/\n              :\n                if (word == WORD_POS_FIELD || word == WORD_POS_AFTER_FIELD || parse_context == CONTEXT_OBJECT_FIELD && word == WORD_POS_RESET) {\n                  throwError(\"fault while parsing; getting field name unexpected \", cInt); // break;\n                }\n\n                {\n                  const old_context = getContext(); //log('_DEBUG_PARSING', \"Begin a new object; previously pushed into elements; but wait until trailing comma or close previously:%d\", val.value_type );\n\n                  val.value_type = VALUE_OBJECT;\n                  const tmpobj = {};\n                  if (parse_context == CONTEXT_UNKNOWN) result = elements = tmpobj;\n                  old_context.context = parse_context;\n                  old_context.elements = elements;\n                  old_context.element_array = element_array;\n                  old_context.name = val.name;\n                  elements = tmpobj; //log('_DEBUG_PARSING_STACK',\"push context (open object): \", context_stack.length );\n\n                  context_stack.push(old_context);\n                  RESET_VAL();\n                  parse_context = CONTEXT_OBJECT_FIELD;\n                }\n                break;\n\n              case 91\n              /*'['*/\n              :\n                if (parse_context == CONTEXT_OBJECT_FIELD || word == WORD_POS_FIELD || word == WORD_POS_AFTER_FIELD) {\n                  throwError(\"Fault while parsing; while getting field name unexpected\", cInt); // break;\n                }\n\n                if (val.value_type == VALUE_UNSET || val.value_type == VALUE_UNDEFINED) {\n                  const old_context = getContext(); //log('_DEBUG_PARSING', \"Begin a new array; previously pushed into elements; but wait until trailing comma or close previously:%d\", val.value_type );\n\n                  val.value_type = VALUE_ARRAY;\n                  const tmparr = [];\n                  if (parse_context == CONTEXT_UNKNOWN) result = element_array = tmparr; //else if( parse_context == CONTEXT_IN_ARRAY )\n                  //    element_array.push( tmparr );\n                  else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) elements[val.name] = tmparr;\n                  old_context.context = parse_context;\n                  old_context.elements = elements;\n                  old_context.element_array = element_array;\n                  old_context.name = val.name;\n                  element_array = tmparr; //log('_DEBUG_PARSING_STACK', \"push context (open array): \", context_stack.length );\n\n                  context_stack.push(old_context);\n                  RESET_VAL();\n                  parse_context = CONTEXT_IN_ARRAY;\n                } else {\n                  throwError(\"Unexpected array open after previous value\", cInt);\n                }\n\n                break;\n\n              case 58\n              /*':'*/\n              :\n                ////log('_DEBUG_PARSING', \"colon context:\", parse_context );\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  word = WORD_POS_RESET;\n                  val.name = val.string;\n                  val.string = '';\n                  parse_context = CONTEXT_OBJECT_FIELD_VALUE;\n                  val.value_type = VALUE_UNSET;\n                } else {\n                  if (parse_context == CONTEXT_IN_ARRAY) throwError(\"(in array, got colon out of string):parsing fault;\", cInt);else throwError(\"(outside any object, got colon out of string):parsing fault;\", cInt);\n                }\n\n                break;\n\n              case 125\n              /*'}'*/\n              :\n                ////log('_DEBUG_PARSING', \"close bracket context:\", word, parse_context );\n                if (word == WORD_POS_END) {\n                  // allow starting a new word\n                  word = WORD_POS_RESET;\n                } // coming back after pushing an array or sub-object will reset the context to FIELD, so an end with a field should still push value.\n\n\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  //log('_DEBUG_PARSING', \"close object; empty object %d\", val.value_type );\n                  //RESET_VAL();\n                  val.value_type = VALUE_OBJECT;\n                  val.contains = elements;\n                  const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close obj)\", context_stack.length, old_context );\n\n                  val.name = old_context.name;\n                  parse_context = old_context.context; // this will restore as IN_ARRAY or OBJECT_FIELD\n\n                  elements = old_context.elements;\n                  element_array = old_context.element_array;\n                  dropContext(old_context);\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) {\n                  // first, add the last value\n                  //log('_DEBUG_PARSING', \"close object; push item '%s' %d\", val.name, val.value_type );\n                  if (val.value_type != VALUE_UNSET) {\n                    objectPush();\n                  } else {\n                    throwError(\"Fault while parsing field value, close with no value\", cInt);\n                  }\n\n                  val.value_type = VALUE_OBJECT;\n                  val.contains = elements;\n                  const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close object)\", context_stack.length, old_context );\n\n                  val.name = old_context.name;\n                  parse_context = old_context.context; // this will restore as IN_ARRAY or OBJECT_FIELD\n\n                  elements = old_context.elements;\n                  element_array = old_context.element_array;\n                  dropContext(old_context);\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else {\n                  throwError(\"Fault while parsing; unexpected\", cInt);\n                }\n\n                negative = false;\n                break;\n\n              case 93\n              /*']'*/\n              :\n                if (word == WORD_POS_END) word = WORD_POS_RESET;\n\n                if (parse_context == CONTEXT_IN_ARRAY) {\n                  //log('_DEBUG_PARSING', \"close array, push last element: %d\", val.value_type );\n                  if (val.value_type != VALUE_UNSET) {\n                    arrayPush();\n                  }\n\n                  val.value_type = VALUE_ARRAY;\n                  val.contains = element_array;\n                  {\n                    const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close array)\", context_stack.length );\n\n                    val.name = old_context.name;\n                    parse_context = old_context.context;\n                    elements = old_context.elements;\n                    element_array = old_context.element_array;\n                    dropContext(old_context);\n                  }\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else {\n                  throwError(`bad context ${parse_context}; fault while parsing`, cInt); // fault\n                }\n\n                negative = false;\n                break;\n\n              case 44\n              /*','*/\n              :\n                if (word == WORD_POS_END) word = WORD_POS_RESET; // allow collect new keyword\n                //log('_DEBUG_PARSING', \"comma context:\", parse_context, val );\n\n                if (parse_context == CONTEXT_IN_ARRAY) {\n                  if (val.value_type == VALUE_UNSET) val.value_type = VALUE_EMPTY; // in an array, elements after a comma should init as undefined...\n                  //log('_DEBUG_PARSING', \"back in array; push item %d\", val.value_type );\n\n                  arrayPush();\n                  RESET_VAL(); // undefined allows [,,,] to be 4 values and [1,2,3,] to be 4 values with an undefined at end.\n                } else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) {\n                  // after an array value, it will have returned to OBJECT_FIELD anyway\n                  //log('_DEBUG_PARSING', \"comma after field value, push field to object: %s\", val.name );\n                  parse_context = CONTEXT_OBJECT_FIELD;\n\n                  if (val.value_type != VALUE_UNSET) {\n                    objectPush();\n                    RESET_VAL();\n                  } else throwError(\"Unexpected comma after object field name\", cInt);\n                } else {\n                  status = false;\n                  throwError(\"bad context; excessive commas while parsing;\", cInt); // fault\n                }\n\n                negative = false;\n                break;\n\n              default:\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  switch (cInt) {\n                    case 96: //'`':\n\n                    case 34: //'\"':\n\n                    case 39:\n                      //'\\'':\n                      if (word == WORD_POS_RESET) {\n                        if (val.value_type != VALUE_UNSET) throwError(\"String begin after previous value\", cInt);\n                        const string_status = gatherString(cInt); //log('_DEBUG_PARSING', \"string gather for object field name :\", val.string, string_status );\n\n                        if (string_status) {\n                          val.value_type = VALUE_STRING;\n                        } else {\n                          gatheringStringFirstChar = cInt;\n                          gatheringString = true;\n                        }\n                      } else {\n                        throwError(\"fault while parsing; quote not at start of field name\", cInt);\n                      }\n\n                      break;\n\n                    case 10:\n                      //'\\n':\n                      pos.line++;\n                      pos.col = 1;\n                    // fall through to normal space handling - just updated line/col position\n\n                    case 13: //'\\r':\n\n                    case 32: //' ':\n\n                    case 160: //&nbsp:\n\n                    case 9: //'\\t':\n\n                    case 0xFEFF:\n                      // ZWNBS is WS though\n                      if (word == WORD_POS_END) {\n                        // allow collect new keyword\n                        word = WORD_POS_RESET;\n                      } else if (word == WORD_POS_FIELD) {\n                        word = WORD_POS_AFTER_FIELD;\n                      } // skip whitespace\n\n\n                      break;\n\n                    default:\n                      if (word == WORD_POS_AFTER_FIELD) {\n                        status = false;\n                        throwError(\"fault while parsing; character unexpected\", cInt);\n                      }\n\n                      if (word == WORD_POS_RESET) word = WORD_POS_FIELD;\n                      val.string += str;\n                      break;\n                    // default\n                  }\n                } else switch (cInt) {\n                  case 96: //'`':\n\n                  case 34: //'\"':\n\n                  case 39:\n                    {\n                      //'\\'':\n                      if (val.value_type === VALUE_UNSET) {\n                        const string_status = gatherString(cInt); //log('_DEBUG_PARSING', \"string gather for object field value :\", val.string, string_status, completed, input.n, buf.length );\n\n                        if (string_status) {\n                          val.value_type = VALUE_STRING;\n                          word = WORD_POS_END;\n                        } else {\n                          gatheringStringFirstChar = cInt;\n                          gatheringString = true;\n                        }\n                      } else throwError(\"String unexpected\", cInt);\n\n                      break;\n                    }\n\n                  case 10:\n                    //'\\n':\n                    pos.line++;\n                    pos.col = 1;\n                  // Fallthrough\n\n                  case 32: //' ':\n\n                  case 160: // &nbsp\n\n                  case 9: //'\\t':\n\n                  case 13: //'\\r':\n\n                  case 0xFEFF:\n                    //'\\uFEFF':\n                    if (word == WORD_POS_END) {\n                      word = WORD_POS_RESET;\n\n                      if (parse_context == CONTEXT_UNKNOWN) {\n                        completed = true;\n                      }\n\n                      break;\n                    }\n\n                    if (word !== WORD_POS_RESET) {\n                      // breaking in the middle of gathering a keyword.\n                      status = false;\n                      throwError(\"fault parsing whitespace\", cInt);\n                    }\n\n                    break;\n                  //----------------------------------------------------------\n                  //  catch characters for true/false/null/undefined which are values outside of quotes\n\n                  case 116:\n                    //'t':\n                    if (word == WORD_POS_RESET) word = WORD_POS_TRUE_1;else if (word == WORD_POS_INFINITY_6) word = WORD_POS_INFINITY_7;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 114:\n                    //'r':\n                    if (word == WORD_POS_TRUE_1) word = WORD_POS_TRUE_2;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 117:\n                    //'u':\n                    if (word == WORD_POS_TRUE_2) word = WORD_POS_TRUE_3;else if (word == WORD_POS_NULL_1) word = WORD_POS_NULL_2;else if (word == WORD_POS_RESET) word = WORD_POS_UNDEFINED_1;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 101:\n                    //'e':\n                    if (word == WORD_POS_TRUE_3) {\n                      val.value_type = VALUE_TRUE;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_FALSE_4) {\n                      val.value_type = VALUE_FALSE;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_UNDEFINED_3) word = WORD_POS_UNDEFINED_4;else if (word == WORD_POS_UNDEFINED_7) word = WORD_POS_UNDEFINED_8;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n\n                    break;\n\n                  case 110:\n                    //'n':\n                    if (word == WORD_POS_RESET) word = WORD_POS_NULL_1;else if (word == WORD_POS_UNDEFINED_1) word = WORD_POS_UNDEFINED_2;else if (word == WORD_POS_UNDEFINED_6) word = WORD_POS_UNDEFINED_7;else if (word == WORD_POS_INFINITY_1) word = WORD_POS_INFINITY_2;else if (word == WORD_POS_INFINITY_4) word = WORD_POS_INFINITY_5;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 100:\n                    //'d':\n                    if (word == WORD_POS_UNDEFINED_2) word = WORD_POS_UNDEFINED_3;else if (word == WORD_POS_UNDEFINED_8) {\n                      val.value_type = VALUE_UNDEFINED;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 105:\n                    //'i':\n                    if (word == WORD_POS_UNDEFINED_5) word = WORD_POS_UNDEFINED_6;else if (word == WORD_POS_INFINITY_3) word = WORD_POS_INFINITY_4;else if (word == WORD_POS_INFINITY_5) word = WORD_POS_INFINITY_6;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 108:\n                    //'l':\n                    if (word == WORD_POS_NULL_2) word = WORD_POS_NULL_3;else if (word == WORD_POS_NULL_3) {\n                      val.value_type = VALUE_NULL;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_FALSE_2) word = WORD_POS_FALSE_3;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 102:\n                    //'f':\n                    if (word == WORD_POS_RESET) word = WORD_POS_FALSE_1;else if (word == WORD_POS_UNDEFINED_4) word = WORD_POS_UNDEFINED_5;else if (word == WORD_POS_INFINITY_2) word = WORD_POS_INFINITY_3;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 97:\n                    //'a':\n                    if (word == WORD_POS_FALSE_1) word = WORD_POS_FALSE_2;else if (word == WORD_POS_NAN_1) word = WORD_POS_NAN_2;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 115:\n                    //'s':\n                    if (word == WORD_POS_FALSE_3) word = WORD_POS_FALSE_4;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 73:\n                    //'I':\n                    if (word == WORD_POS_RESET) word = WORD_POS_INFINITY_1;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 78:\n                    //'N':\n                    if (word == WORD_POS_RESET) word = WORD_POS_NAN_1;else if (word == WORD_POS_NAN_2) {\n                      val.value_type = negative ? VALUE_NEG_NAN : VALUE_NAN;\n                      negative = false;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 121:\n                    //'y':\n                    if (word == WORD_POS_INFINITY_7) {\n                      val.value_type = negative ? VALUE_NEG_INFINITY : VALUE_INFINITY;\n                      negative = false;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n\n                    break;\n\n                  case 45:\n                    //'-':\n                    if (word == WORD_POS_RESET) negative = !negative;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n                  //\n                  //----------------------------------------------------------\n\n                  default:\n                    if (cInt >= 48\n                    /*'0'*/\n                    && cInt <= 57\n                    /*'9'*/\n                    || cInt == 43\n                    /*'+'*/\n                    || cInt == 46\n                    /*'.'*/\n                    || cInt == 45\n                    /*'-'*/\n                    ) {\n                      fromHex = false;\n                      exponent = false;\n                      exponent_sign = false;\n                      exponent_digit = false;\n                      decimal = false;\n                      val.string = str;\n                      input.n = n;\n                      collectNumber();\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    }\n\n                    break;\n                  // default\n                }\n\n                break;\n              // default of high level switch\n            }\n\n            if (completed) {\n              if (word == WORD_POS_END) {\n                word = WORD_POS_RESET;\n              }\n\n              break;\n            }\n          }\n\n          if (n == buf.length) {\n            dropBuffer(input);\n\n            if (gatheringString || gatheringNumber || parse_context == CONTEXT_OBJECT_FIELD) {\n              retval = 0;\n            } else {\n              if (parse_context == CONTEXT_UNKNOWN && (val.value_type != VALUE_UNSET || result)) {\n                completed = true;\n                retval = 1;\n              }\n            }\n          } else {\n            // put these back into the stack.\n            input.n = n;\n            inQueue.unshift(input);\n            retval = 2; // if returning buffers, then obviously there's more in this one.\n          }\n\n          if (completed) break;\n        }\n\n        if (completed && val.value_type != VALUE_UNSET) {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              result = (negative ? -1 : 1) * Number(val.string);\n              break;\n\n            case VALUE_STRING:\n              result = val.string;\n              break;\n\n            case VALUE_TRUE:\n              result = true;\n              break;\n\n            case VALUE_FALSE:\n              result = false;\n              break;\n\n            case VALUE_NULL:\n              result = null;\n              break;\n\n            case VALUE_UNDEFINED:\n              result = undefined;\n              break;\n\n            case VALUE_NAN:\n              result = NaN;\n              break;\n\n            case VALUE_NEG_NAN:\n              result = -NaN;\n              break;\n\n            case VALUE_INFINITY:\n              result = Infinity;\n              break;\n\n            case VALUE_NEG_INFINITY:\n              result = -Infinity;\n              break;\n\n            case VALUE_OBJECT:\n              // never happens\n              result = val.contains;\n              break;\n\n            case VALUE_ARRAY:\n              // never happens\n              result = val.contains;\n              break;\n          }\n\n          negative = false;\n          val.string = '';\n          val.value_type = VALUE_UNSET;\n        }\n\n        completed = false;\n        return retval;\n      }\n\n    };\n  };\n\n  const _parser = [Object.freeze(JSON6.begin())];\n  let _parse_level = 0;\n\n  JSON6.parse = function (msg, reviver) {\n    //var parser = JSON6.begin();\n    const parse_level = _parse_level++;\n    if (_parser.length <= parse_level) _parser.push(Object.freeze(JSON6.begin()));\n    const parser = _parser[parse_level];\n    if (typeof msg !== \"string\") msg = String(msg);\n    parser.reset();\n\n    if (parser._write(msg, true) > 0) {\n      const result = parser.value();\n      if (typeof reviver === 'function') (function walk(holder, key) {\n        const value = holder[key];\n\n        if (value && typeof value === 'object') {\n          for (const k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k)) {\n              const v = walk(value, k);\n\n              if (v !== undefined) {\n                value[k] = v;\n              } else {\n                delete value[k];\n              }\n            }\n          }\n        }\n\n        return reviver.call(holder, key, value);\n      })({\n        '': result\n      }, '');\n      _parse_level--;\n      return result;\n    } else parser.finalError();\n\n    return undefined;\n  };\n\n  JSON6.stringify = JSON.stringify;\n});\n\nvar lib = json6;\n\nexport default lib;\n","// We want it to work in the browser, so commenting out\n// import jsonExtra from 'json5';\n// import jsonExtra from 'json-6';\n\n// We need this for the browser version to work, but this breaks nyc;\n//  see https://github.com/standard-things/esm/issues/839\n// import jsonExtra from '../node_modules/json-6/dist/index.mjs';\nimport jsonExtra from 'json-6';\n\nexport const unescapeBackslashes = (str) => {\n  return str.replace(/\\\\+/gu, (esc) => {\n    return esc.slice(0, esc.length / 2);\n  });\n};\n\nexport const parseJSONExtra = (args) => {\n  return jsonExtra.parse(\n    // Doesn't actually currently allow explicit brackets,\n    //  but in case we change our regex to allow inner brackets\n    '{' + (args || '').replace(/^\\{/u, '').replace(/\\}$/u, '') + '}'\n  );\n};\n\n// Todo: Extract to own library (RegExtras?)\nexport const processRegex = (regex, str, {\n  onMatch,\n  extra,\n  betweenMatches,\n  afterMatch,\n  escapeAtOne\n}) => {\n  let match;\n  let previousIndex = 0;\n  if (extra) {\n    betweenMatches = extra;\n    afterMatch = extra;\n    escapeAtOne = extra;\n  }\n  while ((match = regex.exec(str)) !== null) {\n    const [_, esc] = match;\n    const {lastIndex} = regex;\n\n    const startMatchPos = lastIndex - _.length;\n    if (startMatchPos > previousIndex) {\n      betweenMatches(str.slice(previousIndex, startMatchPos));\n    }\n\n    if (escapeAtOne && esc.length % 2) {\n      previousIndex = lastIndex;\n      escapeAtOne(_);\n      continue;\n    }\n    onMatch(...match);\n    previousIndex = lastIndex;\n  }\n  if (previousIndex !== str.length) { // Get text at end\n    afterMatch(str.slice(previousIndex));\n  }\n};\n","/* globals fetch, document */\nlet _fetch = typeof fetch !== 'undefined'\n  // istanbul ignore next\n  ? fetch\n  : null;\n\n/**\n * @param {fetch} f\n * @returns {void}\n */\nexport const setFetch = (f) => {\n  _fetch = f;\n};\n\n/**\n * @returns {fetch}\n */\nexport const getFetch = () => {\n  return _fetch;\n};\n\nlet _doc = typeof document !== 'undefined'\n  // istanbul ignore next\n  ? document\n  : null;\n\n/**\n * @param {document} doc\n * @returns {void}\n */\nexport const setDocument = (doc) => {\n  _doc = doc;\n};\n\n/**\n * @returns {document}\n */\nexport const getDocument = () => {\n  return _doc;\n};\n","/* globals performance */\nimport {processRegex} from './utils.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/**\n *\n * @returns {string}\n */\nfunction generateUUID () { //  Adapted from original: public domain/MIT: http://stackoverflow.com/a/8809472/271577\n  let d = new Date().getTime();\n  /* istanbul ignore next */\n  if (typeof performance !== 'undefined' &&\n      typeof performance.now === 'function'\n  ) {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, function (c) {\n    /* eslint-disable no-bitwise */\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n    /* eslint-enable no-bitwise */\n  });\n}\n\nexport const sort = (locale, arrayOfItems, options) => {\n  return arrayOfItems.sort(new Intl.Collator(\n    locale,\n    options\n  ).compare);\n};\n\nexport const list = (locale, arrayOfItems, options) => {\n  return new Intl.ListFormat(\n    locale, options\n  ).format(arrayOfItems);\n};\n\nexport const sortListSimple = (\n  locale, arrayOfItems, listOptions, collationOptions\n) => {\n  sort(locale, arrayOfItems, collationOptions);\n  return list(locale, arrayOfItems, listOptions);\n};\n\nexport const sortList = (\n  locale, arrayOfItems, map, listOptions, collationOptions\n) => {\n  if (typeof map !== 'function') {\n    return sortListSimple(locale, arrayOfItems, map, listOptions);\n  }\n  sort(locale, arrayOfItems, collationOptions);\n\n  const randomId = generateUUID();\n\n  const placeholderArray = [...arrayOfItems].map(\n    (_, i) => `<<${randomId}${i}>>`\n  );\n  const nodes = [];\n  const push = (...args) => {\n    nodes.push(...args);\n  };\n\n  processRegex(\n    // // eslint-disable-next-line prefer-named-capture-group\n    new RegExp(`<<${randomId}(\\\\d)>>`, 'gu'),\n    list(locale, placeholderArray, listOptions), {\n      betweenMatches: push,\n      afterMatch: push,\n      onMatch (_, idx) {\n        push(map(arrayOfItems[idx], idx));\n      }\n    }\n  );\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n  return container;\n};\n","import {parseJSONExtra} from './utils.js';\nimport {sortList} from './collation.js';\n\nexport const getFormatterInfo = ({object}) => {\n  if (Array.isArray(object)) {\n    if (typeof object[1] === 'function') {\n      const [value, callback, options, extraOpts] = object;\n      return {value, callback, options, extraOpts};\n    }\n    const [value, options, extraOpts] = object;\n    return {value, options, extraOpts};\n  }\n  return {value: object};\n};\n\n/* eslint-disable max-len */\n/**\n * Callback to give replacement text based on a substitution value.\n * @callback AllSubstitutionCallback\n * @param {PlainObject} cfg\n * @param {string|Node|number|Date|RelativeTimeInfo|ListInfo|NumberInfo|DateInfo} cfg.value Contains\n *   the value returned by the individual substitution\n * @param {string} cfg.arg See `cfg.arg` of {@link SubstitutionCallback}.\n * @param {string} cfg.key The substitution key Not currently in use\n * @param {string} cfg.locale The locale\n * @returns {string|Element} The replacement text or element\n*/\n/* eslint-enable max-len */\n\n/**\n * @type {AllSubstitutionCallback}\n */\nexport const defaultAllSubstitutions = ({value, arg, key, locale}) => {\n  // Strings or DOM Nodes\n  if (\n    typeof value === 'string' || (value && typeof value === 'object' &&\n    'nodeType' in value)\n  ) {\n    return value;\n  }\n\n  let opts;\n\n  const applyArgs = ({type, options = opts, checkArgOptions = false}) => {\n    if (typeof arg === 'string') {\n      let [userType, extraArgs, argOptions] = arg.split('|');\n      // Alias\n      if (userType === 'DATE') {\n        userType = 'DATETIME';\n      }\n      if (userType === type) {\n        if (!extraArgs) {\n          options = {};\n        } else if (!checkArgOptions || argOptions) {\n          // Todo: Allow escaping and restoring of pipe symbol\n          options = {\n            ...options,\n            ...parseJSONExtra(\n              checkArgOptions && argOptions ? argOptions : extraArgs\n            )\n          };\n        }\n      }\n    }\n    return options;\n  };\n\n  if (value && typeof value === 'object') {\n    const singleKey = Object.keys(value)[0];\n    if ([\n      'number', 'date', 'datetime', 'relative', 'list', 'plural'\n    ].includes(singleKey)) {\n      let extraOpts, callback;\n      ({\n        value, options: opts, extraOpts, callback\n      } = getFormatterInfo({object: value[singleKey]}));\n\n      switch (singleKey) {\n      case 'relative':\n        // The second argument actually contains the primary options, so swap\n        [extraOpts, opts] = [opts, extraOpts];\n        return new Intl.RelativeTimeFormat(\n          locale, applyArgs({type: 'RELATIVE'})\n        ).format(value, extraOpts);\n\n      // ListFormat (with Collator)\n      case 'list':\n        if (callback) {\n          return sortList(\n            locale, value, callback,\n            applyArgs({type: 'LIST'}),\n            applyArgs({\n              type: 'LIST', options: extraOpts, checkArgOptions: true\n            })\n          );\n        }\n        return sortList(locale, value, applyArgs({type: 'LIST'}), applyArgs({\n          type: 'LIST', options: extraOpts, checkArgOptions: true\n        }));\n      default:\n        // Let `number` and `date` types drop through so their options\n        //  can be applied\n        // Let `plural` be treated as number (since value should be a number)\n        break;\n      }\n    }\n  }\n\n  // Numbers\n  if (typeof value === 'number') {\n    return new Intl.NumberFormat(\n      locale,\n      applyArgs({type: 'NUMBER'})\n    ).format(value);\n  }\n\n  // Dates\n  if (\n    value && typeof value === 'object' &&\n    typeof value.getTime === 'function'\n  ) {\n    return new Intl.DateTimeFormat(\n      locale,\n      applyArgs({type: 'DATETIME'})\n    ).format(value);\n  }\n\n  // console.log('value', value);\n  throw new TypeError('Unknown formatter');\n};\n","import {getMessageForKeyByStyle} from './index.js';\nimport {parseJSONExtra} from './utils.js';\nimport {getFormatterInfo} from './defaultAllSubstitutions.js';\n\n/**\n * Base class for formatting.\n */\nexport class Formatter {\n}\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.key\n * @param {LocaleBody} cfg.body\n * @param {string} cfg.type\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} cfg.messageStyle\n * @returns {string|Element}\n */\nconst getSubstitution = ({key, body, type, messageStyle = 'richNested'}) => {\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const substitution = messageForKey({body}, key);\n  if (!substitution) {\n    throw new Error(`Key value not found for ${type} key: (${key})`);\n  }\n  // We don't allow a substitution function here or below as comes\n  //  from locale and locale content should not pose security concerns\n  return substitution.value;\n};\n\n/**\n * Formatter for local variables.\n */\nexport class LocalFormatter extends Formatter {\n  /**\n   * @param {LocalObject} locals\n   */\n  constructor (locals) {\n    super();\n    this.locals = locals;\n  }\n  /**\n   * @param {string} key\n   * @returns {string|Element}\n   */\n  getSubstitution (key) {\n    return getSubstitution({\n      key: key.slice(1), body: this.locals, type: 'local'\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    const components = key.slice(1).split('.');\n    let parent = this.locals;\n    return this.constructor.isMatchingKey(key) && components.every((cmpt) => {\n      const result = cmpt in parent;\n      parent = parent[cmpt];\n      return result;\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('-');\n  }\n}\n\n/**\n * Formatter for regular variables.\n */\nexport class RegularFormatter extends Formatter {\n  /**\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (substitutions) {\n    super();\n    this.substitutions = substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return this.constructor.isMatchingKey(key) && key in this.substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return (/^\\w/u).test(key);\n  }\n}\n\n/**\n * Formatter for switch variables.\n */\nexport class SwitchFormatter extends Formatter {\n  /**\n   * @param {Switches} switches\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (switches, {substitutions}) {\n    super();\n    this.switches = switches;\n    this.substitutions = substitutions;\n  }\n\n  /**\n   * @param {string} key\n   * @param {PlainObject} cfg\n   * @param {string} cfg.locale\n   * @param {string[]} cfg.usedKeys\n   * @param {string} cfg.arg\n   * @param {MissingSuppliedFormattersCallback} cfg.missingSuppliedFormatters\n   * @returns {string}\n   */\n  getSubstitution (key, {locale, usedKeys, arg, missingSuppliedFormatters}) {\n    const ky = this.constructor.getKey(key).slice(1);\n    // Expression might not actually use formatter, e.g., for singular,\n    //  the conditional might just write out \"one\"\n\n    const [objKey, body, keySegment] = this.getMatch(ky);\n    usedKeys.push(keySegment);\n\n    let type, opts;\n    if (objKey && objKey.includes('|')) {\n      [, type, opts] = objKey.split('|');\n    }\n    if (!body) {\n      missingSuppliedFormatters({\n        key,\n        formatter: this\n      });\n      return '\\\\{' + key + '}';\n    }\n\n    /*\n    if (!(ky in this.substitutions)) {\n      throw new Error(`Switch expecting formatter: ${ky}`);\n    }\n    */\n\n    const getNumberFormat = (value, defaultOptions) => {\n      const numberOpts = parseJSONExtra(opts);\n      return new Intl.NumberFormat(locale, {\n        ...defaultOptions, ...numberOpts\n      }).format(value);\n    };\n\n    const getPluralFormat = (value, defaultOptions) => {\n      const pluralOpts = parseJSONExtra(opts);\n      return new Intl.PluralRules(locale, {\n        ...defaultOptions, ...pluralOpts\n      }).select(value);\n    };\n\n    const formatterValue = this.substitutions[keySegment];\n\n    let match = formatterValue;\n    if (typeof formatterValue === 'number') {\n      switch (type) {\n      case 'NUMBER':\n        match = getNumberFormat(formatterValue);\n        break;\n      case 'PLURAL':\n        match = getPluralFormat(formatterValue);\n        break;\n      default:\n        match = new Intl.PluralRules(locale).select(formatterValue);\n        break;\n      }\n    } else if (formatterValue && typeof formatterValue === 'object') {\n      const singleKey = Object.keys(formatterValue)[0];\n      if (['number', 'plural'].includes(singleKey)) {\n        const {value, options} = getFormatterInfo({\n          object: formatterValue[singleKey]\n        });\n        if (!type) {\n          type = singleKey.toUpperCase();\n        }\n        const typeMatches = singleKey.toUpperCase() === type;\n        if (!typeMatches) {\n          throw new TypeError(\n            `Expecting type \"${\n              type.toLowerCase()\n            }\"; instead found \"${singleKey}\".`\n          );\n        }\n        // eslint-disable-next-line default-case\n        switch (type) {\n        case 'NUMBER':\n          match = getNumberFormat(value, options);\n          break;\n        case 'PLURAL':\n          match = getPluralFormat(value, options);\n          break;\n        }\n      }\n    }\n\n    // We do not want the default `richNested` here as that will split\n    //  up the likes of `0.0`\n    const messageStyle = 'richNested';\n\n    const preventNesting = (s) => {\n      return s.replace(/\\\\/gu, '\\\\\\\\').replace(/\\./gu, '\\\\.');\n    };\n\n    try {\n      return getSubstitution({\n        messageStyle,\n        key: match ? preventNesting(match) : arg,\n        body,\n        type: 'switch'\n      });\n    } catch (err) {\n      try {\n        return getSubstitution({\n          messageStyle, key: '*' + preventNesting(match), body, type: 'switch'\n        });\n      } catch (error) {\n        const k = Object.keys(body).find(\n          (switchKey) => switchKey.startsWith('*')\n        );\n        if (!k) {\n          throw new Error(`No defaults found for switch ${ky}`);\n        }\n        return getSubstitution({\n          messageStyle, key: preventNesting(k), body, type: 'switch'\n        });\n      }\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return key && this.constructor.isMatchingKey(key) &&\n      Boolean(this.getMatch(key.slice(1)).length);\n  }\n\n  /**\n  * @typedef {GenericArray} SwitchMatch\n  * @property {string} 0 objKey\n  * @property {LocaleBody} 1 body\n  * @property {string} 2 keySegment\n  */\n\n  /**\n   * @param {string} ky\n   * @returns {SwitchMatch}\n   */\n  getMatch (ky) {\n    const ks = ky.split('.');\n    return ks.reduce((obj, k, i) => {\n      if (i < ks.length - 1) {\n        if (!(k in obj)) {\n          throw new Error(`Switch key \"${k}\" not found (from \"~${ky}\")`);\n        }\n        return obj[k];\n      }\n      // Todo: Should throw on encountering duplicate fundamental keys (even\n      //  if there are different arguments, that should not be allowed)\n      const ret = Object.entries(obj).find(([switchKey]) => {\n        return k === this.constructor.getKey(switchKey);\n      });\n\n      return ret ? ret.concat(k) : [];\n    }, this.switches);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('~');\n  }\n  /**\n   * @param {string} key\n   * @returns {string}\n   */\n  static getKey (key) {\n    const match = key.match(/^[^|]*/u);\n    return match && match[0];\n  }\n}\n","/**\n* @callback PromiseChainErrback\n* @param {any} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @param {string} [errorMessage=\"Reached end of values array.\"]\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\n promiseChainForValues(['a', 'b', 'c'], (val) => {\n   return new Promise(function (resolve, reject) {\n     if (val === 'a') {\n       reject(new Error('missing'));\n     }\n     setTimeout(() => {\n       resolve(val);\n     }, 100);\n   });\n });\n */\nexport const promiseChainForValues = (\n  values, errBack, errorMessage = 'Reached end of values array.'\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(\n      'The `values` argument to `promiseChainForValues` must be an array.'\n    );\n  }\n  if (typeof errBack !== 'function') {\n    throw new TypeError(\n      'The `errBack` argument to `promiseChainForValues` must be a function.'\n    );\n  }\n  return (async () => {\n    let ret;\n    let p = Promise.reject(\n      new Error('Intentionally reject so as to begin checking chain')\n    );\n    let breaking;\n    while (true) {\n      const value = values.shift();\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        ret = await p;\n        break;\n      } catch (err) {\n        if (breaking) {\n          throw new Error(errorMessage);\n        }\n        // We allow one more try\n        if (!values.length) {\n          breaking = true;\n        }\n        // // eslint-disable-next-line no-await-in-loop\n        p = errBack(value);\n      }\n    }\n    return ret;\n  })();\n};\n","/**\n* @callback SubstitutionCallback\n* @param {PlainObject} cfg\n* @param {string} cfg.arg By default, accepts the third portion of the\n*   `formattingRegex` within `insertNodes`, i.e., to allow the locale to\n*   supply arguments back to the calling script.\n* @param {string} cfg.key The substitution key\n* @returns {string|Element} The replacement text or element\n*/\n\n/**\n * May have additional properties if supplying options to an underlying\n * formatter.\n * @typedef {GenericArray} ValueArray\n * @property {string|Node|number|Date} 0 The main value\n * @property {PlainObject} [1] The options related to the main value\n * @property {PlainObject} [2] Any additional options\n*/\n\n/**\n* @typedef {PlainObject} RelativeTimeInfo\n* @property {ValueArray} relative\n*/\n\n/**\n* @typedef {PlainObject} ListInfo\n* @property {ValueArray} list\n*/\n\n/**\n* @typedef {PlainObject} NumberInfo\n* @property {ValueArray} number\n*/\n\n/**\n* @typedef {PlainObject} DateInfo\n* @property {ValueArray} date\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringBodyObject\n*/\n\n/**\n* @typedef {PlainObject} SwitchCaseInfo\n* @property {boolean} [default=false] Whether this conditional is the default\n*/\n\n/**\n* @typedef {GenericArray} SwitchCase\n* @property {string} 0 The type\n* @property {string} 1 The message\n* @property {SwitchCaseInfo} [2] Info about the switch case\n*/\n\n/**\n* @typedef {PlainObject<string, SwitchCase>} Switch\n*/\n\n/**\n* @typedef {PlainObject<{string, Switch}>} Switches\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} [message] The locale message with any formatting\n*   place-holders; defaults to use of any single conditional\n* @property {string} [description] A description to add translators\n* @property {Switches} [switches] Conditionals\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringBodyObject\n*/\n\n/**\n * Takes a base path and locale and gives a URL.\n * @callback LocaleResolver\n * @param {string} localesBasePath (Trailing slash optional)\n * @param {string} locale BCP-47 language string\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|SubstitutionCallback>}\n*   SubstitutionObject\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (localesBasePath, locale) => {\n  if (typeof localesBasePath !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `localesBasePath`.'\n    );\n  }\n  if (typeof locale !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `locale`.'\n    );\n  }\n  if ((/[./\\\\]/u).test(locale)) {\n    throw new TypeError(\n      'Locales cannot use file-reserved characters, `.`, `/` or `\\\\`'\n    );\n  }\n  return `${localesBasePath.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n","import {\n  LocalFormatter, RegularFormatter, SwitchFormatter\n} from './Formatter.js';\nimport {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {unescapeBackslashes, parseJSONExtra, processRegex} from './utils.js';\n\n/* eslint-disable max-len */\n/**\n * Callback to return a string or array of nodes and strings based on a localized\n * string, substitutions object, and other metadata.\n * @callback InsertNodesCallback\n * @param {PlainObject} cfg\n * @param {string} cfg.string The localized string\n * @param {boolean} [cfg.dom] If substitutions known to contain DOM, can be set\n *   to `true` to optimize\n * @param {string[]} [cfg.usedKeys=[]] Array for tracking which keys have been used\n * @param {SubstitutionObject} cfg.substitutions The formatting substitutions object\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions] The\n *   callback or array composed thereof for applying to each substitution.\n * @param {string} locale The successfully resolved locale\n * @param {Integer} [maximumLocalNestingDepth=3] Depth of local variable resolution to\n *   check before reporting a recursion error\n * @param {MissingSuppliedFormattersCallback} [cfg.missingSuppliedFormatters] Callback\n *   supplied key to throw if the supplied key is present (if\n *   `throwOnMissingSuppliedFormatters` is enabled). Defaults to no-op.\n * @param {CheckExtraSuppliedFormattersCallback} [cfg.checkExtraSuppliedFormatters] No\n *   argument callback to check if any formatters are not present in `string`\n *   (if `throwOnExtraSuppliedFormatters` is enabled). Defaults to no-op.\n * @returns {string|Array<Node|string>}\n */\n\n/**\n * @type {InsertNodesCallback}\n */\nexport const defaultInsertNodes = ({\n  /* eslint-enable max-len */\n  string, dom, usedKeys, substitutions, allSubstitutions, locale,\n  locals, switches,\n  maximumLocalNestingDepth = 3,\n  missingSuppliedFormatters,\n  checkExtraSuppliedFormatters\n}) => {\n  if (typeof maximumLocalNestingDepth !== 'number') {\n    throw new TypeError('`maximumLocalNestingDepth` must be a number.');\n  }\n  const localFormatter = new LocalFormatter(locals);\n  const regularFormatter = new RegularFormatter(substitutions);\n  const switchFormatter = new SwitchFormatter(switches, {substitutions});\n\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  const formattingRegex = /(\\\\*)\\{((?:[^}]|\\\\\\})*?)(?:(\\|)([^}]*))?\\}/gu;\n  if (allSubstitutions) {\n    allSubstitutions = Array.isArray(allSubstitutions)\n      ? allSubstitutions\n      : [allSubstitutions];\n  }\n\n  const getSubstitution = ({key, arg, substs}) => {\n    let substitution;\n    const isLocalKey = localFormatter.constructor.isMatchingKey(key);\n    if (isLocalKey) {\n      substitution = localFormatter.getSubstitution(key);\n    } else if (switchFormatter.constructor.isMatchingKey(key)) {\n      substitution = switchFormatter.getSubstitution(key, {\n        locale, usedKeys, arg,\n        missingSuppliedFormatters\n      });\n    } else {\n      substitution = substs[key];\n      if (typeof substitution === 'function') {\n        substitution = substitution({arg, key});\n      }\n    }\n    // Todo: Could support resolving locals within arguments\n    // Todo: Even for `null` `allSubstitutions`, we could have\n    //  a mode to throw for non-string/non-DOM (non-numbers?),\n    //  or whatever is not likely intended as a target for `toString()`.\n    if (allSubstitutions) {\n      substitution = allSubstitutions.reduce((subst, allSubst) => {\n        return allSubst({\n          value: subst, arg, key, locale\n        });\n      }, substitution);\n    } else if (arg && arg.match(/^(?:NUMBER|DATE(?:TIME)?|RELATIVE|LIST)(?:\\||$)/u)) {\n      substitution = defaultAllSubstitutions({\n        value: substitution, arg, key, locale\n      });\n    }\n    return substitution;\n  };\n\n  let recursiveLocalCount = 1;\n  const checkLocalVars = ({substitution, ky, arg, processSubsts}) => {\n    if (\n      typeof substitution === 'string' &&\n      substitution.includes('{')\n    ) {\n      if (recursiveLocalCount++ > maximumLocalNestingDepth) {\n        throw new TypeError('Too much recursion in local variables.');\n      }\n\n      if (localFormatter.constructor.isMatchingKey(ky)) {\n        let extraSubsts = substitutions;\n        let localFormatters;\n        if (arg) {\n          localFormatters = parseJSONExtra(arg);\n          extraSubsts = {\n            ...substitutions,\n            ...localFormatters\n          };\n        }\n        substitution = processSubsts({\n          str: substitution, substs: extraSubsts,\n          formatter: localFormatter\n        });\n        if (localFormatters) {\n          checkExtraSuppliedFormatters({substitutions: localFormatters});\n        }\n      } else if (switchFormatter.constructor.isMatchingKey(ky)) {\n        substitution = processSubsts({\n          str: substitution\n        });\n      }\n    }\n    return substitution;\n  };\n\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    // Run this block to optimize non-DOM substitutions\n    let returnsDOM = false;\n    const replace = ({\n      str, substs = substitutions,\n      formatter = regularFormatter\n    }) => {\n      return str.replace(formattingRegex, (_, esc, ky, pipe, arg) => {\n        if (esc.length % 2) {\n          return _;\n        }\n        if (missingSuppliedFormatters({\n          key: ky,\n          formatter\n        })) {\n          return _;\n        }\n        let substitution = getSubstitution({key: ky, arg, substs});\n\n        substitution = checkLocalVars({\n          substitution, ky, arg, processSubsts: replace\n        });\n\n        returnsDOM = returnsDOM ||\n          (substitution && typeof substitution === 'object' &&\n          'nodeType' in substitution);\n        usedKeys.push(ky);\n        return esc + substitution;\n      });\n    };\n    const ret = replace({str: string});\n    if (!returnsDOM) {\n      checkExtraSuppliedFormatters({substitutions});\n      usedKeys.length = 0;\n      return unescapeBackslashes(ret);\n    }\n    usedKeys.length = 0;\n  }\n\n  recursiveLocalCount = 1;\n  const processSubstitutions = ({\n    str, substs = substitutions, formatter = regularFormatter\n  }) => {\n    const nodes = [];\n\n    // Copy to ensure we are resetting index on each instance (manually\n    // resetting on `formattingRegex` is problematic with recursion that\n    // uses the same regex copy)\n    const regex = new RegExp(formattingRegex, 'gu');\n\n    const push = (...args) => {\n      nodes.push(...args);\n    };\n\n    processRegex(regex, str, {\n      extra: push,\n      onMatch (_, esc, ky, pipe, arg) {\n        if (missingSuppliedFormatters({\n          key: ky, formatter\n        })) {\n          push(_);\n        } else {\n          if (esc.length) {\n            push(esc);\n          }\n\n          let substitution = getSubstitution({key: ky, arg, substs});\n          substitution = checkLocalVars({\n            substitution, ky, arg, processSubsts: processSubstitutions\n          });\n          if (Array.isArray(substitution)) {\n            push(...substitution);\n          } else if (\n            // Clone so that multiple instances may be added (and no\n            // side effects to user code)\n            substitution && typeof substitution === 'object' &&\n            'nodeType' in substitution\n          ) {\n            push(substitution.cloneNode(true));\n          } else {\n            push(substitution);\n          }\n        }\n        usedKeys.push(ky);\n      }\n    });\n    return nodes;\n  };\n  const nodes = processSubstitutions({str: string});\n\n  checkExtraSuppliedFormatters({substitutions});\n  usedKeys.length = 0;\n  return nodes.map((node) => {\n    if (typeof node === 'string') {\n      return unescapeBackslashes(node);\n    }\n    return node;\n  });\n};\n","import {unescapeBackslashes, processRegex} from './utils.js';\n\n/**\n* @typedef {LocaleBody} LocalObject\n*/\n\n/**\n * May also contain language code and direction, translator name and\n * contact, etc., but no defaults currently apply besides reserving `locals`\n * @typedef {PlainObject} LocaleHead\n * @property {LocalObject} locals\n*/\n\n/**\n* @typedef {LocaleStringBodyObject|PlainLocaleStringBodyObject|PlainObject}\n* LocaleBody\n*/\n\n/**\n* @typedef {PlainObject} LocaleObject\n* @property {LocaleHead} [head]\n* @property {LocaleBody} body\n*/\n\n/**\n* @typedef {PlainObject} MessageStyleCallbackResult\n* @property {string} value Regardless of message style, will contain the\n*   string result\n* @property {LocaleStringSubObject} [info] Full info on the localized item\n*   (for rich message styles only)\n*/\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|MessageStyleCallbackResult} If `false`, will resort to default\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='richNested']\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  /* eslint-enable max-len */\n  messageStyle = 'richNested'\n} = {}) => {\n  // Todo: Support `plainNested` style\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'richNested'\n      ? (mainObj, key) => {\n        const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n        const keys = [];\n        // eslint-disable-next-line prefer-named-capture-group\n        const possiblyEscapedCharPattern = /(\\\\*)\\./gu;\n        const mergeWithPreviousOrStart = (val) => {\n          if (!keys.length) {\n            keys[0] = '';\n          }\n          keys[keys.length - 1] += val;\n        };\n        processRegex(possiblyEscapedCharPattern, key, {\n          // If odd, this is just an escaped dot, so merge content with\n          //   any previous\n          extra: mergeWithPreviousOrStart,\n          onMatch (_, esc) {\n            // If even, there are no backslashes, or they are just escaped\n            //  backslashes and not an escaped dot, so start anew, though\n            //  first merge any backslashes\n            mergeWithPreviousOrStart(esc);\n            keys.push('');\n          }\n        });\n        const keysUnescaped = keys.map((ky) => {\n          return unescapeBackslashes(ky);\n        });\n\n        let ret = false;\n        let currObj = obj;\n        keysUnescaped.some((ky, i, kys) => {\n          if (!currObj || typeof currObj !== 'object') {\n            return true;\n          }\n          if (\n            // If specified key is too deep, we should fail\n            i === kys.length - 1 &&\n            ky in currObj && currObj[ky] && typeof currObj[ky] === 'object' &&\n            'message' in currObj[ky] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof currObj[ky].message === 'string'\n          ) {\n            ret = {\n              value: currObj[ky].message,\n              info: currObj[ky]\n            };\n          }\n          currObj = currObj[ky];\n\n          return false;\n        });\n        return ret;\n      }\n      : (messageStyle === 'rich'\n        ? (mainObj, key) => {\n          const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n          if (\n            obj && typeof obj === 'object' &&\n            key in obj && obj[key] && typeof obj[key] === 'object' &&\n            'message' in obj[key] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof obj[key].message === 'string'\n          ) {\n            return {\n              value: obj[key].message,\n              info: obj[key]\n            };\n          }\n          return false;\n        }\n        : (messageStyle === 'plain'\n          ? (mainObj, key) => {\n            const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n            if (\n              obj && typeof obj === 'object' &&\n              key in obj && obj[key] && typeof obj[key] === 'string'\n            ) {\n              return {\n                value: obj[key]\n              };\n            }\n            return false;\n          }\n          : (() => {\n            throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n          })())\n      )\n    );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message] If present, this string will be the return value.\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='richNested']\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings; used to find a default if no string `message` is provided.\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n} = {}) => {\n  if (typeof key !== 'string') {\n    throw new TypeError(\n      'An options object with a `key` string is expected on ' +\n      '`getStringFromMessageAndDefaults`'\n    );\n  }\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  let str;\n  if (typeof message === 'string') {\n    str = message;\n  } else if (\n    defaults === false || defaults === undefined || defaults === null\n  ) {\n    str = false;\n  } else if (defaults && typeof defaults === 'object') {\n    str = messageForKey({body: defaults}, key);\n    if (str) {\n      str = str.value;\n    }\n  } else {\n    throw new TypeError(\n      `Default locale strings must resolve to \\`false\\`, ` +\n      `nullish, or an object!`\n    );\n  }\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n","import {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {defaultInsertNodes} from './defaultInsertNodes.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/* eslint-disable max-len */\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {string} cfg.locale The (possibly already resolved) locale for use by\n *   configuring formatters\n * @param {LocalObject} [cfg.locals]\n * @param {LocalObject} [cfg.switches]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions=[defaultAllSubstitutions]]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  /* eslint-enable max-len */\n  string,\n  locale,\n  locals,\n  switches,\n  maximumLocalNestingDepth,\n  allSubstitutions = [\n    defaultAllSubstitutions\n  ],\n  insertNodes = defaultInsertNodes,\n  substitutions = false,\n  dom = false,\n  forceNodeReturn = false,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true\n} = {}) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'An options object with a `string` property set to a string must ' +\n      'be provided for `getDOMForLocaleString`.'\n    );\n  }\n  const stringOrTextNode = (str) => {\n    const _doc = getDocument();\n    return forceNodeReturn ? _doc.createTextNode(str) : str;\n  };\n\n  const usedKeys = [];\n\n  /**\n  * @callback CheckExtraSuppliedFormattersCallback\n  * @param {SubstitutionObject} substs\n  * @throws {Error} Upon an extra formatting key being found\n  * @returns {void}\n  */\n\n  /**\n   * @type {CheckExtraSuppliedFormattersCallback}\n   */\n  const checkExtraSuppliedFormatters = ({\n    substitutions: substs\n  }) => {\n    if (throwOnExtraSuppliedFormatters) {\n      Object.keys(substs).forEach((key) => {\n        if (!usedKeys.includes(key)) {\n          throw new Error(`Extra formatting key: ${key}`);\n        }\n      });\n    }\n  };\n\n  /**\n  * @callback MissingSuppliedFormattersCallback\n  * @param {string} key\n  * @param {SubstitutionObject} substs\n  * @throws {Error} If missing formatting key\n  * @returns {boolean}\n  */\n  /**\n   * @type {MissingSuppliedFormattersCallback}\n   */\n  const missingSuppliedFormatters = ({\n    key, formatter\n  }) => {\n    const matching = formatter.isMatch(key);\n    if (formatter.constructor.isMatchingKey(key) && !matching) {\n      if (throwOnMissingSuppliedFormatters) {\n        throw new Error(`Missing formatting key: ${key}`);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  if (\n    !substitutions && !allSubstitutions &&\n    !throwOnMissingSuppliedFormatters\n  ) {\n    return stringOrTextNode(string);\n  }\n  if (!substitutions) {\n    substitutions = {};\n  }\n\n  const nodes = insertNodes({\n    string, dom, usedKeys, substitutions, allSubstitutions, locale,\n    locals, switches,\n    missingSuppliedFormatters,\n    checkExtraSuppliedFormatters\n  });\n  if (typeof nodes === 'string') {\n    return stringOrTextNode(nodes);\n  }\n\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n\n  return container;\n};\n","/* globals intlDomLocale */\n\nimport {defaultLocaleResolver} from './defaultLocaleResolver.js';\nimport {promiseChainForValues} from './promiseChainForValues.js';\nimport {getFetch} from './shared.js';\n\nexport {setFetch, getFetch} from './shared.js';\n\n/**\n * Takes a locale and returns a new locale to check.\n * @callback LocaleMatcher\n * @param {string} locale The failed locale\n * @throws If there are no further hyphens left to check\n * @returns {string|Promise<string>} The new locale to check\n*/\n\n/**\n * @type {LocaleMatcher}\n */\nexport const defaultLocaleMatcher = (locale) => {\n  if (!locale.includes('-')) {\n    throw new Error('Locale not available');\n  }\n  // Try without hyphen, i.e., the \"lookup\" algorithm:\n  // See https://tools.ietf.org/html/rfc4647#section-3.4 and\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\n  return locale.replace(/-[^-]*$/u, '');\n};\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.locale\n * @param {string[]} cfg.locales\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleMatcher}]\n * @returns {string|false}\n */\nexport const getMatchingLocale = ({\n  locale, locales, localeResolver = defaultLocaleMatcher\n}) => {\n  try {\n    while (!locales.includes(locale)) {\n      // Catch as `defaultLocaleMatcher` will throw if no hyphen found\n      locale = localeResolver(locale);\n    }\n  } catch (err) {\n    return false;\n  }\n  return locale;\n};\n\n/**\n* @typedef {PlainObject} LocaleObjectInfo\n* @property {LocaleObject} strings The successfully retrieved locale strings\n* @property {string} locale The successfully resolved locale\n*/\n\n/**\n * @callback LocaleStringFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<LocaleObjectInfo>}\n */\n\n/**\n *\n * @type {LocaleStringFinder}\n */\nexport const findLocaleStrings = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n};\n\n/**\n * @callback LocaleFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<string>} Resolves to the successfully resolved locale\n */\n\n/**\n *\n * @type {LocaleFinder}\n */\nexport const findLocale = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher,\n    headOnly: true\n  });\n};\n\n/**\n * @type {LocaleStringFinder|LocaleFinder} Also has a `headOnly` boolean\n *  property to determine whether to make a simple HEAD and resolve to\n *  the locale rather than locale and contents\n */\nconst _findLocale = async ({\n  locales = typeof intlDomLocale !== 'undefined'\n    ? [intlDomLocale]\n    : typeof navigator === 'undefined' ? [] : navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.',\n  localeMatcher = 'lookup',\n  headOnly = false\n}) => {\n  /**\n   * @callback getLocale\n   * @throws {SyntaxError|TypeError|Error}\n   * @param {string} locale\n   * @returns {Promise<LocaleObjectInfo>}\n   */\n  async function getLocale (locale) {\n    if (typeof locale !== 'string') {\n      throw new TypeError('Non-string locale type');\n    }\n    const url = localeResolver(localesBasePath, locale);\n    if (typeof url !== 'string') {\n      throw new TypeError(\n        '`localeResolver` expected to resolve to (URL) string.'\n      );\n    }\n    try {\n      const _fetch = getFetch();\n      const resp = await (headOnly\n        ? _fetch(url, {\n          method: 'HEAD'\n        })\n        : _fetch(url)\n      );\n\n      if (resp.status === 404) {\n        // Don't allow browser (tested in Firefox) to continue\n        //  and give `SyntaxError` with missing file or we won't be\n        //  able to try without the hyphen\n        throw new Error('Trying again');\n      }\n      if (headOnly) {\n        return locale;\n      }\n      const strings = await (resp.json());\n      return {\n        locale,\n        strings\n      };\n    } catch (err) {\n      if (err.name === 'SyntaxError') {\n        throw err;\n      }\n      const newLocale = await localeMatcher(locale);\n      return getLocale(newLocale);\n    }\n  }\n  if (localeMatcher === 'lookup') {\n    localeMatcher = defaultLocaleMatcher;\n  } else if (typeof localeMatcher !== 'function') {\n    throw new TypeError('`localeMatcher` must be \"lookup\" or a function!');\n  }\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    getLocale,\n    'No matching locale found!'\n  );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\nimport {findLocaleStrings} from './findLocaleStrings.js';\nimport {getDOMForLocaleString} from './getDOMForLocaleString.js';\nimport {\n  getStringFromMessageAndDefaults\n} from './getStringFromMessageAndDefaults.js';\nimport {sort, sortList, list} from './collation.js';\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present.\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {LocaleObject} cfg.strings\n * @param {string} cfg.resolvedLocale\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='richNested']\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18nServer = function i18nServer ({\n  /* eslint-enable max-len */\n  strings,\n  resolvedLocale,\n  messageStyle,\n  allSubstitutions: defaultAllSubstitutionsValue,\n  insertNodes,\n  defaults: defaultDefaults,\n  substitutions: defaultSubstitutions,\n  maximumLocalNestingDepth,\n  dom: domDefaults = false,\n  forceNodeReturn: forceNodeReturnDefault = false,\n  throwOnMissingSuppliedFormatters:\n    throwOnMissingSuppliedFormattersDefault = true,\n  throwOnExtraSuppliedFormatters:\n    throwOnExtraSuppliedFormattersDefault = true\n}) {\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const formatter = (key, substitutions, {\n    allSubstitutions = defaultAllSubstitutionsValue,\n    defaults = defaultDefaults,\n    dom = domDefaults,\n    forceNodeReturn = forceNodeReturnDefault,\n    throwOnMissingSuppliedFormatters = throwOnMissingSuppliedFormattersDefault,\n    throwOnExtraSuppliedFormatters = throwOnExtraSuppliedFormattersDefault\n  } = {}) => {\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message: (message && message.value) || false,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      locals: strings.head && strings.head.locals,\n      switches: strings.head && strings.head.switches,\n      locale: resolvedLocale,\n      maximumLocalNestingDepth,\n      allSubstitutions,\n      insertNodes,\n      substitutions: {...defaultSubstitutions, ...substitutions},\n      dom,\n      forceNodeReturn,\n      throwOnMissingSuppliedFormatters,\n      throwOnExtraSuppliedFormatters\n    });\n  };\n\n  formatter.resolvedLocale = resolvedLocale;\n  formatter.strings = strings;\n\n  formatter.sort = (...args) => {\n    return sort(resolvedLocale, ...args);\n  };\n\n  formatter.sortList = (...args) => {\n    return sortList(\n      resolvedLocale, ...args\n    );\n  };\n\n  formatter.list = (...args) => {\n    return list(\n      resolvedLocale, ...args\n    );\n  };\n\n  return formatter;\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {LocaleStringFinder} [cfg.localeStringFinder=findLocaleStrings]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher='lookup']\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='richNested']\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localeStringFinder = findLocaleStrings,\n  localesBasePath,\n  localeResolver,\n  localeMatcher,\n  messageStyle,\n  allSubstitutions,\n  insertNodes,\n  defaults,\n  substitutions,\n  maximumLocalNestingDepth,\n  dom,\n  forceNodeReturn,\n  throwOnMissingSuppliedFormatters,\n  throwOnExtraSuppliedFormatters\n} = {}) {\n  const {strings, locale: resolvedLocale} = await localeStringFinder({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n\n  return i18nServer({\n    strings,\n    resolvedLocale,\n    messageStyle,\n    allSubstitutions,\n    insertNodes,\n    defaults,\n    substitutions,\n    maximumLocalNestingDepth,\n    dom,\n    forceNodeReturn,\n    throwOnMissingSuppliedFormatters,\n    throwOnExtraSuppliedFormatters\n  });\n};\n"],"names":["module","lib","exports","contexts","getContext","pop","context","elements","element_array","dropContext","ctx","push","buffers","dropBuffer","buf","JSON6","escape","string","output","n","length","begin","cb","reviver","val","name","value_type","contains","pos","line","col","word","status","negative","result","undefined","parse_context","comment","fromHex","decimal","exponent","exponent_sign","exponent_digit","gatheringStringFirstChar","gatheringString","gatheringNumber","stringEscape","cr_escaped","unicodeWide","stringUnicode","stringHex","hex_char","hex_char_len","completed","context_stack","first","last","saved","node","recover","this","next","prior","inQueue","shift","unshift","throwEndError","leader","Error","finalError","console","log","value","r","reset","save","write","msg","retcode","String","_write","walk","holder","key","k","Object","prototype","hasOwnProperty","call","v","complete_at_end","input","retval","throwError","c","fromCodePoint","substr","RESET_VAL","arrayPush","Number","NaN","Infinity","objectPush","gatherString","start_c","str","charAt","cInt","codePointAt","collectNumber","_n","getBuffer","old_context","tmpobj","tmparr","_parser","freeze","_parse_level","parse","parse_level","parser","stringify","JSON","fn","unescapeBackslashes","replace","esc","slice","parseJSONExtra","args","jsonExtra","processRegex","regex","match","onMatch","extra","betweenMatches","afterMatch","escapeAtOne","previousIndex","exec","_","lastIndex","startMatchPos","_fetch","fetch","setFetch","f","getFetch","_doc","document","setDocument","doc","getDocument","sort","locale","arrayOfItems","options","Intl","Collator","compare","list","ListFormat","format","sortList","map","listOptions","collationOptions","sortListSimple","d","randomId","Date","getTime","performance","now","Math","random","floor","toString","placeholderArray","_toConsumableArray","i","nodes","RegExp","idx","container","createDocumentFragment","append","getFormatterInfo","object","Array","isArray","callback","extraOpts","defaultAllSubstitutions","opts","arg","_typeof","applyArgs","type","checkArgOptions","split","userType","extraArgs","argOptions","singleKey","keys","includes","RelativeTimeFormat","NumberFormat","DateTimeFormat","TypeError","Formatter","getSubstitution","body","messageStyle","substitution","getMessageForKeyByStyle","messageForKey","LocalFormatter","locals","components","parent","constructor","isMatchingKey","every","cmpt","startsWith","RegularFormatter","substitutions","test","SwitchFormatter","switches","usedKeys","missingSuppliedFormatters","ky","getKey","getMatch","objKey","keySegment","formatter","getNumberFormat","defaultOptions","numberOpts","getPluralFormat","pluralOpts","PluralRules","select","formatterValue","toUpperCase","toLowerCase","preventNesting","s","err","error","find","switchKey","Boolean","ks","reduce","obj","ret","entries","_this4","concat","then","direct","Promise","resolve","e","pact","state","o","_settle","bind","observer","_Pact","onFulfilled","onRejected","_this","thenable","update","stage","shouldContinue","_isSettledPact","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","arguments","apply","promiseChainForValues","values","errBack","errorMessage","_async","breaking","p","defaultLocaleResolver","localesBasePath","defaultInsertNodes","dom","allSubstitutions","maximumLocalNestingDepth","checkExtraSuppliedFormatters","localFormatter","regularFormatter","switchFormatter","formattingRegex","substs","subst","allSubst","recursiveLocalCount","checkLocalVars","processSubsts","localFormatters","extraSubsts","returnsDOM","pipe","processSubstitutions","cloneNode","mainObj","mergeWithPreviousOrStart","keysUnescaped","currObj","some","kys","message","info","getStringFromMessageAndDefaults","defaults","getDOMForLocaleString","insertNodes","forceNodeReturn","throwOnMissingSuppliedFormatters","throwOnExtraSuppliedFormatters","stringOrTextNode","createTextNode","forEach","matching","isMatch","defaultLocaleMatcher","getMatchingLocale","locales","localeResolver","findLocaleStrings","defaultLocales","localeMatcher","_findLocale","findLocale","headOnly","getLocale","url","method","resp","json","strings","intlDomLocale","navigator","languages","i18nServer","resolvedLocale","defaultAllSubstitutionsValue","defaultDefaults","defaultSubstitutions","domDefaults","forceNodeReturnDefault","throwOnMissingSuppliedFormattersDefault","throwOnExtraSuppliedFormattersDefault","head","i18n","localeStringFinder"],"mappings":"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"}