{"version":3,"file":"index.esm.min.js","sources":["../src/index.js"],"sourcesContent":["// Todo: Allow literal brackets (with or without substitutions\n//   of the same name present)\n\n/**\n* @callback PromiseChainErrback\n* @param {any} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  errback, when passed the current item, returns a Promise or value that\n *  resolves, that value will be used for the return result of this function\n *  and no other items in the array will continue to be processed; if it\n *  rejects, however, the next item will be processed.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\n promiseChainForValues(['a', 'b', 'c'], (val) => {\n   return new Promise(function (resolve, reject) {\n     if (val === 'a') {\n       reject(new Error('missing'));\n     }\n     setTimeout(() => {\n       resolve(val);\n     }, 100);\n   });\n });\n */\nexport const promiseChainForValues = (values, errBack) => {\n  return values.reduce(async (p, value) => {\n    try {\n      return await p; // We'd short-circuit here instead if we could\n    } catch (err) {\n      return errBack(value);\n    }\n  }, Promise.reject(\n    new Error('Intentionally reject so as to begin checking chain')\n  ));\n};\n\n/**\n* @callback SubstitutionCallback\n* @param {string} arg Accepts the second portion of the `bracketRegex` of\n*   `i18n`, i.e., the non-bracketed segments of text from the locale string\n*   following a bracketed segment.\n* @returns {string} The replacement text\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringObject\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} message The locale message with any formatting\n*   place-holders\n* @property {string} description A description to add translators\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringObject\n*/\n\n/**\n * @callback LocaleResolver\n * @param {string} locale BCP-47 language string\n * @param {string} localesBasePth (Trailing slash optional)\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|SubstitutionCallback>}\n*   SubstitutionObject\n*/\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const DefaultLocaleResolver = (locale, localesBasePth) => {\n  return `${localesBasePth.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleStringObject|PlainLocaleStringObject|PlainObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|string} If `false`, will resort to default\n*/\n\n/**\n * @param {PlainObject} [cfg]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=DefaultLocaleResolver]\n * @returns {Promise<LocaleStringObject|PlainLocaleStringObject|PlainObject>}\n */\nexport const findLocaleStrings = async ({\n  locales = navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = DefaultLocaleResolver,\n  localesBasePath = '.'\n}) => {\n  // eslint-disable-next-line no-return-await\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    async function getLocale (locale) {\n      const url = localeResolver(locale, localesBasePath);\n      try {\n        return await (await fetch(url)).json();\n      } catch (err) {\n        if (!locale.includes('-')) {\n          throw new Error('Locale not available');\n        }\n        // Try without hyphen\n        return getLocale(locale.replace(/-.*$/u, ''));\n      }\n    }\n  );\n};\n\n/**\n * @param {PlainObject} [cfg]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  messageStyle = 'rich'\n} = {}) => {\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'rich'\n      ? (obj, key) => {\n        if (key in obj && obj[key] && 'message' in obj[key] &&\n          // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n          typeof obj[key].message === 'string'\n        ) {\n          return obj[key].message;\n        }\n        return false;\n      }\n      : (messageStyle === 'plain'\n        ? (obj, key) => {\n          if (key in obj && obj[key] && typeof obj[key] === 'string') {\n            return obj[key];\n          }\n          return false;\n        }\n        : (() => {\n          throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n        })()\n      )\n    );\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message]\n * @param {false|LocaleStringObject|PlainLocaleStringObject|PlainObject} [cfg.defaults]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n}) => {\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  const str = typeof message === 'string'\n    ? message\n    : (defaults === false\n      ? (() => {\n        throw new Error(`Key value not found for key: (${key})`);\n      })()\n      : (defaults && typeof defaults === 'object'\n        ? messageForKey(defaults, key)\n        : (() => {\n          throw new TypeError(\n            `Default locale strings must resolve to \\`false\\` or an object!`\n          );\n        })()\n      )\n    );\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {RegExp} [cfg.bracketRegex=/\\{([^}]*?)(?:\\|([^}]*))?\\}/gu]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  string,\n  substitutions,\n  dom,\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  bracketRegex = /\\{([^}]*?)(?:\\|([^}]*))?\\}/gu,\n  forceNodeReturn = false\n}) => {\n  if (!substitutions) {\n    return forceNodeReturn ? document.createTextNode(string) : string;\n  }\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    let returnsDOM = false;\n    // Run this block to optimize non-DOM substitutions\n    const ret = string.replace(bracketRegex, (_, ky, arg) => {\n      let substitution = substitutions[ky];\n      if (typeof substitution === 'function') {\n        substitution = substitution(arg);\n      }\n      returnsDOM = returnsDOM ||\n        (substitution && substitution.nodeType === 1);\n      return substitution;\n    });\n    if (!returnsDOM) {\n      return ret;\n    }\n  }\n  const nodes = [];\n  let result;\n  let previousIndex = 0;\n  while ((result = bracketRegex.exec(string)) !== null) {\n    const {lastIndex} = bracketRegex;\n    const [bracketedKey, ky, arg] = result;\n    let substitution = substitutions[ky];\n    if (typeof substitution === 'function') {\n      substitution = substitution(arg);\n    }\n    const startBracketPos = lastIndex - bracketedKey.length;\n    if (startBracketPos > previousIndex) {\n      nodes.push(string.slice(previousIndex, startBracketPos));\n    }\n    nodes.push(substitution);\n    previousIndex = lastIndex;\n  }\n  if (previousIndex !== string.length) { // Get text at end\n    nodes.push(string.slice(previousIndex));\n  }\n\n  const container = document.createDocumentFragment();\n\n  // console.log('nodes', nodes);\n  container.append(...nodes);\n  return container;\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=DefaultLocaleResolver]\n * @param {false|LocaleStringObject|PlainLocaleStringObject|PlainObject} [cfg.defaults]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @param {RegExp} [cfg.bracketRegex=/\\{([^}]*?)(?:\\|([^}]*))?\\}/gu]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localesBasePath,\n  localeResolver,\n  defaults,\n  messageStyle,\n  bracketRegex,\n  forceNodeReturn\n}) {\n  const strings = await findLocaleStrings({\n    locales, defaultLocales, localeResolver, localesBasePath\n  });\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  return (key, substitutions, {dom} = {}) => {\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      substitutions,\n      forceNodeReturn,\n      dom,\n      bracketRegex\n    });\n  };\n};\n"],"names":["promiseChainForValues","values","errBack","reduce","p","value","Promise","reject","Error","DefaultLocaleResolver","locale","localesBasePth","replace","findLocaleStrings","locales","navigator","languages","defaultLocales","localeResolver","localesBasePath","url","fetch","json","includes","getLocale","getMessageForKeyByStyle","messageStyle","obj","key","message","TypeError","getStringFromMessageAndDefaults","defaults","messageForKey","str","_typeof","getDOMForLocaleString","string","substitutions","dom","bracketRegex","forceNodeReturn","document","createTextNode","returnsDOM","ret","_","ky","arg","substitution","nodeType","result","nodes","previousIndex","exec","lastIndex","bracketedKey","startBracketPos","length","push","slice","container","createDocumentFragment","append","i18n","strings"],"mappings":"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"}