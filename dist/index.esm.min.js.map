{"version":3,"file":"index.esm.min.js","sources":["../node_modules/json-6/dist/index.mjs","../src/utils.js","../src/shared.js","../src/collation.js","../src/defaultAllSubstitutions.js","../src/Formatter.js","../src/promiseChainForValues.js","../src/defaultLocaleResolver.js","../src/defaultInsertNodes.js","../src/getMessageForKeyByStyle.js","../src/getStringFromMessageAndDefaults.js","../src/getDOMForLocaleString.js","../src/findLocaleStrings.js","../src/i18n.js"],"sourcesContent":["function createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t  path: basedir,\n\t  exports: {},\n\t  require: function (path, base) {\n      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n    }\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar json6 = createCommonjsModule(function (module, exports) {\n\n  const VALUE_UNDEFINED = -1;\n  const VALUE_UNSET = 0;\n  const VALUE_NULL = 1;\n  const VALUE_TRUE = 2;\n  const VALUE_FALSE = 3;\n  const VALUE_STRING = 4;\n  const VALUE_NUMBER = 5;\n  const VALUE_OBJECT = 6;\n  const VALUE_ARRAY = 7;\n  const VALUE_NEG_NAN = 8;\n  const VALUE_NAN = 9;\n  const VALUE_NEG_INFINITY = 10;\n  const VALUE_INFINITY = 11; // const VALUE_DATE = 12  // unused yet\n\n  const VALUE_EMPTY = 13; // [,] makes an array with 'empty item'\n\n  const WORD_POS_RESET = 0;\n  const WORD_POS_TRUE_1 = 1;\n  const WORD_POS_TRUE_2 = 2;\n  const WORD_POS_TRUE_3 = 3;\n  const WORD_POS_FALSE_1 = 5;\n  const WORD_POS_FALSE_2 = 6;\n  const WORD_POS_FALSE_3 = 7;\n  const WORD_POS_FALSE_4 = 8;\n  const WORD_POS_NULL_1 = 9;\n  const WORD_POS_NULL_2 = 10;\n  const WORD_POS_NULL_3 = 11;\n  const WORD_POS_UNDEFINED_1 = 12;\n  const WORD_POS_UNDEFINED_2 = 13;\n  const WORD_POS_UNDEFINED_3 = 14;\n  const WORD_POS_UNDEFINED_4 = 15;\n  const WORD_POS_UNDEFINED_5 = 16;\n  const WORD_POS_UNDEFINED_6 = 17;\n  const WORD_POS_UNDEFINED_7 = 18;\n  const WORD_POS_UNDEFINED_8 = 19;\n  const WORD_POS_NAN_1 = 20;\n  const WORD_POS_NAN_2 = 21;\n  const WORD_POS_INFINITY_1 = 22;\n  const WORD_POS_INFINITY_2 = 23;\n  const WORD_POS_INFINITY_3 = 24;\n  const WORD_POS_INFINITY_4 = 25;\n  const WORD_POS_INFINITY_5 = 26;\n  const WORD_POS_INFINITY_6 = 27;\n  const WORD_POS_INFINITY_7 = 28;\n  const WORD_POS_FIELD = 29;\n  const WORD_POS_AFTER_FIELD = 30;\n  const WORD_POS_END = 31;\n  const CONTEXT_UNKNOWN = 0;\n  const CONTEXT_IN_ARRAY = 1; // const CONTEXT_IN_OBJECT = 2\n\n  const CONTEXT_OBJECT_FIELD = 3;\n  const CONTEXT_OBJECT_FIELD_VALUE = 4;\n  const contexts = [];\n\n  function getContext() {\n    return contexts.pop() || {\n      context: CONTEXT_UNKNOWN,\n      elements: null,\n      element_array: null\n    };\n  }\n\n  function dropContext(ctx) {\n    contexts.push(ctx);\n  }\n\n  const buffers = [];\n\n  function getBuffer() {\n    let buf = buffers.pop();\n    if (!buf) buf = {\n      buf: null,\n      n: 0\n    };else buf.n = 0;\n    return buf;\n  }\n\n  function dropBuffer(buf) {\n    buffers.push(buf);\n  }\n\n  const JSON6 =  exports // istanbul ignore next\n  ;\n  /*\n  let _DEBUG_LL = true;\n  let _DEBUG_PARSING = true;\n  let _DEBUG_PARSING_STACK = true;\n  \n  const log = function(type) {\n  \tif (type === '_DEBUG_PARSING' && !_DEBUG_PARSING) {\n  \t\treturn;\n  \t}\n  \tif (type === '_DEBUG_PARSING_STACK' && !_DEBUG_PARSING_STACK) {\n  \t\treturn;\n  \t}\n  \tif (type === '_DEBUG_LL' && !_DEBUG_LL) {\n  \t\treturn;\n  \t}\n  \tconsole.log.apply(console, [].slice.call(arguments, 1));\n  };\n  */\n\n  JSON6.escape = function (string) {\n    let output = '';\n    if (!string) return string;\n\n    for (let n = 0; n < string.length; n++) {\n      if (string[n] == '\"' || string[n] == '\\\\' || string[n] == '`' || string[n] == '\\'') {\n        output += '\\\\';\n      }\n\n      output += string[n];\n    }\n\n    return output;\n  };\n\n  JSON6.begin = function (cb, reviver) {\n    const val = {\n      name: null,\n      // name of this value (if it's contained in an object)\n      value_type: VALUE_UNSET,\n      // value from above indiciating the type of this value\n      string: '',\n      // the string value of this value (strings and number types only)\n      contains: null\n    };\n    const pos = {\n      line: 1,\n      col: 1\n    };\n    let n = 0;\n    let word = WORD_POS_RESET,\n        status = true,\n        negative = false,\n        result = null,\n        elements = undefined,\n        element_array = [],\n        parse_context = CONTEXT_UNKNOWN,\n        comment = 0,\n        fromHex = false,\n        decimal = false,\n        exponent = false,\n        exponent_sign = false,\n        exponent_digit = false,\n        gatheringStringFirstChar = null,\n        gatheringString = false,\n        gatheringNumber = false,\n        stringEscape = false,\n        cr_escaped = false,\n        unicodeWide = false,\n        stringUnicode = false,\n        stringHex = false,\n        hex_char = 0,\n        hex_char_len = 0,\n        completed = false;\n    const context_stack = {\n      first: null,\n      last: null,\n      saved: null,\n\n      push(node) {\n        let recover = this.saved;\n\n        if (recover) {\n          this.saved = recover.next;\n          recover.node = node;\n          recover.next = null;\n          recover.prior = this.last;\n        } else {\n          recover = {\n            node: node,\n            next: null,\n            prior: this.last\n          };\n        }\n\n        if (!this.last) this.first = recover;\n        this.last = recover;\n      },\n\n      pop() {\n        const result = this.last;\n        if (!(this.last = result.prior)) this.first = null;\n        result.next = this.saved;\n        this.saved = result;\n        return result.node;\n      }\n\n    };\n    const inQueue = {\n      first: null,\n      last: null,\n      saved: null,\n\n      push(node) {\n        let recover = this.saved;\n\n        if (recover) {\n          this.saved = recover.next;\n          recover.node = node;\n          recover.next = null;\n          recover.prior = this.last;\n        } else {\n          recover = {\n            node: node,\n            next: null,\n            prior: this.last\n          };\n        }\n\n        if (!this.last) this.first = recover;else this.last.next = recover;\n        this.last = recover;\n      },\n\n      shift() {\n        const result = this.first;\n        if (!result) return null;\n        this.first = result.next;\n        if (!this.first) this.last = null;\n        result.next = this.saved;\n        this.saved = result; // node is in saved...\n\n        return result.node;\n      },\n\n      unshift(node) {\n        // usage in this module, recover will ALWAYS have a saved to use.\n        const recover = this.saved; //if( recover ) {\n\n        this.saved = recover.next;\n        recover.node = node;\n        recover.next = this.first;\n        recover.prior = null; //} else { recover = { node : node, next : this.first, prior : null }; }\n\n        if (!this.first) this.last = recover;\n        this.first = recover;\n      }\n\n    };\n\n    function throwEndError(leader\n    /* , c */\n    ) {\n      throw new Error(`${leader} at ${n} [${pos.line}:${pos.col}]`);\n    }\n\n    return {\n      finalError() {\n        if (comment !== 0) {\n          // most of the time everything's good.\n          switch (comment) {\n            case 1:\n              return throwEndError(\"Comment began at end of document\");\n\n            case 2:\n              console.log(\"Warning: '//' comment without end of line ended document\");\n              break;\n\n            case 3:\n              return throwEndError(\"Open comment '/*' is missing close at end of document\");\n\n            case 4:\n              return throwEndError(\"Incomplete '/* *' close at end of document\");\n          }\n        }\n\n        if (gatheringString) throwEndError(\"Incomplete string\");\n      },\n\n      value() {\n        this.finalError();\n        const r = result;\n        result = undefined;\n        return r;\n      },\n\n      reset() {\n        word = WORD_POS_RESET;\n        status = true;\n        if (inQueue.last) inQueue.last.next = inQueue.save;\n        inQueue.save = inQueue.first;\n        inQueue.first = inQueue.last = null;\n        if (context_stack.last) context_stack.last.next = context_stack.save;\n        context_stack.save = inQueue.first;\n        context_stack.first = context_stack.last = null; //= [];\n\n        element_array = null;\n        elements = undefined;\n        parse_context = CONTEXT_UNKNOWN;\n        val.value_type = VALUE_UNSET;\n        val.name = null;\n        val.string = '';\n        pos.line = 1;\n        pos.col = 1;\n        negative = false;\n        comment = 0;\n        completed = false;\n        gatheringString = false;\n        stringEscape = false; // string stringEscape intro\n\n        cr_escaped = false; // carraige return escaped\n        //stringUnicode = false;  // reading \\u\n        //unicodeWide = false;  // reading \\u{} in string\n        //stringHex = false;  // reading \\x in string\n      },\n\n      write(msg) {\n        let retcode;\n        if (msg !== undefined && typeof msg !== \"string\") msg = String(msg);\n        if (!status) throw new Error(\"Parser is in an error state, please reset.\");\n\n        for (retcode = this._write(msg, false); retcode > 0; retcode = this._write()) {\n          this.finalError();\n          if (typeof reviver === 'function') (function walk(holder, key) {\n            const value = holder[key];\n\n            if (value && typeof value === 'object') {\n              for (const k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                  const v = walk(value, k);\n\n                  if (v !== undefined) {\n                    value[k] = v;\n                  } else {\n                    delete value[k];\n                  }\n                }\n              }\n            }\n\n            return reviver.call(holder, key, value);\n          })({\n            '': result\n          }, '');\n          cb(result);\n          result = undefined;\n          if (retcode < 2) break;\n        }\n\n        if (retcode) this.finalError();\n      },\n\n      _write(msg, complete_at_end) {\n        let input;\n        let buf;\n        let retval = 0;\n\n        function throwError(leader, c) {\n          throw new Error(`${leader} '${String.fromCodePoint(c)}' unexpected at ${n} (near '${buf.substr(n > 4 ? n - 4 : 0, n > 4 ? 3 : n - 1)}[${String.fromCodePoint(c)}]${buf.substr(n, 10)}') [${pos.line}:${pos.col}]`);\n        }\n\n        function RESET_VAL() {\n          val.value_type = VALUE_UNSET;\n          val.string = '';\n        }\n\n        function arrayPush() {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              element_array.push((negative ? -1 : 1) * Number(val.string));\n              break;\n\n            case VALUE_STRING:\n              element_array.push(val.string);\n              break;\n\n            case VALUE_TRUE:\n              element_array.push(true);\n              break;\n\n            case VALUE_FALSE:\n              element_array.push(false);\n              break;\n\n            case VALUE_NEG_NAN:\n              element_array.push(-NaN);\n              break;\n\n            case VALUE_NAN:\n              element_array.push(NaN);\n              break;\n\n            case VALUE_NEG_INFINITY:\n              element_array.push(-Infinity);\n              break;\n\n            case VALUE_INFINITY:\n              element_array.push(Infinity);\n              break;\n\n            case VALUE_NULL:\n              element_array.push(null);\n              break;\n\n            case VALUE_UNDEFINED:\n              element_array.push(undefined);\n              break;\n\n            case VALUE_EMPTY:\n              element_array.push(undefined);\n              delete element_array[element_array.length - 1];\n              break;\n\n            case VALUE_OBJECT:\n              element_array.push(val.contains);\n              break;\n\n            case VALUE_ARRAY:\n              element_array.push(val.contains);\n              break;\n          }\n        }\n\n        function objectPush() {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              elements[val.name] = (negative ? -1 : 1) * Number(val.string);\n              break;\n\n            case VALUE_STRING:\n              elements[val.name] = val.string;\n              break;\n\n            case VALUE_TRUE:\n              elements[val.name] = true;\n              break;\n\n            case VALUE_FALSE:\n              elements[val.name] = false;\n              break;\n\n            case VALUE_NEG_NAN:\n              elements[val.name] = -NaN;\n              break;\n\n            case VALUE_NAN:\n              elements[val.name] = NaN;\n              break;\n\n            case VALUE_NEG_INFINITY:\n              elements[val.name] = -Infinity;\n              break;\n\n            case VALUE_INFINITY:\n              elements[val.name] = Infinity;\n              break;\n\n            case VALUE_NULL:\n              elements[val.name] = null;\n              break;\n\n            case VALUE_UNDEFINED:\n              elements[val.name] = undefined;\n              break;\n\n            case VALUE_OBJECT:\n              elements[val.name] = val.contains;\n              break;\n\n            case VALUE_ARRAY:\n              elements[val.name] = val.contains;\n              break;\n          }\n        }\n\n        function gatherString(start_c) {\n          let retval = 0;\n\n          while (retval == 0 && n < buf.length) {\n            let str = buf.charAt(n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              str += buf.charAt(n);\n              n++;\n            } //console.log( \"gathering....\", stringEscape, str, cInt, unicodeWide, stringHex, stringUnicode, hex_char_len );\n\n\n            pos.col++;\n\n            if (cInt == start_c) {\n              //( cInt == 34/*'\"'*/ ) || ( cInt == 39/*'\\''*/ ) || ( cInt == 96/*'`'*/ ) )\n              if (stringEscape) {\n                if (stringHex) throwError(\"Incomplete hexidecimal sequence\", cInt);else if (unicodeWide) throwError(\"Incomplete long unicode sequence\", cInt);else if (stringUnicode) throwError(\"Incomplete unicode sequence\", cInt);\n\n                if (cr_escaped) {\n                  cr_escaped = false; // \\\\ \\r  '  :end string, the backslash was used for \\r\n\n                  retval = 1; // complete string.\n                } else val.string += str; // escaped start quote\n\n\n                stringEscape = false;\n              } else {\n                // quote matches, not escaped, and not processing escape...\n                retval = 1;\n              }\n            } else if (stringEscape) {\n              if (unicodeWide) {\n                if (cInt == 125\n                /*'}'*/\n                ) {\n                    val.string += String.fromCodePoint(hex_char);\n                    unicodeWide = false;\n                    stringUnicode = false;\n                    stringEscape = false;\n                    continue;\n                  }\n\n                hex_char *= 16;\n                if (cInt >= 48\n                /*'0'*/\n                && cInt <= 57\n                /*'9'*/\n                ) hex_char += cInt - 0x30;else if (cInt >= 65\n                /*'A'*/\n                && cInt <= 70\n                /*'F'*/\n                ) hex_char += cInt - 65 + 10;else if (cInt >= 97\n                /*'a'*/\n                && cInt <= 102\n                /*'f'*/\n                ) hex_char += cInt - 97 + 10;else {\n                  throwError(\"(escaped character, parsing hex of \\\\u)\", cInt);\n                }\n                continue;\n              } else if (stringHex || stringUnicode) {\n                if (hex_char_len === 0 && cInt === 123\n                /*'{'*/\n                ) {\n                    unicodeWide = true;\n                    continue;\n                  }\n\n                hex_char *= 16;\n                if (cInt >= 48\n                /*'0'*/\n                && cInt <= 57\n                /*'9'*/\n                ) hex_char += cInt - 0x30;else if (cInt >= 65\n                /*'A'*/\n                && cInt <= 70\n                /*'F'*/\n                ) hex_char += cInt - 65 + 10;else if (cInt >= 97\n                /*'a'*/\n                && cInt <= 102\n                /*'f'*/\n                ) hex_char += cInt - 97 + 10;else {\n                  throwError(stringUnicode ? \"(escaped character, parsing hex of \\\\u)\" : \"(escaped character, parsing hex of \\\\x)\", cInt);\n                }\n                hex_char_len++;\n\n                if (stringUnicode) {\n                  if (hex_char_len == 4) {\n                    val.string += String.fromCodePoint(hex_char);\n                    stringUnicode = false;\n                    stringEscape = false;\n                  }\n                } else if (hex_char_len == 2) {\n                  val.string += String.fromCodePoint(hex_char);\n                  stringHex = false;\n                  stringEscape = false;\n                }\n\n                continue;\n              }\n\n              switch (cInt) {\n                case 13\n                /*'\\r'*/\n                :\n                  cr_escaped = true;\n                  pos.col = 1;\n                  continue;\n\n                case 0x2028: // LS (Line separator)\n\n                case 0x2029:\n                  // PS (paragraph separator)\n                  pos.col = 1;\n                // no return to get newline reset, so reset line pos.\n                // Fallthrough\n\n                case 10\n                /*'\\n'*/\n                :\n                  if (cr_escaped) {\n                    // \\\\ \\r \\n\n                    cr_escaped = false;\n                  } else {\n                    // \\\\ \\n\n                    pos.col = 1;\n                  }\n\n                  pos.line++;\n                  break;\n\n                case 116\n                /*'t'*/\n                :\n                  val.string += '\\t';\n                  break;\n\n                case 98\n                /*'b'*/\n                :\n                  val.string += '\\b';\n                  break;\n\n                case 48\n                /*'0'*/\n                :\n                  val.string += '\\0';\n                  break;\n\n                case 110\n                /*'n'*/\n                :\n                  val.string += '\\n';\n                  break;\n\n                case 114\n                /*'r'*/\n                :\n                  val.string += '\\r';\n                  break;\n\n                case 102\n                /*'f'*/\n                :\n                  val.string += '\\f';\n                  break;\n\n                case 120\n                /*'x'*/\n                :\n                  stringHex = true;\n                  hex_char_len = 0;\n                  hex_char = 0;\n                  continue;\n\n                case 117\n                /*'u'*/\n                :\n                  stringUnicode = true;\n                  hex_char_len = 0;\n                  hex_char = 0;\n                  continue;\n\n                default:\n                  val.string += str;\n                  break;\n              } //console.log( \"other...\" );\n\n\n              stringEscape = false;\n            } else if (cInt === 92\n            /*'\\\\'*/\n            ) {\n                stringEscape = true;\n              } else {\n              if (cr_escaped) {\n                cr_escaped = false; // \\\\ \\r <any other character>\n\n                pos.line++;\n                pos.col = 2; // newline, plus one character.\n              }\n\n              val.string += str;\n            }\n          }\n\n          return retval;\n        }\n\n        function collectNumber() {\n          let _n;\n\n          while ((_n = n) < buf.length) {\n            const str = buf.charAt(_n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              throwError(\"fault while parsing number;\", cInt);\n            } //log('_DEBUG_PARSING', \"in getting number:\", n, cInt, String.fromCodePoint(cInt) );\n\n\n            if (cInt == 95\n            /*_*/\n            ) continue;\n            pos.col++; // leading zeros should be forbidden.\n\n            if (cInt >= 48\n            /*'0'*/\n            && cInt <= 57\n            /*'9'*/\n            ) {\n                if (exponent) {\n                  exponent_digit = true;\n                }\n\n                val.string += str;\n              } else if (cInt == 45\n            /*'-'*/\n            || cInt == 43\n            /*'+'*/\n            ) {\n                if (val.string.length == 0 || exponent && !exponent_sign && !exponent_digit) {\n                  val.string += str;\n                  exponent_sign = true;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 46\n            /*'.'*/\n            ) {\n                if (!decimal && !fromHex && !exponent) {\n                  val.string += str;\n                  decimal = true;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 120\n            /*'x'*/\n            || cInt == 98\n            /*'b'*/\n            || cInt == 111\n            /*'o'*/\n            || cInt == 88\n            /*'X'*/\n            || cInt == 66\n            /*'B'*/\n            || cInt == 79\n            /*'O'*/\n            ) {\n                // hex conversion.\n                if (!fromHex && val.string == '0') {\n                  fromHex = true;\n                  val.string += str;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 101\n            /*'e'*/\n            || cInt == 69\n            /*'E'*/\n            ) {\n              if (!exponent) {\n                val.string += str;\n                exponent = true;\n              } else {\n                status = false;\n                throwError(\"fault while parsing number;\", cInt); // break;\n              }\n            } else {\n              if (cInt == 32\n              /*' '*/\n              || cInt == 160\n              /* &nbsp */\n              || cInt == 13 || cInt == 10 || cInt == 9 || cInt == 0xFEFF || cInt == 44\n              /*','*/\n              || cInt == 125\n              /*'}'*/\n              || cInt == 93\n              /*']'*/\n              || cInt == 58\n              /*':'*/\n              ) {\n                  break;\n                } else {\n                if (complete_at_end) {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt);\n                }\n\n                break;\n              }\n            }\n          }\n\n          n = _n;\n\n          if (!complete_at_end && n == buf.length) {\n            gatheringNumber = true;\n          } else {\n            gatheringNumber = false;\n            val.value_type = VALUE_NUMBER;\n\n            if (parse_context == CONTEXT_UNKNOWN) {\n              completed = true;\n            }\n          }\n        }\n\n        if (!status) return -1;\n\n        if (msg && msg.length) {\n          input = getBuffer();\n          input.buf = msg;\n          inQueue.push(input);\n        } else {\n          if (gatheringNumber) {\n            //console.log( \"Force completed.\")\n            gatheringNumber = false;\n            val.value_type = VALUE_NUMBER;\n\n            if (parse_context == CONTEXT_UNKNOWN) {\n              completed = true;\n            } else {\n              throw new Error(\"context stack is not empty at flush\");\n            }\n\n            retval = 1; // if returning buffers, then obviously there's more in this one.\n          }\n        }\n\n        while (status && (input = inQueue.shift())) {\n          n = input.n;\n          buf = input.buf;\n\n          if (gatheringString) {\n            const string_status = gatherString(gatheringStringFirstChar);\n\n            if (string_status > 0) {\n              gatheringString = false;\n              val.value_type = VALUE_STRING;\n            }\n          }\n\n          if (gatheringNumber) {\n            collectNumber();\n          }\n\n          while (!completed && status && n < buf.length) {\n            let str = buf.charAt(n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              str += buf.charAt(n);\n              n++;\n            } //// log('_DEBUG_PARSING', \"parsing at \", cInt, str );\n            //log('_DEBUG_LL', \"processing: \", cInt, str, pos, comment, parse_context, word, val );\n\n\n            pos.col++;\n\n            if (comment) {\n              // '/'\n              if (comment == 1) {\n                // '/'\n                if (cInt == 42\n                /*'*'*/\n                ) {\n                    comment = 3;\n                  } // '/*'\n                else if (cInt != 47\n                  /*'/'*/\n                  ) {\n                      // '//'(NOT)\n                      throwError(\"fault while parsing;\", cInt);\n                    } else comment = 2; // '//' (valid)\n\n              } else if (comment == 2) {\n                // '// ...'\n                if (cInt == 10\n                /*'\\n'*/\n                || cInt == 13\n                /*'\\r'*/\n                ) comment = 0;\n              } else if (comment == 3) {\n                // '/*... '\n                if (cInt == 42\n                /*'*'*/\n                ) comment = 4;\n              } else {\n                // if( comment == 4 ) { // '/* ... *'\n                if (cInt == 47\n                /*'/'*/\n                ) comment = 0;else comment = 3; // any other char, goto expect * to close */\n              }\n\n              continue;\n            }\n\n            switch (cInt) {\n              case 47\n              /*'/'*/\n              :\n                comment = 1;\n                break;\n\n              case 123\n              /*'{'*/\n              :\n                if (word == WORD_POS_FIELD || word == WORD_POS_AFTER_FIELD || parse_context == CONTEXT_OBJECT_FIELD && word == WORD_POS_RESET) {\n                  throwError(\"fault while parsing; getting field name unexpected \", cInt); // break;\n                }\n\n                {\n                  const old_context = getContext(); //log('_DEBUG_PARSING', \"Begin a new object; previously pushed into elements; but wait until trailing comma or close previously:%d\", val.value_type );\n\n                  val.value_type = VALUE_OBJECT;\n                  const tmpobj = {};\n                  if (parse_context == CONTEXT_UNKNOWN) result = elements = tmpobj;\n                  old_context.context = parse_context;\n                  old_context.elements = elements;\n                  old_context.element_array = element_array;\n                  old_context.name = val.name;\n                  elements = tmpobj; //log('_DEBUG_PARSING_STACK',\"push context (open object): \", context_stack.length );\n\n                  context_stack.push(old_context);\n                  RESET_VAL();\n                  parse_context = CONTEXT_OBJECT_FIELD;\n                }\n                break;\n\n              case 91\n              /*'['*/\n              :\n                if (parse_context == CONTEXT_OBJECT_FIELD || word == WORD_POS_FIELD || word == WORD_POS_AFTER_FIELD) {\n                  throwError(\"Fault while parsing; while getting field name unexpected\", cInt); // break;\n                }\n\n                if (val.value_type == VALUE_UNSET || val.value_type == VALUE_UNDEFINED) {\n                  const old_context = getContext(); //log('_DEBUG_PARSING', \"Begin a new array; previously pushed into elements; but wait until trailing comma or close previously:%d\", val.value_type );\n\n                  val.value_type = VALUE_ARRAY;\n                  const tmparr = [];\n                  if (parse_context == CONTEXT_UNKNOWN) result = element_array = tmparr; //else if( parse_context == CONTEXT_IN_ARRAY )\n                  //    element_array.push( tmparr );\n                  else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) elements[val.name] = tmparr;\n                  old_context.context = parse_context;\n                  old_context.elements = elements;\n                  old_context.element_array = element_array;\n                  old_context.name = val.name;\n                  element_array = tmparr; //log('_DEBUG_PARSING_STACK', \"push context (open array): \", context_stack.length );\n\n                  context_stack.push(old_context);\n                  RESET_VAL();\n                  parse_context = CONTEXT_IN_ARRAY;\n                } else {\n                  throwError(\"Unexpected array open after previous value\", cInt);\n                }\n\n                break;\n\n              case 58\n              /*':'*/\n              :\n                ////log('_DEBUG_PARSING', \"colon context:\", parse_context );\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  word = WORD_POS_RESET;\n                  val.name = val.string;\n                  val.string = '';\n                  parse_context = CONTEXT_OBJECT_FIELD_VALUE;\n                  val.value_type = VALUE_UNSET;\n                } else {\n                  if (parse_context == CONTEXT_IN_ARRAY) throwError(\"(in array, got colon out of string):parsing fault;\", cInt);else throwError(\"(outside any object, got colon out of string):parsing fault;\", cInt);\n                }\n\n                break;\n\n              case 125\n              /*'}'*/\n              :\n                ////log('_DEBUG_PARSING', \"close bracket context:\", word, parse_context );\n                if (word == WORD_POS_END) {\n                  // allow starting a new word\n                  word = WORD_POS_RESET;\n                } // coming back after pushing an array or sub-object will reset the context to FIELD, so an end with a field should still push value.\n\n\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  //log('_DEBUG_PARSING', \"close object; empty object %d\", val.value_type );\n                  //RESET_VAL();\n                  val.value_type = VALUE_OBJECT;\n                  val.contains = elements;\n                  const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close obj)\", context_stack.length, old_context );\n\n                  val.name = old_context.name;\n                  parse_context = old_context.context; // this will restore as IN_ARRAY or OBJECT_FIELD\n\n                  elements = old_context.elements;\n                  element_array = old_context.element_array;\n                  dropContext(old_context);\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) {\n                  // first, add the last value\n                  //log('_DEBUG_PARSING', \"close object; push item '%s' %d\", val.name, val.value_type );\n                  if (val.value_type != VALUE_UNSET) {\n                    objectPush();\n                  } else {\n                    throwError(\"Fault while parsing field value, close with no value\", cInt);\n                  }\n\n                  val.value_type = VALUE_OBJECT;\n                  val.contains = elements;\n                  const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close object)\", context_stack.length, old_context );\n\n                  val.name = old_context.name;\n                  parse_context = old_context.context; // this will restore as IN_ARRAY or OBJECT_FIELD\n\n                  elements = old_context.elements;\n                  element_array = old_context.element_array;\n                  dropContext(old_context);\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else {\n                  throwError(\"Fault while parsing; unexpected\", cInt);\n                }\n\n                negative = false;\n                break;\n\n              case 93\n              /*']'*/\n              :\n                if (word == WORD_POS_END) word = WORD_POS_RESET;\n\n                if (parse_context == CONTEXT_IN_ARRAY) {\n                  //log('_DEBUG_PARSING', \"close array, push last element: %d\", val.value_type );\n                  if (val.value_type != VALUE_UNSET) {\n                    arrayPush();\n                  }\n\n                  val.value_type = VALUE_ARRAY;\n                  val.contains = element_array;\n                  {\n                    const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close array)\", context_stack.length );\n\n                    val.name = old_context.name;\n                    parse_context = old_context.context;\n                    elements = old_context.elements;\n                    element_array = old_context.element_array;\n                    dropContext(old_context);\n                  }\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else {\n                  throwError(`bad context ${parse_context}; fault while parsing`, cInt); // fault\n                }\n\n                negative = false;\n                break;\n\n              case 44\n              /*','*/\n              :\n                if (word == WORD_POS_END) word = WORD_POS_RESET; // allow collect new keyword\n                //log('_DEBUG_PARSING', \"comma context:\", parse_context, val );\n\n                if (parse_context == CONTEXT_IN_ARRAY) {\n                  if (val.value_type == VALUE_UNSET) val.value_type = VALUE_EMPTY; // in an array, elements after a comma should init as undefined...\n                  //log('_DEBUG_PARSING', \"back in array; push item %d\", val.value_type );\n\n                  arrayPush();\n                  RESET_VAL(); // undefined allows [,,,] to be 4 values and [1,2,3,] to be 4 values with an undefined at end.\n                } else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) {\n                  // after an array value, it will have returned to OBJECT_FIELD anyway\n                  //log('_DEBUG_PARSING', \"comma after field value, push field to object: %s\", val.name );\n                  parse_context = CONTEXT_OBJECT_FIELD;\n\n                  if (val.value_type != VALUE_UNSET) {\n                    objectPush();\n                    RESET_VAL();\n                  } else throwError(\"Unexpected comma after object field name\", cInt);\n                } else {\n                  status = false;\n                  throwError(\"bad context; excessive commas while parsing;\", cInt); // fault\n                }\n\n                negative = false;\n                break;\n\n              default:\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  switch (cInt) {\n                    case 96: //'`':\n\n                    case 34: //'\"':\n\n                    case 39:\n                      //'\\'':\n                      if (word == WORD_POS_RESET) {\n                        if (val.value_type != VALUE_UNSET) throwError(\"String begin after previous value\", cInt);\n                        const string_status = gatherString(cInt); //log('_DEBUG_PARSING', \"string gather for object field name :\", val.string, string_status );\n\n                        if (string_status) {\n                          val.value_type = VALUE_STRING;\n                        } else {\n                          gatheringStringFirstChar = cInt;\n                          gatheringString = true;\n                        }\n                      } else {\n                        throwError(\"fault while parsing; quote not at start of field name\", cInt);\n                      }\n\n                      break;\n\n                    case 10:\n                      //'\\n':\n                      pos.line++;\n                      pos.col = 1;\n                    // fall through to normal space handling - just updated line/col position\n\n                    case 13: //'\\r':\n\n                    case 32: //' ':\n\n                    case 160: //&nbsp:\n\n                    case 9: //'\\t':\n\n                    case 0xFEFF:\n                      // ZWNBS is WS though\n                      if (word == WORD_POS_END) {\n                        // allow collect new keyword\n                        word = WORD_POS_RESET;\n                      } else if (word == WORD_POS_FIELD) {\n                        word = WORD_POS_AFTER_FIELD;\n                      } // skip whitespace\n\n\n                      break;\n\n                    default:\n                      if (word == WORD_POS_AFTER_FIELD) {\n                        status = false;\n                        throwError(\"fault while parsing; character unexpected\", cInt);\n                      }\n\n                      if (word == WORD_POS_RESET) word = WORD_POS_FIELD;\n                      val.string += str;\n                      break;\n                    // default\n                  }\n                } else switch (cInt) {\n                  case 96: //'`':\n\n                  case 34: //'\"':\n\n                  case 39:\n                    {\n                      //'\\'':\n                      if (val.value_type === VALUE_UNSET) {\n                        const string_status = gatherString(cInt); //log('_DEBUG_PARSING', \"string gather for object field value :\", val.string, string_status, completed, input.n, buf.length );\n\n                        if (string_status) {\n                          val.value_type = VALUE_STRING;\n                          word = WORD_POS_END;\n                        } else {\n                          gatheringStringFirstChar = cInt;\n                          gatheringString = true;\n                        }\n                      } else throwError(\"String unexpected\", cInt);\n\n                      break;\n                    }\n\n                  case 10:\n                    //'\\n':\n                    pos.line++;\n                    pos.col = 1;\n                  // Fallthrough\n\n                  case 32: //' ':\n\n                  case 160: // &nbsp\n\n                  case 9: //'\\t':\n\n                  case 13: //'\\r':\n\n                  case 0xFEFF:\n                    //'\\uFEFF':\n                    if (word == WORD_POS_END) {\n                      word = WORD_POS_RESET;\n\n                      if (parse_context == CONTEXT_UNKNOWN) {\n                        completed = true;\n                      }\n\n                      break;\n                    }\n\n                    if (word !== WORD_POS_RESET) {\n                      // breaking in the middle of gathering a keyword.\n                      status = false;\n                      throwError(\"fault parsing whitespace\", cInt);\n                    }\n\n                    break;\n                  //----------------------------------------------------------\n                  //  catch characters for true/false/null/undefined which are values outside of quotes\n\n                  case 116:\n                    //'t':\n                    if (word == WORD_POS_RESET) word = WORD_POS_TRUE_1;else if (word == WORD_POS_INFINITY_6) word = WORD_POS_INFINITY_7;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 114:\n                    //'r':\n                    if (word == WORD_POS_TRUE_1) word = WORD_POS_TRUE_2;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 117:\n                    //'u':\n                    if (word == WORD_POS_TRUE_2) word = WORD_POS_TRUE_3;else if (word == WORD_POS_NULL_1) word = WORD_POS_NULL_2;else if (word == WORD_POS_RESET) word = WORD_POS_UNDEFINED_1;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 101:\n                    //'e':\n                    if (word == WORD_POS_TRUE_3) {\n                      val.value_type = VALUE_TRUE;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_FALSE_4) {\n                      val.value_type = VALUE_FALSE;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_UNDEFINED_3) word = WORD_POS_UNDEFINED_4;else if (word == WORD_POS_UNDEFINED_7) word = WORD_POS_UNDEFINED_8;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n\n                    break;\n\n                  case 110:\n                    //'n':\n                    if (word == WORD_POS_RESET) word = WORD_POS_NULL_1;else if (word == WORD_POS_UNDEFINED_1) word = WORD_POS_UNDEFINED_2;else if (word == WORD_POS_UNDEFINED_6) word = WORD_POS_UNDEFINED_7;else if (word == WORD_POS_INFINITY_1) word = WORD_POS_INFINITY_2;else if (word == WORD_POS_INFINITY_4) word = WORD_POS_INFINITY_5;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 100:\n                    //'d':\n                    if (word == WORD_POS_UNDEFINED_2) word = WORD_POS_UNDEFINED_3;else if (word == WORD_POS_UNDEFINED_8) {\n                      val.value_type = VALUE_UNDEFINED;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 105:\n                    //'i':\n                    if (word == WORD_POS_UNDEFINED_5) word = WORD_POS_UNDEFINED_6;else if (word == WORD_POS_INFINITY_3) word = WORD_POS_INFINITY_4;else if (word == WORD_POS_INFINITY_5) word = WORD_POS_INFINITY_6;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 108:\n                    //'l':\n                    if (word == WORD_POS_NULL_2) word = WORD_POS_NULL_3;else if (word == WORD_POS_NULL_3) {\n                      val.value_type = VALUE_NULL;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_FALSE_2) word = WORD_POS_FALSE_3;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 102:\n                    //'f':\n                    if (word == WORD_POS_RESET) word = WORD_POS_FALSE_1;else if (word == WORD_POS_UNDEFINED_4) word = WORD_POS_UNDEFINED_5;else if (word == WORD_POS_INFINITY_2) word = WORD_POS_INFINITY_3;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 97:\n                    //'a':\n                    if (word == WORD_POS_FALSE_1) word = WORD_POS_FALSE_2;else if (word == WORD_POS_NAN_1) word = WORD_POS_NAN_2;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 115:\n                    //'s':\n                    if (word == WORD_POS_FALSE_3) word = WORD_POS_FALSE_4;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 73:\n                    //'I':\n                    if (word == WORD_POS_RESET) word = WORD_POS_INFINITY_1;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 78:\n                    //'N':\n                    if (word == WORD_POS_RESET) word = WORD_POS_NAN_1;else if (word == WORD_POS_NAN_2) {\n                      val.value_type = negative ? VALUE_NEG_NAN : VALUE_NAN;\n                      negative = false;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 121:\n                    //'y':\n                    if (word == WORD_POS_INFINITY_7) {\n                      val.value_type = negative ? VALUE_NEG_INFINITY : VALUE_INFINITY;\n                      negative = false;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n\n                    break;\n\n                  case 45:\n                    //'-':\n                    if (word == WORD_POS_RESET) negative = !negative;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n                  //\n                  //----------------------------------------------------------\n\n                  default:\n                    if (cInt >= 48\n                    /*'0'*/\n                    && cInt <= 57\n                    /*'9'*/\n                    || cInt == 43\n                    /*'+'*/\n                    || cInt == 46\n                    /*'.'*/\n                    || cInt == 45\n                    /*'-'*/\n                    ) {\n                      fromHex = false;\n                      exponent = false;\n                      exponent_sign = false;\n                      exponent_digit = false;\n                      decimal = false;\n                      val.string = str;\n                      input.n = n;\n                      collectNumber();\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    }\n\n                    break;\n                  // default\n                }\n\n                break;\n              // default of high level switch\n            }\n\n            if (completed) {\n              if (word == WORD_POS_END) {\n                word = WORD_POS_RESET;\n              }\n\n              break;\n            }\n          }\n\n          if (n == buf.length) {\n            dropBuffer(input);\n\n            if (gatheringString || gatheringNumber || parse_context == CONTEXT_OBJECT_FIELD) {\n              retval = 0;\n            } else {\n              if (parse_context == CONTEXT_UNKNOWN && (val.value_type != VALUE_UNSET || result)) {\n                completed = true;\n                retval = 1;\n              }\n            }\n          } else {\n            // put these back into the stack.\n            input.n = n;\n            inQueue.unshift(input);\n            retval = 2; // if returning buffers, then obviously there's more in this one.\n          }\n\n          if (completed) break;\n        }\n\n        if (completed && val.value_type != VALUE_UNSET) {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              result = (negative ? -1 : 1) * Number(val.string);\n              break;\n\n            case VALUE_STRING:\n              result = val.string;\n              break;\n\n            case VALUE_TRUE:\n              result = true;\n              break;\n\n            case VALUE_FALSE:\n              result = false;\n              break;\n\n            case VALUE_NULL:\n              result = null;\n              break;\n\n            case VALUE_UNDEFINED:\n              result = undefined;\n              break;\n\n            case VALUE_NAN:\n              result = NaN;\n              break;\n\n            case VALUE_NEG_NAN:\n              result = -NaN;\n              break;\n\n            case VALUE_INFINITY:\n              result = Infinity;\n              break;\n\n            case VALUE_NEG_INFINITY:\n              result = -Infinity;\n              break;\n\n            case VALUE_OBJECT:\n              // never happens\n              result = val.contains;\n              break;\n\n            case VALUE_ARRAY:\n              // never happens\n              result = val.contains;\n              break;\n          }\n\n          negative = false;\n          val.string = '';\n          val.value_type = VALUE_UNSET;\n        }\n\n        completed = false;\n        return retval;\n      }\n\n    };\n  };\n\n  const _parser = [Object.freeze(JSON6.begin())];\n  let _parse_level = 0;\n\n  JSON6.parse = function (msg, reviver) {\n    //var parser = JSON6.begin();\n    const parse_level = _parse_level++;\n    if (_parser.length <= parse_level) _parser.push(Object.freeze(JSON6.begin()));\n    const parser = _parser[parse_level];\n    if (typeof msg !== \"string\") msg = String(msg);\n    parser.reset();\n\n    if (parser._write(msg, true) > 0) {\n      const result = parser.value();\n      if (typeof reviver === 'function') (function walk(holder, key) {\n        const value = holder[key];\n\n        if (value && typeof value === 'object') {\n          for (const k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k)) {\n              const v = walk(value, k);\n\n              if (v !== undefined) {\n                value[k] = v;\n              } else {\n                delete value[k];\n              }\n            }\n          }\n        }\n\n        return reviver.call(holder, key, value);\n      })({\n        '': result\n      }, '');\n      _parse_level--;\n      return result;\n    } else parser.finalError();\n\n    return undefined;\n  };\n\n  JSON6.stringify = JSON.stringify;\n});\n\nvar lib = json6;\n\nexport default lib;\n","// We want it to work in the browser, so commenting out\n// import jsonExtra from 'json5';\n// import jsonExtra from 'json-6';\n\n// We need this for the browser version to work, but this breaks nyc;\n//  see https://github.com/standard-things/esm/issues/839\n// import jsonExtra from '../node_modules/json-6/dist/index.mjs';\nimport jsonExtra from 'json-6';\n\nexport const unescapeBackslashes = (str) => {\n  return str.replace(/\\\\+/gu, (esc) => {\n    return esc.slice(0, esc.length / 2);\n  });\n};\n\nexport const parseJSONExtra = (args) => {\n  return jsonExtra.parse(\n    // Doesn't actually currently allow explicit brackets,\n    //  but in case we change our regex to allow inner brackets\n    '{' + (args || '').replace(/^\\{/u, '').replace(/\\}$/u, '') + '}'\n  );\n};\n\n// Todo: Extract to own library (RegExtras?)\nexport const processRegex = (regex, str, {\n  onMatch,\n  extra,\n  betweenMatches,\n  afterMatch,\n  escapeAtOne\n}) => {\n  let match;\n  let previousIndex = 0;\n  if (extra) {\n    betweenMatches = extra;\n    afterMatch = extra;\n    escapeAtOne = extra;\n  }\n  while ((match = regex.exec(str)) !== null) {\n    const [_, esc] = match;\n    const {lastIndex} = regex;\n\n    const startMatchPos = lastIndex - _.length;\n    if (startMatchPos > previousIndex) {\n      betweenMatches(str.slice(previousIndex, startMatchPos));\n    }\n\n    if (escapeAtOne && esc.length % 2) {\n      previousIndex = lastIndex;\n      escapeAtOne(_);\n      continue;\n    }\n    onMatch(...match);\n    previousIndex = lastIndex;\n  }\n  if (previousIndex !== str.length) { // Get text at end\n    afterMatch(str.slice(previousIndex));\n  }\n};\n","/* globals fetch, document */\nlet _fetch = typeof fetch !== 'undefined'\n  // istanbul ignore next\n  ? fetch\n  : null;\n\n/**\n * @param {fetch} f\n * @returns {void}\n */\nexport const setFetch = (f) => {\n  _fetch = f;\n};\n\n/**\n * @returns {fetch}\n */\nexport const getFetch = () => {\n  return _fetch;\n};\n\nlet _doc = typeof document !== 'undefined'\n  // istanbul ignore next\n  ? document\n  : null;\n\n/**\n * @param {document} doc\n * @returns {void}\n */\nexport const setDocument = (doc) => {\n  _doc = doc;\n};\n\n/**\n * @returns {document}\n */\nexport const getDocument = () => {\n  return _doc;\n};\n","/* globals performance */\nimport {processRegex} from './utils.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/**\n *\n * @returns {string}\n */\nfunction generateUUID () { //  Adapted from original: public domain/MIT: http://stackoverflow.com/a/8809472/271577\n  let d = Date.now();\n  /* istanbul ignore next */\n  if (typeof performance !== 'undefined' &&\n      typeof performance.now === 'function'\n  ) {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, function (c) {\n    /* eslint-disable no-bitwise */\n    const r = Math.trunc((d + Math.random() * 16) % 16);\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n    /* eslint-enable no-bitwise */\n  });\n}\n\nexport const sort = (locale, arrayOfItems, options) => {\n  return arrayOfItems.sort(new Intl.Collator(\n    locale,\n    options\n  ).compare);\n};\n\nexport const list = (locale, arrayOfItems, options) => {\n  return new Intl.ListFormat(\n    locale, options\n  ).format(arrayOfItems);\n};\n\nexport const sortListSimple = (\n  locale, arrayOfItems, listOptions, collationOptions\n) => {\n  sort(locale, arrayOfItems, collationOptions);\n  return list(locale, arrayOfItems, listOptions);\n};\n\nexport const sortList = (\n  locale, arrayOfItems, map, listOptions, collationOptions\n) => {\n  if (typeof map !== 'function') {\n    return sortListSimple(locale, arrayOfItems, map, listOptions);\n  }\n  sort(locale, arrayOfItems, collationOptions);\n\n  const randomId = generateUUID();\n\n  const placeholderArray = [...arrayOfItems].map(\n    (_, i) => `<<${randomId}${i}>>`\n  );\n  const nodes = [];\n  const push = (...args) => {\n    nodes.push(...args);\n  };\n\n  processRegex(\n    // // eslint-disable-next-line prefer-named-capture-group\n    new RegExp(`<<${randomId}(\\\\d)>>`, 'gu'),\n    list(locale, placeholderArray, listOptions), {\n      betweenMatches: push,\n      afterMatch: push,\n      onMatch (_, idx) {\n        push(map(arrayOfItems[idx], idx));\n      }\n    }\n  );\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n  return container;\n};\n","import {parseJSONExtra} from './utils.js';\nimport {sortList} from './collation.js';\n\nexport const getFormatterInfo = ({object}) => {\n  if (Array.isArray(object)) {\n    if (typeof object[1] === 'function') {\n      const [value, callback, options, extraOpts] = object;\n      return {value, callback, options, extraOpts};\n    }\n    const [value, options, extraOpts] = object;\n    return {value, options, extraOpts};\n  }\n  return {value: object};\n};\n\n/* eslint-disable max-len */\n/**\n * Callback to give replacement text based on a substitution value.\n * @callback AllSubstitutionCallback\n * @param {PlainObject} cfg\n * @param {string|Node|number|Date|RelativeTimeInfo|ListInfo|NumberInfo|DateInfo} cfg.value Contains\n *   the value returned by the individual substitution\n * @param {string} cfg.arg See `cfg.arg` of {@link SubstitutionCallback}.\n * @param {string} cfg.key The substitution key Not currently in use\n * @param {string} cfg.locale The locale\n * @returns {string|Element} The replacement text or element\n*/\n/* eslint-enable max-len */\n\n/**\n * @type {AllSubstitutionCallback}\n */\nexport const defaultAllSubstitutions = ({value, arg, key, locale}) => {\n  // Strings or DOM Nodes\n  if (\n    typeof value === 'string' || (value && typeof value === 'object' &&\n    'nodeType' in value)\n  ) {\n    return value;\n  }\n\n  let opts;\n\n  const applyArgs = ({type, options = opts, checkArgOptions = false}) => {\n    if (typeof arg === 'string') {\n      let [userType, extraArgs, argOptions] = arg.split('|');\n      // Alias\n      if (userType === 'DATE') {\n        userType = 'DATETIME';\n      }\n      if (userType === type) {\n        if (!extraArgs) {\n          options = {};\n        } else if (!checkArgOptions || argOptions) {\n          // Todo: Allow escaping and restoring of pipe symbol\n          options = {\n            ...options,\n            ...parseJSONExtra(\n              checkArgOptions && argOptions ? argOptions : extraArgs\n            )\n          };\n        }\n      }\n    }\n    return options;\n  };\n\n  if (value && typeof value === 'object') {\n    const singleKey = Object.keys(value)[0];\n    if ([\n      'number', 'date', 'datetime', 'relative', 'list', 'plural'\n    ].includes(singleKey)) {\n      let extraOpts, callback;\n      ({\n        value, options: opts, extraOpts, callback\n      } = getFormatterInfo({object: value[singleKey]}));\n\n      switch (singleKey) {\n      case 'relative':\n        // The second argument actually contains the primary options, so swap\n        [extraOpts, opts] = [opts, extraOpts];\n        return new Intl.RelativeTimeFormat(\n          locale, applyArgs({type: 'RELATIVE'})\n        ).format(value, extraOpts);\n\n      // ListFormat (with Collator)\n      case 'list':\n        if (callback) {\n          return sortList(\n            locale, value, callback,\n            applyArgs({type: 'LIST'}),\n            applyArgs({\n              type: 'LIST', options: extraOpts, checkArgOptions: true\n            })\n          );\n        }\n        return sortList(locale, value, applyArgs({type: 'LIST'}), applyArgs({\n          type: 'LIST', options: extraOpts, checkArgOptions: true\n        }));\n      default:\n        // Let `number` and `date` types drop through so their options\n        //  can be applied\n        // Let `plural` be treated as number (since value should be a number)\n        break;\n      }\n    }\n  }\n\n  // Numbers\n  if (typeof value === 'number') {\n    return new Intl.NumberFormat(\n      locale,\n      applyArgs({type: 'NUMBER'})\n    ).format(value);\n  }\n\n  // Dates\n  if (\n    value && typeof value === 'object' &&\n    typeof value.getTime === 'function'\n  ) {\n    return new Intl.DateTimeFormat(\n      locale,\n      applyArgs({type: 'DATETIME'})\n    ).format(value);\n  }\n\n  // console.log('value', value);\n  throw new TypeError('Unknown formatter');\n};\n","import {getMessageForKeyByStyle} from './index.js';\nimport {parseJSONExtra} from './utils.js';\nimport {getFormatterInfo} from './defaultAllSubstitutions.js';\n\n/**\n * Base class for formatting.\n */\nexport class Formatter {\n}\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.key\n * @param {LocaleBody} cfg.body\n * @param {string} cfg.type\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} cfg.messageStyle\n * @returns {string|Element}\n */\nconst getSubstitution = ({key, body, type, messageStyle = 'richNested'}) => {\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const substitution = messageForKey({body}, key);\n  if (!substitution) {\n    throw new Error(`Key value not found for ${type} key: (${key})`);\n  }\n  // We don't allow a substitution function here or below as comes\n  //  from locale and locale content should not pose security concerns\n  return substitution.value;\n};\n\n/**\n * Formatter for local variables.\n */\nexport class LocalFormatter extends Formatter {\n  /**\n   * @param {LocalObject} locals\n   */\n  constructor (locals) {\n    super();\n    this.locals = locals;\n  }\n  /**\n   * @param {string} key\n   * @returns {string|Element}\n   */\n  getSubstitution (key) {\n    return getSubstitution({\n      key: key.slice(1), body: this.locals, type: 'local'\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    const components = key.slice(1).split('.');\n    let parent = this.locals;\n    return this.constructor.isMatchingKey(key) && components.every((cmpt) => {\n      const result = cmpt in parent;\n      parent = parent[cmpt];\n      return result;\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('-');\n  }\n}\n\n/**\n * Formatter for regular variables.\n */\nexport class RegularFormatter extends Formatter {\n  /**\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (substitutions) {\n    super();\n    this.substitutions = substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return this.constructor.isMatchingKey(key) && key in this.substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return (/^\\w/u).test(key);\n  }\n}\n\n/**\n * Formatter for switch variables.\n */\nexport class SwitchFormatter extends Formatter {\n  /**\n   * @param {Switches} switches\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (switches, {substitutions}) {\n    super();\n    this.switches = switches;\n    this.substitutions = substitutions;\n  }\n\n  /**\n   * @param {string} key\n   * @param {PlainObject} cfg\n   * @param {string} cfg.locale\n   * @param {string[]} cfg.usedKeys\n   * @param {string} cfg.arg\n   * @param {MissingSuppliedFormattersCallback} cfg.missingSuppliedFormatters\n   * @returns {string}\n   */\n  getSubstitution (key, {locale, usedKeys, arg, missingSuppliedFormatters}) {\n    const ky = this.constructor.getKey(key).slice(1);\n    // Expression might not actually use formatter, e.g., for singular,\n    //  the conditional might just write out \"one\"\n\n    const [objKey, body, keySegment] = this.getMatch(ky);\n    usedKeys.push(keySegment);\n\n    let type, opts;\n    if (objKey && objKey.includes('|')) {\n      [, type, opts] = objKey.split('|');\n    }\n    if (!body) {\n      missingSuppliedFormatters({\n        key,\n        formatter: this\n      });\n      return '\\\\{' + key + '}';\n    }\n\n    /*\n    if (!(ky in this.substitutions)) {\n      throw new Error(`Switch expecting formatter: ${ky}`);\n    }\n    */\n\n    const getNumberFormat = (value, defaultOptions) => {\n      const numberOpts = parseJSONExtra(opts);\n      return new Intl.NumberFormat(locale, {\n        ...defaultOptions, ...numberOpts\n      }).format(value);\n    };\n\n    const getPluralFormat = (value, defaultOptions) => {\n      const pluralOpts = parseJSONExtra(opts);\n      return new Intl.PluralRules(locale, {\n        ...defaultOptions, ...pluralOpts\n      }).select(value);\n    };\n\n    const formatterValue = this.substitutions[keySegment];\n\n    let match = formatterValue;\n    if (typeof formatterValue === 'number') {\n      switch (type) {\n      case 'NUMBER':\n        match = getNumberFormat(formatterValue);\n        break;\n      case 'PLURAL':\n        match = getPluralFormat(formatterValue);\n        break;\n      default:\n        match = new Intl.PluralRules(locale).select(formatterValue);\n        break;\n      }\n    } else if (formatterValue && typeof formatterValue === 'object') {\n      const singleKey = Object.keys(formatterValue)[0];\n      if (['number', 'plural'].includes(singleKey)) {\n        const {value, options} = getFormatterInfo({\n          object: formatterValue[singleKey]\n        });\n        if (!type) {\n          type = singleKey.toUpperCase();\n        }\n        const typeMatches = singleKey.toUpperCase() === type;\n        if (!typeMatches) {\n          throw new TypeError(\n            `Expecting type \"${\n              type.toLowerCase()\n            }\"; instead found \"${singleKey}\".`\n          );\n        }\n        // eslint-disable-next-line default-case\n        switch (type) {\n        case 'NUMBER':\n          match = getNumberFormat(value, options);\n          break;\n        case 'PLURAL':\n          match = getPluralFormat(value, options);\n          break;\n        }\n      }\n    }\n\n    // We do not want the default `richNested` here as that will split\n    //  up the likes of `0.0`\n    const messageStyle = 'richNested';\n\n    const preventNesting = (s) => {\n      return s.replace(/\\\\/gu, '\\\\\\\\').replace(/\\./gu, '\\\\.');\n    };\n\n    try {\n      return getSubstitution({\n        messageStyle,\n        key: match ? preventNesting(match) : arg,\n        body,\n        type: 'switch'\n      });\n    } catch (err) {\n      try {\n        return getSubstitution({\n          messageStyle, key: '*' + preventNesting(match), body, type: 'switch'\n        });\n      } catch (error) {\n        const k = Object.keys(body).find(\n          (switchKey) => switchKey.startsWith('*')\n        );\n        if (!k) {\n          throw new Error(`No defaults found for switch ${ky}`);\n        }\n        return getSubstitution({\n          messageStyle, key: preventNesting(k), body, type: 'switch'\n        });\n      }\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return key && this.constructor.isMatchingKey(key) &&\n      Boolean(this.getMatch(key.slice(1)).length);\n  }\n\n  /**\n  * @typedef {GenericArray} SwitchMatch\n  * @property {string} 0 objKey\n  * @property {LocaleBody} 1 body\n  * @property {string} 2 keySegment\n  */\n\n  /**\n   * @param {string} ky\n   * @returns {SwitchMatch}\n   */\n  getMatch (ky) {\n    const ks = ky.split('.');\n    return ks.reduce((obj, k, i) => {\n      if (i < ks.length - 1) {\n        if (!(k in obj)) {\n          throw new Error(`Switch key \"${k}\" not found (from \"~${ky}\")`);\n        }\n        return obj[k];\n      }\n      // Todo: Should throw on encountering duplicate fundamental keys (even\n      //  if there are different arguments, that should not be allowed)\n      const ret = Object.entries(obj).find(([switchKey]) => {\n        return k === this.constructor.getKey(switchKey);\n      });\n\n      return ret ? ret.concat(k) : [];\n    }, this.switches);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('~');\n  }\n  /**\n   * @param {string} key\n   * @returns {string}\n   */\n  static getKey (key) {\n    const match = key.match(/^[^|]*/u);\n    return match && match[0];\n  }\n}\n","/**\n* @callback PromiseChainErrback\n* @param {any} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @param {string} [errorMessage=\"Reached end of values array.\"]\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\n promiseChainForValues(['a', 'b', 'c'], (val) => {\n   return new Promise(function (resolve, reject) {\n     if (val === 'a') {\n       reject(new Error('missing'));\n     }\n     setTimeout(() => {\n       resolve(val);\n     }, 100);\n   });\n });\n */\nexport const promiseChainForValues = (\n  values, errBack, errorMessage = 'Reached end of values array.'\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(\n      'The `values` argument to `promiseChainForValues` must be an array.'\n    );\n  }\n  if (typeof errBack !== 'function') {\n    throw new TypeError(\n      'The `errBack` argument to `promiseChainForValues` must be a function.'\n    );\n  }\n  return (async () => {\n    let ret;\n    let p = Promise.reject(\n      new Error('Intentionally reject so as to begin checking chain')\n    );\n    let breaking;\n    while (true) {\n      const value = values.shift();\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        ret = await p;\n        break;\n      } catch (err) {\n        if (breaking) {\n          throw new Error(errorMessage);\n        }\n        // We allow one more try\n        if (!values.length) {\n          breaking = true;\n        }\n        // // eslint-disable-next-line no-await-in-loop\n        p = errBack(value);\n      }\n    }\n    return ret;\n  })();\n};\n","/**\n* @callback SubstitutionCallback\n* @param {PlainObject} cfg\n* @param {string} cfg.arg By default, accepts the third portion of the\n*   `formattingRegex` within `insertNodes`, i.e., to allow the locale to\n*   supply arguments back to the calling script.\n* @param {string} cfg.key The substitution key\n* @returns {string|Element} The replacement text or element\n*/\n\n/**\n * May have additional properties if supplying options to an underlying\n * formatter.\n * @typedef {GenericArray} ValueArray\n * @property {string|Node|number|Date} 0 The main value\n * @property {PlainObject} [1] The options related to the main value\n * @property {PlainObject} [2] Any additional options\n*/\n\n/**\n* @typedef {PlainObject} RelativeTimeInfo\n* @property {ValueArray} relative\n*/\n\n/**\n* @typedef {PlainObject} ListInfo\n* @property {ValueArray} list\n*/\n\n/**\n* @typedef {PlainObject} NumberInfo\n* @property {ValueArray} number\n*/\n\n/**\n* @typedef {PlainObject} DateInfo\n* @property {ValueArray} date\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringBodyObject\n*/\n\n/**\n* @typedef {PlainObject} SwitchCaseInfo\n* @property {boolean} [default=false] Whether this conditional is the default\n*/\n\n/**\n* @typedef {GenericArray} SwitchCase\n* @property {string} 0 The type\n* @property {string} 1 The message\n* @property {SwitchCaseInfo} [2] Info about the switch case\n*/\n\n/**\n* @typedef {PlainObject<string, SwitchCase>} Switch\n*/\n\n/**\n* @typedef {PlainObject<{string, Switch}>} Switches\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} [message] The locale message with any formatting\n*   place-holders; defaults to use of any single conditional\n* @property {string} [description] A description to add translators\n* @property {Switches} [switches] Conditionals\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringBodyObject\n*/\n\n/**\n * Takes a base path and locale and gives a URL.\n * @callback LocaleResolver\n * @param {string} localesBasePath (Trailing slash optional)\n * @param {string} locale BCP-47 language string\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|SubstitutionCallback>}\n*   SubstitutionObject\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (localesBasePath, locale) => {\n  if (typeof localesBasePath !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `localesBasePath`.'\n    );\n  }\n  if (typeof locale !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `locale`.'\n    );\n  }\n  if ((/[./\\\\]/u).test(locale)) {\n    throw new TypeError(\n      'Locales cannot use file-reserved characters, `.`, `/` or `\\\\`'\n    );\n  }\n  return `${localesBasePath.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n","import {\n  LocalFormatter, RegularFormatter, SwitchFormatter\n} from './Formatter.js';\nimport {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {unescapeBackslashes, parseJSONExtra, processRegex} from './utils.js';\n\n/* eslint-disable max-len */\n/**\n * Callback to return a string or array of nodes and strings based on a localized\n * string, substitutions object, and other metadata.\n * @callback InsertNodesCallback\n * @param {PlainObject} cfg\n * @param {string} cfg.string The localized string\n * @param {boolean} [cfg.dom] If substitutions known to contain DOM, can be set\n *   to `true` to optimize\n * @param {string[]} [cfg.usedKeys=[]] Array for tracking which keys have been used\n * @param {SubstitutionObject} cfg.substitutions The formatting substitutions object\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions] The\n *   callback or array composed thereof for applying to each substitution.\n * @param {string} locale The successfully resolved locale\n * @param {Integer} [maximumLocalNestingDepth=3] Depth of local variable resolution to\n *   check before reporting a recursion error\n * @param {MissingSuppliedFormattersCallback} [cfg.missingSuppliedFormatters] Callback\n *   supplied key to throw if the supplied key is present (if\n *   `throwOnMissingSuppliedFormatters` is enabled). Defaults to no-op.\n * @param {CheckExtraSuppliedFormattersCallback} [cfg.checkExtraSuppliedFormatters] No\n *   argument callback to check if any formatters are not present in `string`\n *   (if `throwOnExtraSuppliedFormatters` is enabled). Defaults to no-op.\n * @returns {string|Array<Node|string>}\n */\n\n/**\n * @type {InsertNodesCallback}\n */\nexport const defaultInsertNodes = ({\n  /* eslint-enable max-len */\n  string, dom, usedKeys, substitutions, allSubstitutions, locale,\n  locals, switches,\n  maximumLocalNestingDepth = 3,\n  missingSuppliedFormatters,\n  checkExtraSuppliedFormatters\n}) => {\n  if (typeof maximumLocalNestingDepth !== 'number') {\n    throw new TypeError('`maximumLocalNestingDepth` must be a number.');\n  }\n  const localFormatter = new LocalFormatter(locals);\n  const regularFormatter = new RegularFormatter(substitutions);\n  const switchFormatter = new SwitchFormatter(switches, {substitutions});\n\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  const formattingRegex = /(\\\\*)\\{((?:[^}]|\\\\\\})*?)(?:(\\|)([^}]*))?\\}/gu;\n  if (allSubstitutions) {\n    allSubstitutions = Array.isArray(allSubstitutions)\n      ? allSubstitutions\n      : [allSubstitutions];\n  }\n\n  const getSubstitution = ({key, arg, substs}) => {\n    let substitution;\n    const isLocalKey = localFormatter.constructor.isMatchingKey(key);\n    if (isLocalKey) {\n      substitution = localFormatter.getSubstitution(key);\n    } else if (switchFormatter.constructor.isMatchingKey(key)) {\n      substitution = switchFormatter.getSubstitution(key, {\n        locale, usedKeys, arg,\n        missingSuppliedFormatters\n      });\n    } else {\n      substitution = substs[key];\n      if (typeof substitution === 'function') {\n        substitution = substitution({arg, key});\n      }\n    }\n    // Todo: Could support resolving locals within arguments\n    // Todo: Even for `null` `allSubstitutions`, we could have\n    //  a mode to throw for non-string/non-DOM (non-numbers?),\n    //  or whatever is not likely intended as a target for `toString()`.\n    if (allSubstitutions) {\n      substitution = allSubstitutions.reduce((subst, allSubst) => {\n        return allSubst({\n          value: subst, arg, key, locale\n        });\n      }, substitution);\n    } else if (arg && arg.match(/^(?:NUMBER|DATE(?:TIME)?|RELATIVE|LIST)(?:\\||$)/u)) {\n      substitution = defaultAllSubstitutions({\n        value: substitution, arg, key, locale\n      });\n    }\n    return substitution;\n  };\n\n  let recursiveLocalCount = 1;\n  const checkLocalVars = ({substitution, ky, arg, processSubsts}) => {\n    if (\n      typeof substitution === 'string' &&\n      substitution.includes('{')\n    ) {\n      if (recursiveLocalCount++ > maximumLocalNestingDepth) {\n        throw new TypeError('Too much recursion in local variables.');\n      }\n\n      if (localFormatter.constructor.isMatchingKey(ky)) {\n        let extraSubsts = substitutions;\n        let localFormatters;\n        if (arg) {\n          localFormatters = parseJSONExtra(arg);\n          extraSubsts = {\n            ...substitutions,\n            ...localFormatters\n          };\n        }\n        substitution = processSubsts({\n          str: substitution, substs: extraSubsts,\n          formatter: localFormatter\n        });\n        if (localFormatters) {\n          checkExtraSuppliedFormatters({substitutions: localFormatters});\n        }\n      } else if (switchFormatter.constructor.isMatchingKey(ky)) {\n        substitution = processSubsts({\n          str: substitution\n        });\n      }\n    }\n    return substitution;\n  };\n\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    // Run this block to optimize non-DOM substitutions\n    let returnsDOM = false;\n    const replace = ({\n      str, substs = substitutions,\n      formatter = regularFormatter\n    }) => {\n      return str.replace(formattingRegex, (_, esc, ky, pipe, arg) => {\n        if (esc.length % 2) {\n          return _;\n        }\n        if (missingSuppliedFormatters({\n          key: ky,\n          formatter\n        })) {\n          return _;\n        }\n        let substitution = getSubstitution({key: ky, arg, substs});\n\n        substitution = checkLocalVars({\n          substitution, ky, arg, processSubsts: replace\n        });\n\n        returnsDOM = returnsDOM ||\n          (substitution && typeof substitution === 'object' &&\n          'nodeType' in substitution);\n        usedKeys.push(ky);\n        return esc + substitution;\n      });\n    };\n    const ret = replace({str: string});\n    if (!returnsDOM) {\n      checkExtraSuppliedFormatters({substitutions});\n      usedKeys.length = 0;\n      return unescapeBackslashes(ret);\n    }\n    usedKeys.length = 0;\n  }\n\n  recursiveLocalCount = 1;\n  const processSubstitutions = ({\n    str, substs = substitutions, formatter = regularFormatter\n  }) => {\n    const nodes = [];\n\n    // Copy to ensure we are resetting index on each instance (manually\n    // resetting on `formattingRegex` is problematic with recursion that\n    // uses the same regex copy)\n    const regex = new RegExp(formattingRegex, 'gu');\n\n    const push = (...args) => {\n      nodes.push(...args);\n    };\n\n    processRegex(regex, str, {\n      extra: push,\n      onMatch (_, esc, ky, pipe, arg) {\n        if (missingSuppliedFormatters({\n          key: ky, formatter\n        })) {\n          push(_);\n        } else {\n          if (esc.length) {\n            push(esc);\n          }\n\n          let substitution = getSubstitution({key: ky, arg, substs});\n          substitution = checkLocalVars({\n            substitution, ky, arg, processSubsts: processSubstitutions\n          });\n          if (Array.isArray(substitution)) {\n            push(...substitution);\n          } else if (\n            // Clone so that multiple instances may be added (and no\n            // side effects to user code)\n            substitution && typeof substitution === 'object' &&\n            'nodeType' in substitution\n          ) {\n            push(substitution.cloneNode(true));\n          } else {\n            push(substitution);\n          }\n        }\n        usedKeys.push(ky);\n      }\n    });\n    return nodes;\n  };\n  const nodes = processSubstitutions({str: string});\n\n  checkExtraSuppliedFormatters({substitutions});\n  usedKeys.length = 0;\n  return nodes.map((node) => {\n    if (typeof node === 'string') {\n      return unescapeBackslashes(node);\n    }\n    return node;\n  });\n};\n","import {unescapeBackslashes, processRegex} from './utils.js';\n\n/**\n* @typedef {LocaleBody} LocalObject\n*/\n\n/**\n * May also contain language code and direction, translator name and\n * contact, etc., but no defaults currently apply besides reserving `locals`\n * @typedef {PlainObject} LocaleHead\n * @property {LocalObject} locals\n*/\n\n/**\n* @typedef {LocaleStringBodyObject|PlainLocaleStringBodyObject|PlainObject}\n* LocaleBody\n*/\n\n/**\n* @typedef {PlainObject} LocaleObject\n* @property {LocaleHead} [head]\n* @property {LocaleBody} body\n*/\n\n/**\n* @typedef {PlainObject} MessageStyleCallbackResult\n* @property {string} value Regardless of message style, will contain the\n*   string result\n* @property {LocaleStringSubObject} [info] Full info on the localized item\n*   (for rich message styles only)\n*/\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|MessageStyleCallbackResult} If `false`, will resort to default\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  /* eslint-enable max-len */\n  messageStyle = 'richNested'\n} = {}) => {\n  // Todo: Support `plainNested` style\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'richNested'\n      ? (mainObj, key) => {\n        const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n        const keys = [];\n        // eslint-disable-next-line prefer-named-capture-group\n        const possiblyEscapedCharPattern = /(\\\\*)\\./gu;\n        const mergeWithPreviousOrStart = (val) => {\n          if (!keys.length) {\n            keys[0] = '';\n          }\n          keys[keys.length - 1] += val;\n        };\n        processRegex(possiblyEscapedCharPattern, key, {\n          // If odd, this is just an escaped dot, so merge content with\n          //   any previous\n          extra: mergeWithPreviousOrStart,\n          onMatch (_, esc) {\n            // If even, there are no backslashes, or they are just escaped\n            //  backslashes and not an escaped dot, so start anew, though\n            //  first merge any backslashes\n            mergeWithPreviousOrStart(esc);\n            keys.push('');\n          }\n        });\n        const keysUnescaped = keys.map((ky) => {\n          return unescapeBackslashes(ky);\n        });\n\n        let ret = false;\n        let currObj = obj;\n        keysUnescaped.some((ky, i, kys) => {\n          if (!currObj || typeof currObj !== 'object') {\n            return true;\n          }\n          if (\n            // If specified key is too deep, we should fail\n            i === kys.length - 1 &&\n            ky in currObj && currObj[ky] && typeof currObj[ky] === 'object' &&\n            'message' in currObj[ky] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof currObj[ky].message === 'string'\n          ) {\n            ret = {\n              value: currObj[ky].message,\n              info: currObj[ky]\n            };\n          }\n          currObj = currObj[ky];\n\n          return false;\n        });\n        return ret;\n      }\n      : (messageStyle === 'rich'\n        ? (mainObj, key) => {\n          const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n          if (\n            obj && typeof obj === 'object' &&\n            key in obj && obj[key] && typeof obj[key] === 'object' &&\n            'message' in obj[key] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof obj[key].message === 'string'\n          ) {\n            return {\n              value: obj[key].message,\n              info: obj[key]\n            };\n          }\n          return false;\n        }\n        : (messageStyle === 'plain'\n          ? (mainObj, key) => {\n            const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n            if (\n              obj && typeof obj === 'object' &&\n              key in obj && obj[key] && typeof obj[key] === 'string'\n            ) {\n              return {\n                value: obj[key]\n              };\n            }\n            return false;\n          }\n          : (() => {\n            throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n          })())\n      )\n    );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message] If present, this string will be the return value.\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings; used to find a default if no string `message` is provided.\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n} = {}) => {\n  if (typeof key !== 'string') {\n    throw new TypeError(\n      'An options object with a `key` string is expected on ' +\n      '`getStringFromMessageAndDefaults`'\n    );\n  }\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  let str;\n  if (typeof message === 'string') {\n    str = message;\n  } else if (\n    defaults === false || defaults === undefined || defaults === null\n  ) {\n    str = false;\n  } else if (defaults && typeof defaults === 'object') {\n    str = messageForKey({body: defaults}, key);\n    if (str) {\n      str = str.value;\n    }\n  } else {\n    throw new TypeError(\n      `Default locale strings must resolve to \\`false\\`, ` +\n      `nullish, or an object!`\n    );\n  }\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n","import {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {defaultInsertNodes} from './defaultInsertNodes.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/* eslint-disable max-len */\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {string} cfg.locale The (possibly already resolved) locale for use by\n *   configuring formatters\n * @param {LocalObject} [cfg.locals]\n * @param {LocalObject} [cfg.switches]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions=[defaultAllSubstitutions]]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  /* eslint-enable max-len */\n  string,\n  locale,\n  locals,\n  switches,\n  maximumLocalNestingDepth,\n  allSubstitutions = [\n    defaultAllSubstitutions\n  ],\n  insertNodes = defaultInsertNodes,\n  substitutions = false,\n  dom = false,\n  forceNodeReturn = false,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true\n} = {}) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'An options object with a `string` property set to a string must ' +\n      'be provided for `getDOMForLocaleString`.'\n    );\n  }\n  const stringOrTextNode = (str) => {\n    const _doc = getDocument();\n    return forceNodeReturn ? _doc.createTextNode(str) : str;\n  };\n\n  const usedKeys = [];\n\n  /**\n  * @callback CheckExtraSuppliedFormattersCallback\n  * @param {SubstitutionObject} substs\n  * @throws {Error} Upon an extra formatting key being found\n  * @returns {void}\n  */\n\n  /**\n   * @type {CheckExtraSuppliedFormattersCallback}\n   */\n  const checkExtraSuppliedFormatters = ({\n    substitutions: substs\n  }) => {\n    if (throwOnExtraSuppliedFormatters) {\n      Object.keys(substs).forEach((key) => {\n        if (!usedKeys.includes(key)) {\n          throw new Error(`Extra formatting key: ${key}`);\n        }\n      });\n    }\n  };\n\n  /**\n  * @callback MissingSuppliedFormattersCallback\n  * @param {string} key\n  * @param {SubstitutionObject} substs\n  * @throws {Error} If missing formatting key\n  * @returns {boolean}\n  */\n  /**\n   * @type {MissingSuppliedFormattersCallback}\n   */\n  const missingSuppliedFormatters = ({\n    key, formatter\n  }) => {\n    const matching = formatter.isMatch(key);\n    if (formatter.constructor.isMatchingKey(key) && !matching) {\n      if (throwOnMissingSuppliedFormatters) {\n        throw new Error(`Missing formatting key: ${key}`);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  if (\n    !substitutions && !allSubstitutions &&\n    !throwOnMissingSuppliedFormatters\n  ) {\n    return stringOrTextNode(string);\n  }\n  if (!substitutions) {\n    substitutions = {};\n  }\n\n  const nodes = insertNodes({\n    string, dom, usedKeys, substitutions, allSubstitutions, locale,\n    locals, switches,\n    missingSuppliedFormatters,\n    checkExtraSuppliedFormatters\n  });\n  if (typeof nodes === 'string') {\n    return stringOrTextNode(nodes);\n  }\n\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n\n  return container;\n};\n","/* globals intlDomLocale */\n\nimport {defaultLocaleResolver} from './defaultLocaleResolver.js';\nimport {promiseChainForValues} from './promiseChainForValues.js';\nimport {getFetch} from './shared.js';\n\nexport {setFetch, getFetch} from './shared.js';\n\n/**\n * Takes a locale and returns a new locale to check.\n * @callback LocaleMatcher\n * @param {string} locale The failed locale\n * @throws {Error} If there are no further hyphens left to check\n * @returns {string|Promise<string>} The new locale to check\n*/\n\n/**\n * @type {LocaleMatcher}\n */\nexport const defaultLocaleMatcher = (locale) => {\n  if (!locale.includes('-')) {\n    throw new Error('Locale not available');\n  }\n  // Try without hyphen, i.e., the \"lookup\" algorithm:\n  // See https://tools.ietf.org/html/rfc4647#section-3.4 and\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\n  return locale.replace(/-[^-]*$/u, '');\n};\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.locale\n * @param {string[]} cfg.locales\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleMatcher]\n * @returns {string|false}\n */\nexport const getMatchingLocale = ({\n  locale, locales, localeResolver = defaultLocaleMatcher\n}) => {\n  try {\n    while (!locales.includes(locale)) {\n      // Catch as `defaultLocaleMatcher` will throw if no hyphen found\n      locale = localeResolver(locale);\n    }\n  } catch (err) {\n    return false;\n  }\n  return locale;\n};\n\n/**\n* @typedef {PlainObject} LocaleObjectInfo\n* @property {LocaleObject} strings The successfully retrieved locale strings\n* @property {string} locale The successfully resolved locale\n*/\n\n/**\n * @callback LocaleStringFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<LocaleObjectInfo>}\n */\n\n/**\n *\n * @type {LocaleStringFinder}\n */\nexport const findLocaleStrings = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n};\n\n/**\n * @callback LocaleFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<string>} Resolves to the successfully resolved locale\n */\n\n/**\n *\n * @type {LocaleFinder}\n */\nexport const findLocale = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher,\n    headOnly: true\n  });\n};\n\n/**\n * @type {LocaleStringFinder|LocaleFinder} Also has a `headOnly` boolean\n *  property to determine whether to make a simple HEAD and resolve to\n *  the locale rather than locale and contents\n */\nconst _findLocale = async ({\n  locales = typeof intlDomLocale !== 'undefined'\n    ? [intlDomLocale]\n    : typeof navigator === 'undefined' ? [] : navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.',\n  localeMatcher = 'lookup',\n  headOnly = false\n}) => {\n  /**\n   * @callback getLocale\n   * @throws {SyntaxError|TypeError|Error}\n   * @param {string} locale\n   * @returns {Promise<LocaleObjectInfo>}\n   */\n  async function getLocale (locale) {\n    if (typeof locale !== 'string') {\n      throw new TypeError('Non-string locale type');\n    }\n    const url = localeResolver(localesBasePath, locale);\n    if (typeof url !== 'string') {\n      throw new TypeError(\n        '`localeResolver` expected to resolve to (URL) string.'\n      );\n    }\n    try {\n      const _fetch = getFetch();\n      const resp = await (headOnly\n        ? _fetch(url, {\n          method: 'HEAD'\n        })\n        : _fetch(url)\n      );\n\n      if (resp.status === 404) {\n        // Don't allow browser (tested in Firefox) to continue\n        //  and give `SyntaxError` with missing file or we won't be\n        //  able to try without the hyphen\n        throw new Error('Trying again');\n      }\n      if (headOnly) {\n        return locale;\n      }\n      const strings = await (resp.json());\n      return {\n        locale,\n        strings\n      };\n    } catch (err) {\n      if (err.name === 'SyntaxError') {\n        throw err;\n      }\n      const newLocale = await localeMatcher(locale);\n      return getLocale(newLocale);\n    }\n  }\n  if (localeMatcher === 'lookup') {\n    localeMatcher = defaultLocaleMatcher;\n  } else if (typeof localeMatcher !== 'function') {\n    throw new TypeError('`localeMatcher` must be \"lookup\" or a function!');\n  }\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    getLocale,\n    'No matching locale found!'\n  );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\nimport {findLocaleStrings} from './findLocaleStrings.js';\nimport {getDOMForLocaleString} from './getDOMForLocaleString.js';\nimport {\n  getStringFromMessageAndDefaults\n} from './getStringFromMessageAndDefaults.js';\nimport {sort, sortList, list} from './collation.js';\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present.\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {LocaleObject} cfg.strings\n * @param {string} cfg.resolvedLocale\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18nServer = function i18nServer ({\n  /* eslint-enable max-len */\n  strings,\n  resolvedLocale,\n  messageStyle,\n  allSubstitutions: defaultAllSubstitutionsValue,\n  insertNodes,\n  defaults: defaultDefaults,\n  substitutions: defaultSubstitutions,\n  maximumLocalNestingDepth,\n  dom: domDefaults = false,\n  forceNodeReturn: forceNodeReturnDefault = false,\n  throwOnMissingSuppliedFormatters:\n    throwOnMissingSuppliedFormattersDefault = true,\n  throwOnExtraSuppliedFormatters:\n    throwOnExtraSuppliedFormattersDefault = true\n}) {\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const formatter = (key, substitutions, {\n    allSubstitutions = defaultAllSubstitutionsValue,\n    defaults = defaultDefaults,\n    dom = domDefaults,\n    forceNodeReturn = forceNodeReturnDefault,\n    throwOnMissingSuppliedFormatters = throwOnMissingSuppliedFormattersDefault,\n    throwOnExtraSuppliedFormatters = throwOnExtraSuppliedFormattersDefault\n  } = {}) => {\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message: (message && message.value) || false,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      locals: strings.head && strings.head.locals,\n      switches: strings.head && strings.head.switches,\n      locale: resolvedLocale,\n      maximumLocalNestingDepth,\n      allSubstitutions,\n      insertNodes,\n      substitutions: {...defaultSubstitutions, ...substitutions},\n      dom,\n      forceNodeReturn,\n      throwOnMissingSuppliedFormatters,\n      throwOnExtraSuppliedFormatters\n    });\n  };\n\n  formatter.resolvedLocale = resolvedLocale;\n  formatter.strings = strings;\n\n  formatter.sort = (...args) => {\n    return sort(resolvedLocale, ...args);\n  };\n\n  formatter.sortList = (...args) => {\n    return sortList(\n      resolvedLocale, ...args\n    );\n  };\n\n  formatter.list = (...args) => {\n    return list(\n      resolvedLocale, ...args\n    );\n  };\n\n  return formatter;\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {LocaleStringFinder} [cfg.localeStringFinder=findLocaleStrings]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher=\"lookup\"]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localeStringFinder = findLocaleStrings,\n  localesBasePath,\n  localeResolver,\n  localeMatcher,\n  messageStyle,\n  allSubstitutions,\n  insertNodes,\n  defaults,\n  substitutions,\n  maximumLocalNestingDepth,\n  dom,\n  forceNodeReturn,\n  throwOnMissingSuppliedFormatters,\n  throwOnExtraSuppliedFormatters\n} = {}) {\n  const {strings, locale: resolvedLocale} = await localeStringFinder({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n\n  return i18nServer({\n    strings,\n    resolvedLocale,\n    messageStyle,\n    allSubstitutions,\n    insertNodes,\n    defaults,\n    substitutions,\n    maximumLocalNestingDepth,\n    dom,\n    forceNodeReturn,\n    throwOnMissingSuppliedFormatters,\n    throwOnExtraSuppliedFormatters\n  });\n};\n"],"names":["basedir","module","lib","exports","WORD_POS_END","contexts","getContext","pop","context","elements","element_array","dropContext","ctx","push","buffers","dropBuffer","buf","JSON6","escape","string","output","n","length","begin","cb","reviver","val","name","value_type","contains","pos","line","col","word","status","negative","result","parse_context","comment","fromHex","decimal","exponent","exponent_sign","exponent_digit","gatheringStringFirstChar","gatheringString","gatheringNumber","stringEscape","cr_escaped","unicodeWide","stringUnicode","stringHex","hex_char","hex_char_len","completed","context_stack","first","last","saved","node","recover","this","next","prior","inQueue","shift","unshift","throwEndError","leader","Error","finalError","console","log","value","r","undefined","reset","save","write","msg","retcode","String","_write","walk","holder","key","k","Object","prototype","hasOwnProperty","call","v","complete_at_end","input","retval","throwError","c","fromCodePoint","substr","RESET_VAL","arrayPush","Number","NaN","Infinity","objectPush","gatherString","start_c","str","charAt","cInt","codePointAt","collectNumber","_n","getBuffer","old_context","tmpobj","tmparr","_parser","freeze","_parse_level","parse","parse_level","parser","stringify","JSON","fn","path","require","base","commonjsRequire","unescapeBackslashes","replace","esc","slice","parseJSONExtra","args","jsonExtra","processRegex","regex","match","onMatch","extra","betweenMatches","afterMatch","escapeAtOne","previousIndex","exec","_","lastIndex","startMatchPos","_fetch","fetch","setFetch","f","getFetch","_doc","document","setDocument","doc","getDocument","sort","locale","arrayOfItems","options","Intl","Collator","compare","list","ListFormat","format","sortList","map","listOptions","collationOptions","sortListSimple","d","randomId","Date","now","performance","Math","trunc","random","floor","toString","placeholderArray","_toConsumableArray","i","nodes","RegExp","idx","container","createDocumentFragment","append","getFormatterInfo","object","Array","isArray","callback","extraOpts","defaultAllSubstitutions","opts","arg","_typeof","applyArgs","type","checkArgOptions","split","userType","extraArgs","argOptions","singleKey","keys","includes","RelativeTimeFormat","NumberFormat","getTime","DateTimeFormat","TypeError","Formatter","getSubstitution","body","messageStyle","substitution","getMessageForKeyByStyle","messageForKey","LocalFormatter","locals","components","parent","constructor","isMatchingKey","every","cmpt","startsWith","RegularFormatter","substitutions","test","SwitchFormatter","switches","usedKeys","missingSuppliedFormatters","ky","getKey","getMatch","objKey","keySegment","formatter","getNumberFormat","defaultOptions","numberOpts","getPluralFormat","pluralOpts","PluralRules","select","formatterValue","toUpperCase","toLowerCase","preventNesting","s","err","error","find","switchKey","Boolean","ks","reduce","obj","ret","entries","_this4","concat","then","direct","Promise","resolve","e","pact","state","o","_settle","bind","observer","_Pact","onFulfilled","onRejected","_this","thenable","update","stage","shouldContinue","_isSettledPact","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","arguments","apply","promiseChainForValues","values","errBack","errorMessage","_async","breaking","p","defaultLocaleResolver","localesBasePath","defaultInsertNodes","dom","allSubstitutions","maximumLocalNestingDepth","checkExtraSuppliedFormatters","localFormatter","regularFormatter","switchFormatter","formattingRegex","substs","subst","allSubst","recursiveLocalCount","checkLocalVars","processSubsts","localFormatters","extraSubsts","returnsDOM","pipe","processSubstitutions","cloneNode","mainObj","mergeWithPreviousOrStart","keysUnescaped","currObj","some","kys","message","info","getStringFromMessageAndDefaults","defaults","getDOMForLocaleString","insertNodes","forceNodeReturn","throwOnMissingSuppliedFormatters","throwOnExtraSuppliedFormatters","stringOrTextNode","createTextNode","forEach","matching","isMatch","defaultLocaleMatcher","getMatchingLocale","locales","localeResolver","findLocaleStrings","defaultLocales","localeMatcher","_findLocale","findLocale","headOnly","getLocale","url","method","resp","json","strings","intlDomLocale","navigator","languages","i18nServer","resolvedLocale","defaultAllSubstitutionsValue","defaultDefaults","defaultSubstitutions","domDefaults","forceNodeReturnDefault","throwOnMissingSuppliedFormattersDefault","throwOnExtraSuppliedFormattersDefault","head","i18n","localeStringFinder"],"mappings":"mhHAcA,IAdkCA,EAASC,EAihDvCC,GAngD6B,SAAUD,EAAQE,SAgD3CC,EAAe,GAMfC,EAAW,YAERC,WACAD,EAASE,OAAS,CACvBC,QAToB,EAUpBC,SAAU,KACVC,cAAe,eAIVC,EAAYC,GACnBP,EAASQ,KAAKD,SAGVE,EAAU,YAWPC,EAAWC,GAClBF,EAAQD,KAAKG,SAGTC,EAASd,EAqBfc,EAAMC,OAAS,SAAUC,OACnBC,EAAS,OACRD,EAAQ,OAAOA,MAEf,IAAIE,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAChB,KAAbF,EAAOE,IAA0B,MAAbF,EAAOE,IAA2B,KAAbF,EAAOE,IAA0B,KAAbF,EAAOE,KACtED,GAAU,MAGZA,GAAUD,EAAOE,UAGZD,GAGTH,EAAMM,MAAQ,SAAUC,EAAIC,SACpBC,EAAM,CACVC,KAAM,KAENC,WAxHgB,EA0HhBT,OAAQ,GAERU,SAAU,MAENC,EAAM,CACVC,KAAM,EACNC,IAAK,OAOHvB,EALAY,EAAI,EACJY,EApHiB,EAqHjBC,GAAS,EACTC,GAAW,EACXC,EAAS,KAET1B,EAAgB,GAChB2B,EA3FkB,EA4FlBC,EAAU,EACVC,GAAU,EACVC,GAAU,EACVC,GAAW,EACXC,GAAgB,EAChBC,GAAiB,EACjBC,EAA2B,KAC3BC,GAAkB,EAClBC,GAAkB,EAClBC,GAAe,EACfC,GAAa,EACbC,GAAc,EACdC,GAAgB,EAChBC,GAAY,EACZC,EAAW,EACXC,EAAe,EACfC,GAAY,QACVC,EAAgB,CACpBC,MAAO,KACPC,KAAM,KACNC,MAAO,KAEP7C,KAAK8C,OACCC,EAAUC,KAAKH,MAEfE,QACGF,MAAQE,EAAQE,KACrBF,EAAQD,KAAOA,EACfC,EAAQE,KAAO,KACfF,EAAQG,MAAQF,KAAKJ,MAErBG,EAAU,CACRD,KAAMA,EACNG,KAAM,KACNC,MAAOF,KAAKJ,MAIXI,KAAKJ,OAAMI,KAAKL,MAAQI,QACxBH,KAAOG,GAGdrD,YACQ6B,EAASyB,KAAKJ,YACdI,KAAKJ,KAAOrB,EAAO2B,SAAQF,KAAKL,MAAQ,MAC9CpB,EAAO0B,KAAOD,KAAKH,WACdA,MAAQtB,EACNA,EAAOuB,OAIZK,EAAU,CACdR,MAAO,KACPC,KAAM,KACNC,MAAO,KAEP7C,KAAK8C,OACCC,EAAUC,KAAKH,MAEfE,QACGF,MAAQE,EAAQE,KACrBF,EAAQD,KAAOA,EACfC,EAAQE,KAAO,KACfF,EAAQG,MAAQF,KAAKJ,MAErBG,EAAU,CACRD,KAAMA,EACNG,KAAM,KACNC,MAAOF,KAAKJ,MAIXI,KAAKJ,KAAgCI,KAAKJ,KAAKK,KAAOF,EAA3CC,KAAKL,MAAQI,OACxBH,KAAOG,GAGdK,cACQ7B,EAASyB,KAAKL,aACfpB,QACAoB,MAAQpB,EAAO0B,KACfD,KAAKL,QAAOK,KAAKJ,KAAO,MAC7BrB,EAAO0B,KAAOD,KAAKH,WACdA,MAAQtB,EAENA,EAAOuB,MANM,MAStBO,QAAQP,SAEAC,EAAUC,KAAKH,WAEhBA,MAAQE,EAAQE,KACrBF,EAAQD,KAAOA,EACfC,EAAQE,KAAOD,KAAKL,MACpBI,EAAQG,MAAQ,KAEXF,KAAKL,QAAOK,KAAKJ,KAAOG,QACxBJ,MAAQI,aAKRO,EAAcC,SAGf,IAAIC,MAAO,GAAED,QAAa/C,MAAMS,EAAIC,QAAQD,EAAIE,cAGjD,CACLsC,gBACkB,IAAZhC,SAEMA,QACD,SACI6B,EAAc,yCAElB,EACHI,QAAQC,IAAI,uEAGT,SACIL,EAAc,8DAElB,SACIA,EAAc,8CAIvBtB,GAAiBsB,EAAc,sBAGrCM,aACOH,mBACCI,EAAItC,SACVA,OAASuC,EACFD,GAGTE,QACE3C,EAtQiB,EAuQjBC,GAAS,EACL8B,EAAQP,OAAMO,EAAQP,KAAKK,KAAOE,EAAQa,MAC9Cb,EAAQa,KAAOb,EAAQR,MACvBQ,EAAQR,MAAQQ,EAAQP,KAAO,KAC3BF,EAAcE,OAAMF,EAAcE,KAAKK,KAAOP,EAAcsB,MAChEtB,EAAcsB,KAAOb,EAAQR,MAC7BD,EAAcC,MAAQD,EAAcE,KAAO,KAE3C/C,EAAgB,KAChBD,OAAWkE,EACXtC,EAlPkB,EAmPlBX,EAAIE,WAjSU,EAkSdF,EAAIC,KAAO,KACXD,EAAIP,OAAS,GACbW,EAAIC,KAAO,EACXD,EAAIE,IAAM,EACVG,GAAW,EACXG,EAAU,EACVgB,GAAY,EACZT,GAAkB,EAClBE,GAAe,EAEfC,GAAa,GAMf8B,MAAMC,OACAC,UACQL,IAARI,GAAoC,iBAARA,IAAkBA,EAAME,OAAOF,KAC1D7C,EAAQ,MAAM,IAAImC,MAAM,kDAExBW,EAAUnB,KAAKqB,OAAOH,GAAK,GAAQC,EAAU,SAC3CV,aACkB,mBAAZ7C,GAAwB,SAAU0D,EAAKC,EAAQC,SAClDZ,EAAQW,EAAOC,MAEjBZ,GAA0B,iBAAVA,MACb,MAAMa,KAAKb,KACVc,OAAOC,UAAUC,eAAeC,KAAKjB,EAAOa,GAAI,OAC5CK,EAAIR,EAAKV,EAAOa,QAEZX,IAANgB,EACFlB,EAAMa,GAAKK,SAEJlB,EAAMa,UAMd7D,EAAQiE,KAAKN,EAAQC,EAAKZ,GAjBA,CAkBhC,IACGrC,GACH,IACHZ,EAAGY,GACHA,OAASuC,IACLK,EAAU,IAzBqCA,EAAUnB,KAAKqB,UA4BhEF,GAASnB,KAAKS,cAGpBY,OAAOH,EAAKa,OACNC,EACA7E,EACA8E,EAAS,WAEJC,EAAW3B,EAAQ4B,SACpB,IAAI3B,MAAO,GAAED,MAAWa,OAAOgB,cAAcD,qBAAqB3E,YAAYL,EAAIkF,OAAO7E,EAAI,EAAIA,EAAI,EAAI,EAAGA,EAAI,EAAI,EAAIA,EAAI,MAAM4D,OAAOgB,cAAcD,MAAMhF,EAAIkF,OAAO7E,EAAG,UAAUS,EAAIC,QAAQD,EAAIE,iBAGpMmE,IACPzE,EAAIE,WAhWQ,EAiWZF,EAAIP,OAAS,YAGNiF,WACC1E,EAAIE,iBAhWC,EAkWTlB,EAAcG,MAAMsB,GAAY,EAAI,GAAKkE,OAAO3E,EAAIP,oBAnW3C,EAuWTT,EAAcG,KAAKa,EAAIP,mBAzWhB,EA6WPT,EAAcG,MAAK,cA5WX,EAgXRH,EAAcG,MAAK,cA3WT,OACJ,EAkXNH,EAAcG,KAAKyF,gBAjXJ,GAqXf5F,EAAcG,MAAK,EAAA,cApXR,GAwXXH,EAAcG,KAAK0F,EAAAA,cAlYZ,EAsYP7F,EAAcG,KAAK,iBAxYP,EA4YZH,EAAcG,UAAK8D,cA9XX,GAkYRjE,EAAcG,UAAK8D,UACZjE,EAAcA,EAAcY,OAAS,cA1YnC,OACD,EAiZRZ,EAAcG,KAAKa,EAAIG,oBAKpB2E,WACC9E,EAAIE,iBAzZC,EA2ZTnB,EAASiB,EAAIC,OAASQ,GAAY,EAAI,GAAKkE,OAAO3E,EAAIP,mBA5Z7C,EAgaTV,EAASiB,EAAIC,MAAQD,EAAIP,kBAlalB,EAsaPV,EAASiB,EAAIC,OAAQ,aArab,EAyaRlB,EAASiB,EAAIC,OAAQ,aApaX,OACJ,EA2aNlB,EAASiB,EAAIC,MAAQ2E,eA1aN,GA8af7F,EAASiB,EAAIC,OAAQ,EAAA,aA7aV,GAibXlB,EAASiB,EAAIC,MAAQ4E,EAAAA,aA3bd,EA+bP9F,EAASiB,EAAIC,MAAQ,gBAjcT,EAqcZlB,EAASiB,EAAIC,WAAQgD,aA9bZ,OACD,EAqcRlE,EAASiB,EAAIC,MAAQD,EAAIG,mBAKtB4E,EAAaC,OAChBZ,EAAS,OAEI,GAAVA,GAAezE,EAAIL,EAAIM,QAAQ,KAChCqF,EAAM3F,EAAI4F,OAAOvF,SACfwF,EAAO7F,EAAI8F,YAAYzF,QAEzBwF,GAAQ,QACVF,GAAO3F,EAAI4F,OAAOvF,GAClBA,KAIFS,EAAIE,MAEA6E,GAAQH,EAEN3D,GACEI,EAAW4C,EAAW,kCAAmCc,GAAe5D,EAAa8C,EAAW,mCAAoCc,GAAe3D,GAAe6C,EAAW,8BAA+Bc,GAE5M7D,GACFA,GAAa,EAEb8C,EAAS,GACJpE,EAAIP,QAAUwF,EAGrB5D,GAAe,GAGf+C,EAAS,OAEN,GAAI/C,EAAc,IACnBE,EAAa,IACH,KAAR4D,EAEF,CACEnF,EAAIP,QAAU8D,OAAOgB,cAAc7C,GACnCH,GAAc,EACdC,GAAgB,EAChBH,GAAe,WAInBK,GAAY,GACRyD,GAAQ,IAETA,GAAQ,GAETzD,GAAYyD,EAAO,GAAcA,GAAQ,IAExCA,GAAQ,GAETzD,GAAYyD,EAAO,GAAK,GAAYA,GAAQ,IAE3CA,GAAQ,IAETzD,GAAYyD,EAAO,GAAK,GACxBd,EAAW,0CAA2Cc,YAGnD,GAAI1D,GAAaD,EAAe,IAChB,IAAjBG,GAA+B,MAATwD,EAExB,CACE5D,GAAc,WAIlBG,GAAY,GACRyD,GAAQ,IAETA,GAAQ,GAETzD,GAAYyD,EAAO,GAAcA,GAAQ,IAExCA,GAAQ,GAETzD,GAAYyD,EAAO,GAAK,GAAYA,GAAQ,IAE3CA,GAAQ,IAETzD,GAAYyD,EAAO,GAAK,GACxBd,EAAW7C,EAAgB,0CAA4C,0CAA2C2D,GAEpHxD,IAEIH,EACkB,GAAhBG,IACF3B,EAAIP,QAAU8D,OAAOgB,cAAc7C,GACnCF,GAAgB,EAChBH,GAAe,GAEQ,GAAhBM,IACT3B,EAAIP,QAAU8D,OAAOgB,cAAc7C,GACnCD,GAAY,EACZJ,GAAe,mBAMX8D,QACD,GAGH7D,GAAa,EACblB,EAAIE,IAAM,gBAGP,UAEA,KAEHF,EAAIE,IAAM,OAIP,GAGCgB,EAEFA,GAAa,EAGblB,EAAIE,IAAM,EAGZF,EAAIC,kBAGD,IAGHL,EAAIP,QAAU,gBAGX,GAGHO,EAAIP,QAAU,gBAGX,GAGHO,EAAIP,QAAU,gBAGX,IAGHO,EAAIP,QAAU,gBAGX,IAGHO,EAAIP,QAAU,gBAGX,IAGHO,EAAIP,QAAU,gBAGX,IAGHgC,GAAY,EACZE,EAAe,EACfD,EAAW,gBAGR,IAGHF,GAAgB,EAChBG,EAAe,EACfD,EAAW,mBAIX1B,EAAIP,QAAUwF,EAKlB5D,GAAe,OACG,KAAT8D,EAGP9D,GAAe,GAEbC,IACFA,GAAa,EAEblB,EAAIC,OACJD,EAAIE,IAAM,GAGZN,EAAIP,QAAUwF,UAIXb,WAGAiB,QACHC,QAEIA,EAAK3F,GAAKL,EAAIM,QAAQ,OACtBqF,EAAM3F,EAAI4F,OAAOI,GACjBH,EAAO7F,EAAI8F,YAAYzF,QAEzBwF,GAAQ,OACVd,EAAW,8BAA+Bc,GAIhC,IAARA,KAGJ/E,EAAIE,MAEA6E,GAAQ,IAETA,GAAQ,GAGHpE,IACFE,GAAiB,GAGnBjB,EAAIP,QAAUwF,OACT,GAAY,IAARE,GAEF,IAARA,EAG0B,GAArBnF,EAAIP,OAAOG,QAAemB,IAAaC,IAAkBC,GAC3DjB,EAAIP,QAAUwF,EACdjE,GAAgB,IAEhBR,GAAS,EACT6D,EAAW,8BAA+Bc,SAEvC,GAAY,IAARA,EAGJrE,GAAYD,GAAYE,GAI3BP,GAAS,EACT6D,EAAW,8BAA+Bc,KAJ1CnF,EAAIP,QAAUwF,EACdnE,GAAU,QAKP,GAAY,KAARqE,GAEF,IAARA,GAEQ,KAARA,GAEQ,IAARA,GAEQ,IAARA,GAEQ,IAARA,EAIMtE,GAAyB,KAAdb,EAAIP,QAIlBe,GAAS,EACT6D,EAAW,8BAA+Bc,KAJ1CtE,GAAU,EACVb,EAAIP,QAAUwF,OAKX,CAAA,GAAY,KAARE,GAEF,IAARA,EAUI,IACO,IAARA,GAEO,KAARA,GAEQ,IAARA,GAAsB,IAARA,GAAsB,GAARA,GAAqB,OAARA,GAA0B,IAARA,GAEnD,KAARA,GAEQ,IAARA,GAEQ,IAARA,QAKGjB,IACF1D,GAAS,EACT6D,EAAW,8BAA+Bc,UAzBzCpE,GAIHP,GAAS,EACT6D,EAAW,8BAA+Bc,KAJ1CnF,EAAIP,QAAUwF,EACdlE,GAAW,IA+BjBpB,EAAI2F,EAECpB,GAAmBvE,GAAKL,EAAIM,QAG/BwB,GAAkB,EAClBpB,EAAIE,WAhxBO,EAyCG,GAyuBVS,IACFiB,GAAY,IANdR,GAAkB,MAWjBZ,EAAQ,OAAQ,KAEjB6C,GAAOA,EAAIzD,OACbuE,iBA5tBF7E,EAAMF,EAAQP,aACbS,EAGEA,EAAIK,EAAI,EAHLL,EAAM,CACdA,IAAK,KACLK,EAAG,GAEEL,EAutBOiG,GACRpB,EAAM7E,IAAM+D,EACZf,EAAQnD,KAAKgF,WAET/C,EAAiB,IAEnBA,GAAkB,EAClBpB,EAAIE,WAlyBO,EAyCG,GA2vBVS,QAGI,IAAIgC,MAAM,uCAFhBf,GAAY,EAKdwC,EAAS,OAIN5D,IAAW2D,EAAQ7B,EAAQC,UAAU,KAC1C5C,EAAIwE,EAAMxE,EACVL,EAAM6E,EAAM7E,IAER6B,GACoB4D,EAAa7D,GAEf,IAClBC,GAAkB,EAClBnB,EAAIE,WAxzBK,GA4zBTkB,GACFiE,KAGMzD,GAAapB,GAAUb,EAAIL,EAAIM,QAAQ,KACzCqF,EAAM3F,EAAI4F,OAAOvF,SACfwF,EAAO7F,EAAI8F,YAAYzF,QAEzBwF,GAAQ,QACVF,GAAO3F,EAAI4F,OAAOvF,GAClBA,KAKFS,EAAIE,MAEAM,EAEa,GAAXA,EAEU,IAARuE,EAGAvE,EAAU,EAEG,IAARuE,EAIHd,EAAW,uBAAwBc,GAC9BvE,EAAU,EAED,GAAXA,EAEG,IAARuE,GAEO,IAARA,IAEDvE,EAAU,GACQ,GAAXA,EAEG,IAARuE,IAEFvE,EAAU,GAKVA,EAFU,IAARuE,EAEQ,EAAiB,cAMzBA,QACD,GAGHvE,EAAU,aAGP,KAn1BM,IAs1BLL,GAr1BW,IAq1BeA,GAh1Bf,GAg1B+CI,GAl3BrD,GAk3B8FJ,IACrG8D,EAAW,sDAAuDc,UAI5DK,EAAc5G,IAEpBoB,EAAIE,WAl4BC,QAm4BCuF,EAAS,GA31BP,GA41BJ9E,IAAkCD,EAAS3B,EAAW0G,GAC1DD,EAAY1G,QAAU6B,EACtB6E,EAAYzG,SAAWA,EACvByG,EAAYxG,cAAgBA,EAC5BwG,EAAYvF,KAAOD,EAAIC,KACvBlB,EAAW0G,EAEX5D,EAAc1C,KAAKqG,GACnBf,IACA9D,EAl2Ba,aAs2BZ,MAt2BY,GAy2BXA,GA/2BK,IA+2BoCJ,GA92B9B,IA82BwDA,GACrE8D,EAAW,2DAA4Dc,GA35BnE,GA85BFnF,EAAIE,aA/5BE,GA+5B2BF,EAAIE,WAA+B,OAChEsF,EAAc5G,IAEpBoB,EAAIE,WA15BA,QA25BEwF,EAAS,GAp3BP,GAq3BJ/E,EAAkCD,EAAS1B,EAAgB0G,EAj3B5C,GAm3BV/E,IAA6C5B,EAASiB,EAAIC,MAAQyF,GAC3EF,EAAY1G,QAAU6B,EACtB6E,EAAYzG,SAAWA,EACvByG,EAAYxG,cAAgBA,EAC5BwG,EAAYvF,KAAOD,EAAIC,KACvBjB,EAAgB0G,EAEhB7D,EAAc1C,KAAKqG,GACnBf,IACA9D,EA/3BS,OAi4BT0D,EAAW,6CAA8Cc,cAKxD,GAp4BY,GAw4BXxE,GACFJ,EA36BO,EA46BPP,EAAIC,KAAOD,EAAIP,OACfO,EAAIP,OAAS,GACbkB,EA34BmB,EA44BnBX,EAAIE,WA97BA,GAg8BmCmE,EAj5B9B,GAi5BL1D,EAA8C,qDAA4E,+DAAtBwE,cAKvG,OAIC5E,GAAQ7B,IAEV6B,EA57BO,GAkCM,GA85BXI,EAAuC,CAGzCX,EAAIE,WA58BC,EA68BLF,EAAIG,SAAWpB,QACTyG,EAAc3D,EAAchD,MAElCmB,EAAIC,KAAOuF,EAAYvF,KACvBU,EAAgB6E,EAAY1G,QAE5BC,EAAWyG,EAAYzG,SACvBC,EAAgBwG,EAAYxG,cAC5BC,EAAYuG,GA76BJ,GA+6BJ7E,IACFiB,GAAY,QAET,GA96Bc,GA86BVjB,EAA6C,CAh+BlD,GAm+BAX,EAAIE,WACN4E,IAEAT,EAAW,uDAAwDc,GAGrEnF,EAAIE,WAn+BC,EAo+BLF,EAAIG,SAAWpB,QACTyG,EAAc3D,EAAchD,MAElCmB,EAAIC,KAAOuF,EAAYvF,KACvBU,EAAgB6E,EAAY1G,QAE5BC,EAAWyG,EAAYzG,SACvBC,EAAgBwG,EAAYxG,cAC5BC,EAAYuG,GAp8BJ,GAs8BJ7E,IACFiB,GAAY,QAGdyC,EAAW,kCAAmCc,GAGhD1E,GAAW,aAGR,MAGCF,GAAQ7B,IAAc6B,EAl/BjB,GAgCE,GAo9BPI,EAAmC,CAngCjC,GAqgCAX,EAAIE,YACNwE,IAGF1E,EAAIE,WAlgCA,EAmgCJF,EAAIG,SAAWnB,SAEPwG,EAAc3D,EAAchD,MAElCmB,EAAIC,KAAOuF,EAAYvF,KACvBU,EAAgB6E,EAAY1G,QAC5BC,EAAWyG,EAAYzG,SACvBC,EAAgBwG,EAAYxG,cAC5BC,EAAYuG,GAp+BN,GAu+BJ7E,IACFiB,GAAY,QAGdyC,EAAY,eAAc1D,yBAAsCwE,GAGlE1E,GAAW,aAGR,GAGCF,GAAQ7B,IAAc6B,EAnhCjB,GAgCE,GAs/BPI,GAriCE,GAsiCAX,EAAIE,aAA2BF,EAAIE,WAzhCnC,IA4hCJwE,IACAD,KAx/BmB,GAy/BV9D,GAGTA,EA7/Ba,EAjDT,GAgjCAX,EAAIE,YACN4E,IACAL,KACKJ,EAAW,2CAA4Cc,KAE9D3E,GAAS,EACT6D,EAAW,+CAAgDc,IAG7D1E,GAAW,mBAxgCI,GA4gCXE,SACMwE,QACD,QAEA,QAEA,GApjCA,GAsjCC5E,GArkCJ,GAskCMP,EAAIE,YAA2BmE,EAAW,oCAAqCc,GAC7DJ,EAAaI,GAGjCnF,EAAIE,WAtkCP,GAwkCGgB,EAA2BiE,EAC3BhE,GAAkB,IAGpBkD,EAAW,wDAAyDc,cAKnE,GAEH/E,EAAIC,OACJD,EAAIE,IAAM,OAGP,QAEA,QAEA,SAEA,OAEA,MAECC,GAAQ7B,EAEV6B,EAxlCC,EA4BA,IA6jCQA,IACTA,EA7jCO,kBAAA,IAokCLA,IACFC,GAAS,EACT6D,EAAW,4CAA6Cc,IAnmCvD,GAsmCC5E,IAAwBA,EA1kCzB,IA2kCHP,EAAIP,QAAUwF,OAIb,OAAQE,QACR,QAEA,QAEA,GA/nCD,IAkoCInF,EAAIE,WACgB6E,EAAaI,IAGjCnF,EAAIE,WAloCP,EAmoCGK,EAAO7B,IAEPwC,EAA2BiE,EAC3BhE,GAAkB,GAEfkD,EAAW,oBAAqBc,cAKtC,GAEH/E,EAAIC,OACJD,EAAIE,IAAM,OAGP,QAEA,SAEA,OAEA,QAEA,SAECC,GAAQ7B,EAAc,CACxB6B,EAnpCG,EA+BC,GAsnCAI,IACFiB,GAAY,SAtpCX,IA4pCDrB,IAEFC,GAAS,EACT6D,EAAW,2BAA4Bc,eAOtC,IAtqCE,GAwqCD5E,EAAwBA,EAvqCtB,EAyBI,IA8oCkDA,EAA6BA,EA7oC/E,IA8oCRC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IA9qCG,GAgrCF5E,EAAyBA,EA/qCvB,GAgrCJC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IAtrCG,GAwrCF5E,EAAyBA,EAvrCvB,EAKA,GAkrCuDA,EAAyBA,EAjrChF,GATD,GA0rCiHA,EAAwBA,EA/qCnI,IAgrCTC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IA9rCG,GAgsCF5E,GACFP,EAAIE,WAjtCL,EAktCCK,EAAO7B,GA9rCF,GA+rCI6B,GACTP,EAAIE,WAntCJ,EAotCAK,EAAO7B,GA3rCE,IA4rCA6B,EAA8BA,EA3rC9B,GAGA,IAwrCmEA,EAA8BA,EAvrCjG,IAwrCTC,GAAS,EACT6D,EAAW,gBAAiBc,eAM3B,IAjtCE,GAmtCD5E,EAAwBA,EA3sCtB,EAGK,IAwsCiDA,EAA8BA,EAvsC/E,GAIA,IAmsCoHA,EAA8BA,EAlsClJ,GAID,IA8rCwLA,EAA6BA,EA7rCrN,GAEA,IA2rCyPA,EAA6BA,EA1rCtR,IA2rCRC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IA9sCQ,IAgtCP5E,EAA8BA,EA/sCvB,GAKA,IA0sC4DA,GACrEP,EAAIE,YA7uCA,EA8uCJK,EAAO7B,IAEP8B,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IAvtCQ,IAytCP5E,EAA8BA,EAxtCvB,GAOD,IAitC6DA,EAA6BA,EAhtC1F,GACA,IA+sC8HA,EAA6BA,EA9sC3J,IA+sCRC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IAtuCG,IAwuCF5E,EAAyBA,EAvuCvB,GAAA,IAuuCuDA,GAC3DP,EAAIE,WAhwCL,EAiwCCK,EAAO7B,GA9uCF,GA+uCI6B,EAA0BA,EA9uC9B,GA+uCLC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IA3vCE,GA6vCD5E,EAAwBA,EAzvCrB,EAUI,IA+uCkDA,EAA8BA,EA9uChF,GAOD,IAuuCsHA,EAA6BA,EAtuCnJ,IAuuCRC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,GAhwCI,GAkwCH5E,EAA0BA,EAjwCvB,EAcF,IAmvC0DA,EAAwBA,EAlvClF,IAmvCHC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IAvwCI,GAywCH5E,EAA0BA,EAxwCvB,GAywCLC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,GAtxCE,GAwxCD5E,EAAwBA,EAnwClB,IAowCRC,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,GA/xCE,GAiyCD5E,EAAwBA,EA9wCvB,GACA,IA6wCsDA,GACzDP,EAAIE,WAAaO,EAzyCf,EACJ,EAyyCEA,GAAW,EACXF,EAAO7B,IAEP8B,GAAS,EACT6D,EAAW,gBAAiBc,eAK3B,IAjxCO,IAmxCN5E,GACFP,EAAIE,WAAaO,EApzCV,GACJ,GAozCHA,GAAW,EACXF,EAAO7B,IAEP8B,GAAS,EACT6D,EAAW,gBAAiBc,eAM3B,GA1zCE,GA4zCD5E,EAAwBE,GAAYA,GACtCD,GAAS,EACT6D,EAAW,gBAAiBc,kBAQ1BA,GAAQ,IAETA,GAAQ,IAEA,IAARA,GAEQ,IAARA,GAEQ,IAARA,GAGDtE,GAAU,EACVE,GAAW,EACXC,GAAgB,EAChBC,GAAiB,EACjBH,GAAU,EACVd,EAAIP,OAASwF,EACbd,EAAMxE,EAAIA,EACV0F,MAEA7E,GAAS,EACT6D,EAAW,gBAAiBc,QAWlCvD,EAAW,CACTrB,GAAQ7B,IACV6B,EAx2CS,cA+2CXZ,GAAKL,EAAIM,QACXP,EAAW8E,GAEPhD,GAAmBC,GAh1CJ,GAg1CuBT,EACxCyD,EAAS,EAp1CG,GAs1CRzD,GAp4CI,GAo4CiCX,EAAIE,aAA6BQ,IACxEkB,GAAY,EACZwC,EAAS,KAKbD,EAAMxE,EAAIA,EACV2C,EAAQE,QAAQ2B,GAChBC,EAAS,GAGPxC,EAAW,SAGbA,GAn5CU,GAm5CG5B,EAAIE,WAA2B,QACtCF,EAAIE,iBA/4CC,EAi5CTQ,GAAUD,GAAY,EAAI,GAAKkE,OAAO3E,EAAIP,mBAl5CjC,EAs5CTiB,EAASV,EAAIP,kBAx5CN,EA45CPiB,GAAS,aA35CD,EA+5CRA,GAAS,aAj6CF,EAq6CPA,EAAS,gBAv6CG,EA26CZA,OAASuC,aAj6CH,OADI,EA06CVvC,EAAS,eAv6CE,GA26CXA,EAASmE,EAAAA,aA56CM,GAg7CfnE,GAAS,EAAA,aAp7CA,OACD,EA67CRA,EAASV,EAAIG,SAIjBM,GAAW,EACXT,EAAIP,OAAS,GACbO,EAAIE,WA18CQ,SA68Cd0B,GAAY,EACLwC,WAMPuB,EAAU,CAAC9B,OAAO+B,OAAOrG,EAAMM,cACjCgG,EAAe,EAEnBtG,EAAMuG,MAAQ,SAAUzC,EAAKtD,SAErBgG,EAAcF,IAChBF,EAAQ/F,QAAUmG,GAAaJ,EAAQxG,KAAK0E,OAAO+B,OAAOrG,EAAMM,gBAC9DmG,EAASL,EAAQI,MACJ,iBAAR1C,IAAkBA,EAAME,OAAOF,IAC1C2C,EAAO9C,QAEH8C,EAAOxC,OAAOH,GAAK,GAAQ,EAAG,OAC1B3C,EAASsF,EAAOjD,cACC,mBAAZhD,GAAwB,SAAU0D,EAAKC,EAAQC,SAClDZ,EAAQW,EAAOC,MAEjBZ,GAA0B,iBAAVA,MACb,MAAMa,KAAKb,KACVc,OAAOC,UAAUC,eAAeC,KAAKjB,EAAOa,GAAI,OAC5CK,EAAIR,EAAKV,EAAOa,QAEZX,IAANgB,EACFlB,EAAMa,GAAKK,SAEJlB,EAAMa,UAMd7D,EAAQiE,KAAKN,EAAQC,EAAKZ,GAjBA,CAkBhC,IACGrC,GACH,IACHmF,IACOnF,EACFsF,EAAOpD,cAKhBrD,EAAM0G,UAAYC,KAAKD,UAvgDrBE,CANI5H,EAAS,CACd6H,KAAM9H,EACNG,QAAS,GACT4H,QAAS,SAAUD,EAAME,UAM5B,iBACO,IAAI3D,MAAM,2EANJ4D,CAAuBD,MAAAA,GAAuC/H,EAAO6H,QAEnE7H,EAAOE,SAAUF,EAAOE,SCE1B+H,EAAsB,SAACvB,UAC3BA,EAAIwB,QAAQ,QAAS,SAACC,UACpBA,EAAIC,MAAM,EAAGD,EAAI9G,OAAS,OAIxBgH,EAAiB,SAACC,UACtBC,EAAUhB,WAGRe,GAAQ,IAAIJ,QAAQ,MAAQ,IAAIA,QAAQ,MAAQ,IAAM,MAKpDM,EAAe,SAACC,EAAO/B,SAO9BgC,EANJC,IAAAA,QACAC,IAAAA,MACAC,IAAAA,eACAC,IAAAA,WACAC,IAAAA,YAGIC,EAAgB,MAChBJ,IACFC,EAAiBD,EACjBE,EAAaF,EACbG,EAAcH,GAEqB,QAA7BF,EAAQD,EAAMQ,KAAKvC,KAAgB,SACxBgC,KAAVQ,OAAGf,OACHgB,EAAaV,EAAbU,UAEDC,EAAgBD,EAAYD,EAAE7H,OAChC+H,EAAgBJ,GAClBH,EAAenC,EAAI0B,MAAMY,EAAeI,IAGtCL,GAAeZ,EAAI9G,OAAS,GAC9B2H,EAAgBG,EAChBJ,EAAYG,KAGdP,iBAAWD,IACXM,EAAgBG,GAEdH,IAAkBtC,EAAIrF,QACxByH,EAAWpC,EAAI0B,MAAMY,KCvDrBK,EAA0B,oBAAVC,MAEhBA,MACA,KAMSC,EAAW,SAACC,GACvBH,EAASG,GAMEC,EAAW,kBACfJ,GAGLK,EAA2B,oBAAbC,SAEdA,SACA,KAMSC,EAAc,SAACC,GAC1BH,EAAOG,GAMIC,EAAc,kBAClBJ,GCXF,IAAMK,EAAO,SAACC,EAAQC,EAAcC,UAClCD,EAAaF,KAAK,IAAII,KAAKC,SAChCJ,EACAE,GACAG,UAGSC,EAAO,SAACN,EAAQC,EAAcC,UAClC,IAAIC,KAAKI,WACdP,EAAQE,GACRM,OAAOP,IAUEQ,EAAW,SACtBT,EAAQC,EAAcS,EAAKC,EAAaC,MAErB,mBAARF,SAViB,SAC5BV,EAAQC,EAAcU,EAAaC,UAEnCb,EAAKC,EAAQC,EAAcW,GACpBN,EAAKN,EAAQC,EAAcU,GAOzBE,CAAeb,EAAQC,EAAcS,EAAKC,GAEnDZ,EAAKC,EAAQC,EAAcW,OA1CvBE,EA4CEC,GA5CFD,EAAIE,KAAKC,MAEc,oBAAhBC,aACoB,mBAApBA,YAAYD,MAErBH,GAAKI,YAAYD,OAEZ,uCAAuC/C,QAAQ,SAAU,SAAUnC,OAElEtB,EAAI0G,KAAKC,OAAON,EAAoB,GAAhBK,KAAKE,UAAiB,WAChDP,EAAIK,KAAKG,MAAMR,EAAI,KACL,MAAN/E,EAAYtB,EAAS,EAAJA,EAAU,GAAM8G,SAAS,QAmC9CC,EAAmBC,EAAIxB,GAAcS,KACzC,SAACxB,EAAGwC,qBAAWX,UAAWW,WAEtBC,EAAQ,GACR/K,EAAO,WACX+K,EAAM/K,WAAN+K,cAGFnD,MAEMoD,mBAAYb,aAAmB,MACnCT,EAAKN,EAAQwB,EAAkBb,GAAc,CAC3C9B,eAAgBjI,EAChBkI,WAAYlI,EACZ+H,iBAASO,EAAG2C,GACVjL,EAAK8J,EAAIT,EAAa4B,GAAMA,WAK5BC,EADOhC,IACUiC,gCACvBD,EAAUE,aAAVF,EAAoBH,GACbG,GC5EIG,EAAmB,gBAAEC,IAAAA,UAC5BC,MAAMC,QAAQF,GAAS,IACA,mBAAdA,EAAO,GAAmB,SACWA,WACvC,CAAC1H,WAAO6H,cAAUnC,aAASoC,wBAEAJ,WAC7B,CAAC1H,WAAO0F,aAASoC,sBAEnB,CAAC9H,MAAO0H,IAoBJK,EAA0B,gBASjCC,EATmChI,IAAAA,MAAOiI,IAAAA,IAAUzC,KAAL5E,MAAK4E,WAGrC,iBAAVxF,GAAuBA,GAA0B,WAAjBkI,EAAOlI,IAC9C,aAAcA,SAEPA,MAKHmI,EAAY,gBAAEC,IAAAA,SAAM1C,QAAAA,aAAUsC,QAAMK,gBAAAA,mBACrB,iBAARJ,EAAkB,SACaA,EAAIK,MAAM,QAA7CC,OAAUC,OAAWC,OAET,SAAbF,IACFA,EAAW,YAETA,IAAaH,IACVI,EAEOH,IAAmBI,IAE7B/C,SACKA,GACA7B,EACDwE,GAAmBI,EAAaA,EAAaD,KANjD9C,EAAU,WAYTA,MAGL1F,GAA0B,WAAjBkI,EAAOlI,GAAoB,KAChC0I,EAAY5H,OAAO6H,KAAK3I,GAAO,MACjC,CACF,SAAU,OAAQ,WAAY,WAAY,OAAQ,UAClD4I,SAASF,GAAY,KACjBZ,EAAWD,IAGXJ,EAAiB,CAACC,OAAQ1H,EAAM0I,YADlC1I,IAAAA,MAAgBgI,IAATtC,QAAeoC,IAAAA,UAAWD,IAAAA,SAG3Ba,OACH,iBAEiB,CAACV,EAAMF,UAA1BA,OAAWE,OACL,IAAIrC,KAAKkD,mBACdrD,EAAQ2C,EAAU,CAACC,KAAM,cACzBpC,OAAOhG,EAAO8H,OAGb,cACCD,EACK5B,EACLT,EAAQxF,EAAO6H,EACfM,EAAU,CAACC,KAAM,SACjBD,EAAU,CACRC,KAAM,OAAQ1C,QAASoC,EAAWO,iBAAiB,KAIlDpC,EAAST,EAAQxF,EAAOmI,EAAU,CAACC,KAAM,SAAUD,EAAU,CAClEC,KAAM,OAAQ1C,QAASoC,EAAWO,iBAAiB,UAYtC,iBAAVrI,SACF,IAAI2F,KAAKmD,aACdtD,EACA2C,EAAU,CAACC,KAAM,YACjBpC,OAAOhG,MAKTA,GAA0B,WAAjBkI,EAAOlI,IACS,mBAAlBA,EAAM+I,eAEN,IAAIpD,KAAKqD,eACdxD,EACA2C,EAAU,CAACC,KAAM,cACjBpC,OAAOhG,SAIL,IAAIiJ,UAAU,sBCzHTC,0BAWPC,EAAkB,gBAAEvI,IAAAA,IAAKwI,IAAAA,KAAMhB,IAAAA,SAAMiB,aAEnCC,EADgBC,EAAwB,CAACF,wBADS,gBAEnCG,CAAc,CAACJ,KAAAA,GAAOxI,OACtC0I,QACG,IAAI1J,wCAAiCwI,oBAAcxH,eAIpD0I,EAAatJ,OAMTyJ,kBAAuBP,yBAIrBQ,2CAENA,OAASA,sDAMC9I,UACRuI,EAAgB,CACrBvI,IAAKA,EAAIgD,MAAM,GAAIwF,KAAMhK,KAAKsK,OAAQtB,KAAM,0CAOvCxH,OACD+I,EAAa/I,EAAIgD,MAAM,GAAG0E,MAAM,KAClCsB,EAASxK,KAAKsK,cACXtK,KAAKyK,YAAYC,cAAclJ,IAAQ+I,EAAWI,OAAM,SAACC,OACxDrM,EAASqM,KAAQJ,SACvBA,EAASA,EAAOI,GACTrM,6CAOWiD,UACbA,EAAIqJ,WAAW,cAObC,kBAAyBhB,yBAIvBiB,2CAENA,cAAgBA,8CAMdvJ,UACAxB,KAAKyK,YAAYC,cAAclJ,IAAQA,KAAOxB,KAAK+K,sDAMtCvJ,SACZ,gBAAQwJ,KAAKxJ,YAOZyJ,kBAAwBnB,yBAKtBoB,WAAWH,IAAAA,gDAEjBG,SAAWA,IACXH,cAAgBA,sDAYNvJ,SAQXwH,EAAMJ,EARWxC,IAAAA,OAAQ+E,IAAAA,SAAUtC,IAAAA,IAAKuC,IAAAA,0BACtCC,EAAKrL,KAAKyK,YAAYa,OAAO9J,GAAKgD,MAAM,OAIXxE,KAAKuL,SAASF,MAA1CG,OAAQxB,OAAMyB,UACrBN,EAASnO,KAAKyO,GAGVD,GAAUA,EAAOhC,SAAS,KAAM,SACjBgC,EAAOtC,MAAM,QAA3BF,OAAMJ,WAENoB,SACHoB,EAA0B,CACxB5J,IAAAA,EACAkK,UAAW1L,OAEN,MAAQwB,EAAM,QASjBmK,EAAkB,SAAC/K,EAAOgL,OACxBC,EAAapH,EAAemE,UAC3B,IAAIrC,KAAKmD,aAAatD,SACxBwF,GAAmBC,IACrBjF,OAAOhG,IAGNkL,EAAkB,SAAClL,EAAOgL,OACxBG,EAAatH,EAAemE,UAC3B,IAAIrC,KAAKyF,YAAY5F,SACvBwF,GAAmBG,IACrBE,OAAOrL,IAGNsL,EAAiBlM,KAAK+K,cAAcU,GAEtC3G,EAAQoH,KACkB,iBAAnBA,SACDlD,OACH,SACHlE,EAAQ6G,EAAgBO,aAErB,SACHpH,EAAQgH,EAAgBI,iBAGxBpH,EAAQ,IAAIyB,KAAKyF,YAAY5F,GAAQ6F,OAAOC,QAGzC,GAAIA,GAA4C,WAA1BpD,EAAOoD,GAA6B,KACzD5C,EAAY5H,OAAO6H,KAAK2C,GAAgB,MAC1C,CAAC,SAAU,UAAU1C,SAASF,GAAY,OACnBjB,EAAiB,CACxCC,OAAQ4D,EAAe5C,KADlB1I,IAAAA,MAAO0F,IAAAA,WAGT0C,IACHA,EAAOM,EAAU6C,iBAEC7C,EAAU6C,gBAAkBnD,SAExC,IAAIa,oCAENb,EAAKoD,2CACc9C,gBAIjBN,OACH,SACHlE,EAAQ6G,EAAgB/K,EAAO0F,aAE5B,SACHxB,EAAQgH,EAAgBlL,EAAO0F,SAQ/B2D,EAAe,aAEfoC,EAAiB,SAACC,UACfA,EAAEhI,QAAQ,MAAQ,QAAQA,QAAQ,MAAQ,mBAI1CyF,EAAgB,CACrBE,aAAAA,EACAzI,IAAKsD,EAAQuH,EAAevH,GAAS+D,EACrCmB,KAAAA,EACAhB,KAAM,WAER,MAAOuD,cAEExC,EAAgB,CACrBE,aAAAA,EAAczI,IAAK,IAAM6K,EAAevH,GAAQkF,KAAAA,EAAMhB,KAAM,WAE9D,MAAOwD,OACD/K,EAAIC,OAAO6H,KAAKS,GAAMyC,MAC1B,SAACC,UAAcA,EAAU7B,WAAW,YAEjCpJ,QACG,IAAIjB,6CAAsC6K,WAE3CtB,EAAgB,CACrBE,aAAAA,EAAczI,IAAK6K,EAAe5K,GAAIuI,KAAAA,EAAMhB,KAAM,6CAUjDxH,UACAA,GAAOxB,KAAKyK,YAAYC,cAAclJ,IAC3CmL,QAAQ3M,KAAKuL,SAAS/J,EAAIgD,MAAM,IAAI/G,yCAc9B4N,cACFuB,EAAKvB,EAAGnC,MAAM,YACb0D,EAAGC,QAAO,SAACC,EAAKrL,EAAGqG,MACpBA,EAAI8E,EAAGnP,OAAS,EAAG,MACfgE,KAAKqL,SACH,IAAItM,4BAAqBiB,iCAAwB4J,gBAElDyB,EAAIrL,OAIPsL,EAAMrL,OAAOsL,QAAQF,GAAKL,MAAK,gBAAEC,mBAC9BjL,IAAMwL,EAAKxC,YAAYa,OAAOoB,aAGhCK,EAAMA,EAAIG,OAAOzL,GAAK,KAC5BzB,KAAKkL,kDAOY1J,UACbA,EAAIqJ,WAAW,oCAMTrJ,OACPsD,EAAQtD,EAAIsD,MAAM,6BACjBA,GAASA,EAAM,YC/MnB,WAAgBlE,EAAOuM,EAAMC,UAC/BA,EACID,EAAOA,EAAKvM,GAASA,GAExBA,GAAUA,EAAMuM,OACpBvM,EAAQyM,QAAQC,QAAQ1M,IAElBuM,EAAOvM,EAAMuM,KAAKA,GAAQvM,GAud3B,WAAgBoJ,EAAMjK,WAEvBxB,EAASyL,IACZ,MAAMuD,UACAxN,EAAQwN,UAEZhP,GAAUA,EAAO4O,KACb5O,EAAO4O,UAAK,EAAQpN,GAErBxB,EAphBD,WAAiBiP,EAAMC,EAAO7M,OAC/B4M,EAAKlB,EAAG,IACR1L,eAAwB,KACvBA,EAAM0L,cAMT1L,EAAM8M,EAAIC,EAAQC,KAAK,KAAMJ,EAAMC,IALvB,EAARA,IACHA,EAAQ7M,EAAM0L,GAEf1L,EAAQA,EAAMkB,KAMZlB,GAASA,EAAMuM,iBAClBvM,EAAMuM,KAAKQ,EAAQC,KAAK,KAAMJ,EAAMC,GAAQE,EAAQC,KAAK,KAAMJ,EAAM,IAGtEA,EAAKlB,EAAImB,EACTD,EAAK1L,EAAIlB,MACHiN,EAAWL,EAAKE,EAClBG,GACHA,EAASL,IA3DL,IAAMM,EAAsB,kCAE5BnM,UAAUwL,KAAO,SAASY,EAAaC,OACtCzP,EAAS,MACTkP,EAAQzN,KAAKsM,KACfmB,EAAO,KACJhF,EAAmB,EAARgF,EAAYM,EAAcC,KACvCvF,EAAU,OAEJlK,EAAQ,EAAGkK,EAASzI,KAAK8B,IAChC,MAAOyL,KACAhP,EAAQ,EAAGgP,UAEbhP,SAEAyB,iBAGJ0N,EAAI,SAASO,WAEVrN,EAAQqN,EAAMnM,EACN,EAAVmM,EAAM3B,IACD/N,EAAQ,EAAGwP,EAAcA,EAAYnN,GAASA,GAC5CoN,IACFzP,EAAQ,EAAGyP,EAAWpN,MAEtBrC,EAAQ,EAAGqC,GAEnB,MAAO2M,KACAhP,EAAQ,EAAGgP,KAGdhP,KAhC0B,GAgE5B,WAAwB2P,UACvBA,gBAA0C,EAAbA,EAAS5B,EA6LvC,WAActB,EAAMmD,EAAQnE,WAC9BoE,IACK,KACJC,EAAiBrD,OACjBsD,EAAeD,KAClBA,EAAiBA,EAAevM,IAE5BuM,SACG9P,KAEJ8P,EAAelB,KAAM,CACxBiB,EAAQ,YAGL7P,EAASyL,OACTzL,GAAUA,EAAO4O,KAAM,KACtBmB,EAAe/P,GAEZ,CACN6P,EAAQ,QAFR7P,EAASA,EAAO+N,KAMd6B,EAAQ,KACPI,EAAcJ,OACdI,GAAeA,EAAYpB,OAASmB,EAAeC,GAAc,CACpEH,EAAQ,cAKPZ,EAAO,MACPgB,EAASb,EAAQC,KAAK,KAAMJ,EAAM,UAC3B,IAAVY,EAAcC,EAAelB,KAAKsB,GAA8B,IAAVL,EAAc7P,EAAO4O,KAAKuB,GAAoBH,EAAYpB,KAAKwB,IAAqBxB,UAAK,EAAQqB,GACjJhB,WACEkB,EAAiB9N,GACzBrC,EAASqC,IACN,IACEuN,IACHI,EAAcJ,MACKI,EAAYpB,OAASmB,EAAeC,eACtDA,EAAYpB,KAAKwB,GAAoBxB,UAAK,EAAQqB,QAIpDH,EAAiBrD,MACOsD,EAAeD,KAAoBA,EAAevM,gBACjE0L,EAAM,EAAGjP,MAGd8P,EAAelB,iBAClBkB,EAAelB,KAAKsB,GAAkBtB,UAAK,EAAQqB,GAIhDF,EADJ/P,EAASyL,OAERzL,EAASA,EAAOuD,UAERvD,IAAWA,EAAO4O,MAC5B5O,EAAO4O,KAAKuB,GAAkBvB,UAAK,EAAQqB,YAEnCC,EAAiBJ,GACrBA,GACH9P,EAASyL,MACKzL,EAAO4O,KACpB5O,EAAO4O,KAAKuB,GAAkBvB,UAAK,EAAQqB,GAE3CE,EAAiBnQ,KAGViP,EAAM,EAAGjP,YAGVoQ,KACJN,EAAiBrD,KAChBqD,EAAelB,KAClBkB,EAAelB,KAAKsB,GAAkBtB,UAAK,EAAQqB,GAEnDC,EAAiBJ,KAGVb,EAAM,EAAGjP,IA1Ob,WAAmBqC,EAAOuM,UACzBvM,GAASA,EAAMuM,KAAOvM,EAAMuM,KAAKA,GAAQA,EAAKvM,GAjC/C,WAAgBgF,UACf,eACD,IAAIlB,EAAO,GAAIoD,EAAI,EAAGA,EAAI8G,UAAUnR,OAAQqK,IAChDpD,EAAKoD,GAAK8G,UAAU9G,cAGbuF,QAAQC,QAAQ1H,EAAEiJ,MAAM7O,KAAM0E,IACpC,MAAM6I,UACAF,QAAQmB,OAAOjB,SA5CZuB,EAAwB,SACnCC,EAAQC,OAASC,yDAAe,mCAE3B1G,MAAMC,QAAQuG,SACX,IAAIlF,UACR,yEAGmB,mBAAZmF,QACH,IAAInF,UACR,gFAGGqF,kBACDnC,EAIAoC,OAHAC,EAAI/B,QAAQmB,OACd,IAAIhO,MAAM,gHAIJI,EAAQmO,EAAO3O,sCAGPgP,eAAZrC,6BAGIoC,QACI,IAAI3O,MAAMyO,GAGbF,EAAOtR,SACV0R,GAAW,GAGbC,EAAIJ,EAAQpO,6BAGTmM,OAxBFmC,IC4CIG,EAAwB,SAACC,EAAiBlJ,MACtB,iBAApBkJ,QACH,IAAIzF,UACR,kEAGkB,iBAAXzD,QACH,IAAIyD,UACR,yDAGC,WAAWmB,KAAK5E,SACb,IAAIyD,UACR,iFAGMyF,EAAgBhL,QAAQ,MAAQ,yBAAgB8B,qBCzE/CmJ,EAAqB,gBAEhCjS,IAAAA,OAAQkS,IAAAA,IAAKrE,IAAAA,SAAUJ,IAAAA,cAAe0E,IAAAA,iBAAkBrJ,IAAAA,OACxDkE,IAAAA,OAAQY,IAAAA,aACRwE,yBAAAA,aAA2B,IAC3BtE,IAAAA,0BACAuE,IAAAA,gCAEwC,iBAA7BD,QACH,IAAI7F,UAAU,oDAEhB+F,EAAiB,IAAIvF,EAAeC,GACpCuF,EAAmB,IAAI/E,EAAiBC,GACxC+E,EAAkB,IAAI7E,EAAgBC,EAAU,CAACH,cAAAA,IAIjDgF,EAAkB,sEACpBN,IACFA,EAAmBlH,MAAMC,QAAQiH,GAC7BA,EACA,CAACA,QAGD1F,EAAkB,gBAClBG,EADoB1I,IAAAA,IAAKqH,IAAAA,IAAKmH,IAAAA,cAEfJ,EAAenF,YAAYC,cAAclJ,GAE1D0I,EAAe0F,EAAe7F,gBAAgBvI,GACrCsO,EAAgBrF,YAAYC,cAAclJ,GACnD0I,EAAe4F,EAAgB/F,gBAAgBvI,EAAK,CAClD4E,OAAAA,EAAQ+E,SAAAA,EAAUtC,IAAAA,EAClBuC,0BAAAA,IAI0B,mBAD5BlB,EAAe8F,EAAOxO,MAEpB0I,EAAeA,EAAa,CAACrB,IAAAA,EAAKrH,IAAAA,KAOlCiO,EACFvF,EAAeuF,EAAiB5C,QAAO,SAACoD,EAAOC,UACtCA,EAAS,CACdtP,MAAOqP,EAAOpH,IAAAA,EAAKrH,IAAAA,EAAK4E,OAAAA,MAEzB8D,GACMrB,GAAOA,EAAI/D,MAAM,qDAC1BoF,EAAevB,EAAwB,CACrC/H,MAAOsJ,EAAcrB,IAAAA,EAAKrH,IAAAA,EAAK4E,OAAAA,KAG5B8D,GAGLiG,EAAsB,EACpBC,EAAiB,gBAAElG,IAAAA,aAAcmB,IAAAA,GAAIxC,IAAAA,IAAKwH,IAAAA,iBAEpB,iBAAjBnG,GACPA,EAAaV,SAAS,KACtB,IACI2G,IAAwBT,QACpB,IAAI7F,UAAU,6CAGlB+F,EAAenF,YAAYC,cAAcW,GAAK,KAE5CiF,EADAC,EAAcxF,EAEdlC,IACFyH,EAAkB7L,EAAeoE,GACjC0H,SACKxF,GACAuF,IAGPpG,EAAemG,EAAc,CAC3BvN,IAAKoH,EAAc8F,OAAQO,EAC3B7E,UAAWkE,IAETU,GACFX,EAA6B,CAAC5E,cAAeuF,SAEtCR,EAAgBrF,YAAYC,cAAcW,KACnDnB,EAAemG,EAAc,CAC3BvN,IAAKoH,YAIJA,OAIJsF,EAAK,KAEJgB,GAAa,EA4BXzD,EA3BU,SAAVzI,SACJxB,IAAAA,QAAKkN,OAAAA,aAASjF,QACdW,UAAAA,aAAYmE,WAEL/M,EAAIwB,QAAQyL,GAAiB,SAACzK,EAAGf,EAAK8G,EAAIoF,EAAM5H,MACjDtE,EAAI9G,OAAS,SACR6H,KAEL8F,EAA0B,CAC5B5J,IAAK6J,EACLK,UAAAA,WAEOpG,MAEL4E,EAAeH,EAAgB,CAACvI,IAAK6J,EAAIxC,IAAAA,EAAKmH,OAAAA,WAElD9F,EAAekG,EAAe,CAC5BlG,aAAAA,EAAcmB,GAAAA,EAAIxC,IAAAA,EAAKwH,cAAe/L,IAGxCkM,EAAaA,GACVtG,GAAwC,WAAxBpB,EAAOoB,IACxB,aAAcA,EAChBiB,EAASnO,KAAKqO,GACP9G,EAAM2F,KAGL5F,CAAQ,CAACxB,IAAKxF,QACrBkT,SACHb,EAA6B,CAAC5E,cAAAA,IAC9BI,EAAS1N,OAAS,EACX4G,EAAoB0I,GAE7B5B,EAAS1N,OAAS,EAGpB0S,EAAsB,MAiDhBpI,EAhDuB,SAAvB2I,SACJ5N,IAAAA,QAAKkN,OAAAA,aAASjF,QAAeW,UAAAA,aAAYmE,IAEnC9H,EAAQ,GAKRlD,EAAQ,IAAImD,OAAO+H,EAAiB,MAEpC/S,EAAO,WACX+K,EAAM/K,WAAN+K,qBAGFnD,EAAaC,EAAO/B,EAAK,CACvBkC,MAAOhI,EACP+H,iBAASO,EAAGf,EAAK8G,EAAIoF,EAAM5H,MACrBuC,EAA0B,CAC5B5J,IAAK6J,EAAIK,UAAAA,IAET1O,EAAKsI,OACA,CACDf,EAAI9G,QACNT,EAAKuH,OAGH2F,EAAeH,EAAgB,CAACvI,IAAK6J,EAAIxC,IAAAA,EAAKmH,OAAAA,IAClD9F,EAAekG,EAAe,CAC5BlG,aAAAA,EAAcmB,GAAAA,EAAIxC,IAAAA,EAAKwH,cAAeK,IAEpCnI,MAAMC,QAAQ0B,GAChBlN,iBAAQkN,IAIRA,GAAwC,WAAxBpB,EAAOoB,IACvB,aAAcA,EAEdlN,EAAKkN,EAAayG,WAAU,IAE5B3T,EAAKkN,GAGTiB,EAASnO,KAAKqO,MAGXtD,EAEK2I,CAAqB,CAAC5N,IAAKxF,WAEzCqS,EAA6B,CAAC5E,cAAAA,IAC9BI,EAAS1N,OAAS,EACXsK,EAAMjB,KAAI,SAAChH,SACI,iBAATA,EACFuE,EAAoBvE,GAEtBA,MCnLEqK,EAA0B,wEAGnC,OADFF,aAAAA,aAAe,qBAGgB,mBAAjBA,EACVA,EACkB,eAAjBA,EACC,SAAC2G,EAASpP,OACJsL,EAAM8D,GAA8B,WAAnB9H,EAAO8H,IAAwBA,EAAQ5G,KACxDT,EAAO,GAGPsH,EAA2B,SAAChT,GAC3B0L,EAAK9L,SACR8L,EAAK,GAAK,IAEZA,EAAKA,EAAK9L,OAAS,IAAMI,GAE3B+G,EAPmC,WAOMpD,EAAK,CAG5CwD,MAAO6L,EACP9L,iBAASO,EAAGf,GAIVsM,EAAyBtM,GACzBgF,EAAKvM,KAAK,WAGR8T,EAAgBvH,EAAKzC,KAAI,SAACuE,UACvBhH,EAAoBgH,MAGzB0B,GAAM,EACNgE,EAAUjE,SACdgE,EAAcE,MAAK,SAAC3F,EAAIvD,EAAGmJ,UACpBF,GAA8B,WAAnBjI,EAAOiI,KAKrBjJ,IAAMmJ,EAAIxT,OAAS,GACnB4N,KAAM0F,GAAWA,EAAQ1F,IAA8B,WAAvBvC,EAAOiI,EAAQ1F,KAC/C,YAAa0F,EAAQ1F,IAEU,iBAAxB0F,EAAQ1F,GAAI6F,UAEnBnE,EAAM,CACJnM,MAAOmQ,EAAQ1F,GAAI6F,QACnBC,KAAMJ,EAAQ1F,KAGlB0F,EAAUA,EAAQ1F,IAEX,MAEF0B,GAEW,SAAjB9C,EACC,SAAC2G,EAASpP,OACJsL,EAAM8D,GAA8B,WAAnB9H,EAAO8H,IAAwBA,EAAQ5G,cAE5D8C,GAAsB,WAAfhE,EAAOgE,IACdtL,KAAOsL,GAAOA,EAAItL,IAA4B,WAApBsH,EAAOgE,EAAItL,KACrC,YAAasL,EAAItL,IAEW,iBAArBsL,EAAItL,GAAK0P,UAET,CACLtQ,MAAOkM,EAAItL,GAAK0P,QAChBC,KAAMrE,EAAItL,KAKI,UAAjByI,EACC,SAAC2G,EAASpP,OACJsL,EAAM8D,GAA8B,WAAnB9H,EAAO8H,IAAwBA,EAAQ5G,cAE5D8C,GAAsB,WAAfhE,EAAOgE,IACdtL,KAAOsL,GAAOA,EAAItL,IAA4B,iBAAbsL,EAAItL,KAE9B,CACLZ,MAAOkM,EAAItL,KAKd,iBACK,IAAIqI,2CAAsCI,IAD/C,IC5HAmH,EAAkC,eAezCtO,2DARF,GALFoO,IAAAA,QACAG,IAAAA,SACApH,IAAAA,iBACAG,cAAAA,aAAgBD,EAAwB,CAACF,aAAAA,MACzCzI,IAAAA,OAEmB,iBAARA,QACH,IAAIqI,UACR,6FAMmB,iBAAZqH,EACTpO,EAAMoO,OACD,IACQ,IAAbG,GAAAA,MAAsBA,EAEtBvO,GAAM,MACD,CAAA,IAAIuO,GAAgC,WAApBvI,EAAOuI,SAMtB,IAAIxH,UACR,2EANF/G,EAAMsH,EAAc,CAACJ,KAAMqH,GAAW7P,MAEpCsB,EAAMA,EAAIlC,WAQF,IAARkC,QACI,IAAItC,8CAAuCgB,eAE5CsB,GCvBIwO,EAAwB,wEAgBjC,GAdFhU,IAAAA,OACA8I,IAAAA,OACAkE,IAAAA,OACAY,IAAAA,cACAwE,2BACAD,kBAAAA,aAAmB,CACjB9G,SAEF4I,YAAAA,aAAchC,QACdxE,cAAAA,oBACAyE,IAAAA,oBACAgC,gBAAAA,oBACAC,iCAAAA,oBACAC,+BAAAA,mBAEsB,iBAAXpU,QACH,IAAIuM,UACR,gHAIE8H,EAAmB,SAAC7O,OAClBgD,EAAOI,WACNsL,EAAkB1L,EAAK8L,eAAe9O,GAAOA,GAGhDqI,EAAW,GAYXwE,EAA+B,gBACpBK,IAAfjF,cAEI2G,GACFhQ,OAAO6H,KAAKyG,GAAQ6B,SAAQ,SAACrQ,OACtB2J,EAAS3B,SAAShI,SACf,IAAIhB,sCAA+BgB,QAgB3C4J,EAA4B,gBAChC5J,IAAAA,IAAKkK,IAAAA,UAECoG,EAAWpG,EAAUqG,QAAQvQ,MAC/BkK,EAAUjB,YAAYC,cAAclJ,KAASsQ,EAAU,IACrDL,QACI,IAAIjR,wCAAiCgB,WAEtC,SAEF,OAINuJ,IAAkB0E,IAClBgC,SAEME,EAAiBrU,GAErByN,IACHA,EAAgB,QAGZhD,EAAQwJ,EAAY,CACxBjU,OAAAA,EAAQkS,IAAAA,EAAKrE,SAAAA,EAAUJ,cAAAA,EAAe0E,iBAAAA,EAAkBrJ,OAAAA,EACxDkE,OAAAA,EAAQY,SAAAA,EACRE,0BAAAA,EACAuE,6BAAAA,OAEmB,iBAAV5H,SACF4J,EAAiB5J,OAGpBjC,EAAOI,IACPgC,EAAYpC,EAAKqC,gCACvBD,EAAUE,aAAVF,IAAoBH,IAEbG,GCxCF,WAAgBtH,EAAOuM,EAAMC,UAC/BA,EACID,EAAOA,EAAKvM,GAASA,GAExBA,GAAUA,EAAMuM,OACpBvM,EAAQyM,QAAQC,QAAQ1M,IAElBuM,EAAOvM,EAAMuM,KAAKA,GAAQvM,GArB3B,WAAgBgF,UACf,eACD,IAAIlB,EAAO,GAAIoD,EAAI,EAAGA,EAAI8G,UAAUnR,OAAQqK,IAChDpD,EAAKoD,GAAK8G,UAAU9G,cAGbuF,QAAQC,QAAQ1H,EAAEiJ,MAAM7O,KAAM0E,IACpC,MAAM6I,UACAF,QAAQmB,OAAOjB,SA3DZyE,GAAuB,SAAC5L,OAC9BA,EAAOoD,SAAS,WACb,IAAIhJ,MAAM,+BAKX4F,EAAO9B,QAAQ,2BAAY,KAUvB2N,GAAoB,gBAC/B7L,IAAAA,OAAQ8L,IAAAA,YAASC,eAAAA,aAAiBH,eAGxBE,EAAQ1I,SAASpD,IAEvBA,EAAS+L,EAAe/L,GAE1B,MAAOmG,UACA,SAEFnG,GAwBIgM,GAAoB,wEAM7B,GALFF,IAAAA,QACAG,IAAAA,eACAF,IAAAA,eACA7C,IAAAA,gBACAgD,IAAAA,qBAEOC,GAAY,CACjBL,QAAAA,EAASG,eAAAA,EAAgBF,eAAAA,EAAgB7C,gBAAAA,EAAiBgD,cAAAA,KAmBjDE,GAAa,wEAMtB,GALFN,IAAAA,QACAG,IAAAA,eACAF,IAAAA,eACA7C,IAAAA,gBACAgD,IAAAA,qBAEOC,GAAY,CACjBL,QAAAA,EAASG,eAAAA,EAAgBF,eAAAA,EAAgB7C,gBAAAA,EAAiBgD,cAAAA,EAC1DG,UAAU,KASRF,sBAgBWG,cAAWtM,MACF,iBAAXA,QACH,IAAIyD,UAAU,8BAEhB8I,EAAMR,EAAe7C,EAAiBlJ,MACzB,iBAARuM,QACH,IAAI9I,UACR,gEAuaD,SAAgBG,EAAMjK,WAEvBxB,EAASyL,IACZ,MAAMuD,UACAxN,EAAQwN,UAEZhP,GAAUA,EAAO4O,KACb5O,EAAO4O,UAAK,EAAQpN,GAErBxB,mBA5aIkH,EAASI,aACK4M,EAChBhN,EAAOkN,EAAK,CACZC,OAAQ,SAERnN,EAAOkN,aAJLE,MAOc,MAAhBA,EAAKxU,aAID,IAAImC,MAAM,uBAEdiS,EACKrM,IAEcyM,EAAKC,iBAAtBC,SACC,CACL3M,OAAAA,EACA2M,QAAAA,qBAEKxG,MACU,gBAAbA,EAAIzO,WACAyO,WAEgB+F,EAAclM,GAC/BsM,aArDXR,QAAAA,aAAmC,oBAAlBc,cACb,CAACA,eACoB,oBAAdC,UAA4B,GAAKA,UAAUC,gBACtDb,eAAAA,aAAiB,CAAC,eAClBF,eAAAA,aAAiB9C,QACjBC,gBAAAA,aAAkB,UAClBgD,cAAAA,aAAgB,eAChBG,SAAAA,mBAiDsB,WAAlBH,EACFA,EAAgBN,QACX,GAA6B,mBAAlBM,QACV,IAAIzI,UAAU,0DAETiF,cACPoD,KAAYG,IAChBK,EACA,gCCjGG,YAAgB9R,EAAOuM,EAAMC,UAC/BA,EACID,EAAOA,EAAKvM,GAASA,GAExBA,GAAUA,EAAMuM,OACpBvM,EAAQyM,QAAQC,QAAQ1M,IAElBuM,EAAOvM,EAAMuM,KAAKA,GAAQvM,OAjDrBuS,GAAa,gBAExBJ,IAAAA,QACAK,IAAAA,eACAnJ,IAAAA,aACkBoJ,IAAlB5D,iBACA8B,IAAAA,YACU+B,IAAVjC,SACekC,IAAfxI,cACA2E,IAAAA,6BACAF,IAAKgE,oBACLhC,gBAAiBiC,oBACjBhC,iCACEiC,oBACFhC,+BACEiC,oBAEGZ,GAA8B,WAAnBjK,EAAOiK,SACf,IAAIlJ,mDAENO,EAAgBD,EAAwB,CAACF,aAAAA,IACzCyB,EAAY,SAAClK,EAAKuJ,gEAOpB,OANF0E,iBAAAA,aAAmB4D,QACnBhC,SAAAA,aAAWiC,QACX9D,IAAAA,aAAMgE,QACNhC,gBAAAA,aAAkBiC,QAClBhC,iCAAAA,aAAmCiC,QACnChC,+BAAAA,aAAiCiC,IAE3BzC,EAAU9G,EAAc2I,EAASvR,GACjClE,EAAS8T,EAAgC,CAC7CF,QAAUA,GAAWA,EAAQtQ,QAAU,EACvCyQ,SAAAA,EACAjH,cAAAA,EACA5I,IAAAA,WAGK8P,EAAsB,CAC3BhU,OAAAA,EACAgN,OAAQyI,EAAQa,MAAQb,EAAQa,KAAKtJ,OACrCY,SAAU6H,EAAQa,MAAQb,EAAQa,KAAK1I,SACvC9E,OAAQgN,EACR1D,yBAAAA,EACAD,iBAAAA,EACA8B,YAAAA,EACAxG,qBAAmBwI,GAAyBxI,GAC5CyE,IAAAA,EACAgC,gBAAAA,EACAC,iCAAAA,EACAC,+BAAAA,YAIJhG,EAAU0H,eAAiBA,EAC3B1H,EAAUqH,QAAUA,EAEpBrH,EAAUvF,KAAO,sCAAIzB,2BAAAA,yBACZyB,gBAAKiN,UAAmB1O,KAGjCgH,EAAU7E,SAAW,sCAAInC,2BAAAA,yBAChBmC,gBACLuM,UAAmB1O,KAIvBgH,EAAUhF,KAAO,sCAAIhC,2BAAAA,yBACZgC,gBACL0M,UAAmB1O,KAIhBgH,GAwBImI,2EAkBT,GAhBF3B,IAAAA,QACAG,IAAAA,mBACAyB,mBAAAA,aAAqB1B,KACrB9C,IAAAA,gBACA6C,IAAAA,eACAG,IAAAA,cACArI,IAAAA,aACAwF,IAAAA,iBACA8B,IAAAA,YACAF,IAAAA,SACAtG,IAAAA,cACA2E,IAAAA,yBACAF,IAAAA,IACAgC,IAAAA,gBACAC,IAAAA,iCACAC,IAAAA,6CAEgDoC,EAAmB,CACjE5B,QAAAA,EAASG,eAAAA,EAAgBF,eAAAA,EAAgB7C,gBAAAA,EAAiBgD,cAAAA,qBADrDS,IAAAA,QAAiBK,IAARhN,cAIT+M,GAAW,CAChBJ,QAAAA,EACAK,eAAAA,EACAnJ,aAAAA,EACAwF,iBAAAA,EACA8B,YAAAA,EACAF,SAAAA,EACAtG,cAAAA,EACA2E,yBAAAA,EACAF,IAAAA,EACAgC,gBAAAA,EACAC,iCAAAA,EACAC,+BAAAA"}