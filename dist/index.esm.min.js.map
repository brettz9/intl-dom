{"version":3,"file":"index.esm.min.js","sources":["../src/utils.js","../src/shared.js","../src/collation.js","../src/defaultAllSubstitutions.js","../src/Formatter.js","../src/promiseChainForValues.js","../src/defaultLocaleResolver.js","../src/defaultInsertNodes.js","../src/defaultKeyCheckerConverter.js","../src/getMessageForKeyByStyle.js","../src/getStringFromMessageAndDefaults.js","../src/getDOMForLocaleString.js","../src/findLocaleStrings.js","../src/i18n.js"],"sourcesContent":["// We want it to work in the browser, so commenting out\n// import jsonExtra from 'json5';\n// import jsonExtra from 'json-6';\n\nlet _jsonExtra = globalThis.jsonExtra;\nexport const setJSONExtra = (__jsonExtra) => {\n  _jsonExtra = __jsonExtra;\n};\n\nexport const unescapeBackslashes = (str) => {\n  return str.replace(/\\\\+/gu, (esc) => {\n    return esc.slice(0, esc.length / 2);\n  });\n};\n\nexport const parseJSONExtra = (args) => {\n  return _jsonExtra.parse(\n    // Doesn't actually currently allow explicit brackets,\n    //  but in case we change our regex to allow inner brackets\n    '{' + (args || '').replace(/^\\{/u, '').replace(/\\}$/u, '') + '}'\n  );\n};\n\n// Todo: Extract to own library (RegExtras?)\nexport const processRegex = (regex, str, {\n  onMatch,\n  extra,\n  betweenMatches,\n  afterMatch,\n  escapeAtOne\n}) => {\n  let match;\n  let previousIndex = 0;\n  if (extra) {\n    betweenMatches = extra;\n    afterMatch = extra;\n    escapeAtOne = extra;\n  }\n  while ((match = regex.exec(str)) !== null) {\n    const [_, esc] = match;\n    const {lastIndex} = regex;\n\n    const startMatchPos = lastIndex - _.length;\n    if (startMatchPos > previousIndex) {\n      betweenMatches(str.slice(previousIndex, startMatchPos));\n    }\n\n    if (escapeAtOne && esc.length % 2) {\n      previousIndex = lastIndex;\n      escapeAtOne(_);\n      continue;\n    }\n    onMatch(...match);\n    previousIndex = lastIndex;\n  }\n  if (previousIndex !== str.length) { // Get text at end\n    afterMatch(str.slice(previousIndex));\n  }\n};\n","/* globals fetch, document */\nlet _fetch = typeof fetch !== 'undefined'\n  ? fetch\n  /* c8 ignore next */\n  : null;\n\n/**\n * @param {fetch} f\n * @returns {void}\n */\nexport const setFetch = (f) => {\n  _fetch = f;\n};\n\n/**\n * @returns {fetch}\n */\nexport const getFetch = () => {\n  return _fetch;\n};\n\nlet _doc = typeof document !== 'undefined'\n  /* c8 ignore next */\n  ? document\n  : null;\n\n/**\n * @param {document} doc\n * @returns {void}\n */\nexport const setDocument = (doc) => {\n  _doc = doc;\n};\n\n/**\n * @returns {document}\n */\nexport const getDocument = () => {\n  return _doc;\n};\n","/* globals performance */\nimport {processRegex} from './utils.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/**\n *\n * @returns {string}\n */\nfunction generateUUID () { //  Adapted from original: public domain/MIT: http://stackoverflow.com/a/8809472/271577\n  let d = Date.now();\n  /* c8 ignore next 5 */\n  if (typeof performance !== 'undefined' &&\n      typeof performance.now === 'function'\n  ) {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, function (c) {\n    /* eslint-disable no-bitwise */\n    const r = Math.trunc((d + Math.random() * 16) % 16);\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n    /* eslint-enable no-bitwise */\n  });\n}\n\nexport const sort = (locale, arrayOfItems, options) => {\n  return arrayOfItems.sort(new Intl.Collator(\n    locale,\n    options\n  ).compare);\n};\n\nexport const list = (locale, arrayOfItems, options) => {\n  return new Intl.ListFormat(\n    locale, options\n  ).format(arrayOfItems);\n};\n\nexport const sortListSimple = (\n  locale, arrayOfItems, listOptions, collationOptions\n) => {\n  sort(locale, arrayOfItems, collationOptions);\n  return list(locale, arrayOfItems, listOptions);\n};\n\nexport const sortList = (\n  locale, arrayOfItems, map, listOptions, collationOptions\n) => {\n  if (typeof map !== 'function') {\n    return sortListSimple(locale, arrayOfItems, map, listOptions);\n  }\n  sort(locale, arrayOfItems, collationOptions);\n\n  const randomId = generateUUID();\n\n  const placeholderArray = [...arrayOfItems].map(\n    (_, i) => `<<${randomId}${i}>>`\n  );\n  const nodes = [];\n  const push = (...args) => {\n    nodes.push(...args);\n  };\n\n  processRegex(\n    // // eslint-disable-next-line prefer-named-capture-group\n    new RegExp(`<<${randomId}(\\\\d)>>`, 'gu'),\n    list(locale, placeholderArray, listOptions), {\n      betweenMatches: push,\n      afterMatch: push,\n      onMatch (_, idx) {\n        push(map(arrayOfItems[idx], idx));\n      }\n    }\n  );\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n  return container;\n};\n","import {parseJSONExtra} from './utils.js';\nimport {sortList} from './collation.js';\n\nexport const getFormatterInfo = ({object}) => {\n  if (Array.isArray(object)) {\n    if (typeof object[1] === 'function') {\n      const [value, callback, options, extraOpts] = object;\n      return {value, callback, options, extraOpts};\n    }\n    const [value, options, extraOpts] = object;\n    return {value, options, extraOpts};\n  }\n  return {value: object};\n};\n\n/* eslint-disable max-len */\n/**\n * Callback to give replacement text based on a substitution value.\n * @callback AllSubstitutionCallback\n * @param {PlainObject} cfg\n * @param {string|Node|number|Date|RelativeTimeInfo|ListInfo|NumberInfo|DateInfo} cfg.value Contains\n *   the value returned by the individual substitution\n * @param {string} cfg.arg See `cfg.arg` of {@link SubstitutionCallback}.\n * @param {string} cfg.key The substitution key Not currently in use\n * @param {string} cfg.locale The locale\n * @returns {string|Element} The replacement text or element\n*/\n/* eslint-enable max-len */\n\n/**\n * @type {AllSubstitutionCallback}\n */\nexport const defaultAllSubstitutions = ({value, arg, key, locale}) => {\n  // Strings or DOM Nodes\n  if (\n    typeof value === 'string' || (value && typeof value === 'object' &&\n    'nodeType' in value)\n  ) {\n    return value;\n  }\n\n  let opts;\n\n  const applyArgs = ({type, options = opts, checkArgOptions = false}) => {\n    if (typeof arg === 'string') {\n      let [userType, extraArgs, argOptions] = arg.split('|');\n      // Alias\n      if (userType === 'DATE') {\n        userType = 'DATETIME';\n      }\n      if (userType === type) {\n        if (!extraArgs) {\n          options = {};\n        } else if (!checkArgOptions || argOptions) {\n          // Todo: Allow escaping and restoring of pipe symbol\n          options = {\n            ...options,\n            ...parseJSONExtra(\n              checkArgOptions && argOptions ? argOptions : extraArgs\n            )\n          };\n        }\n      }\n    }\n    return options;\n  };\n\n  let expectsDatetime = false;\n  if (value && typeof value === 'object' && !Array.isArray(value)) {\n    const singleKey = Object.keys(value)[0];\n    if ([\n      'number', 'date', 'datetime', 'dateRange', 'datetimeRange', 'relative',\n      'region', 'language', 'script', 'currency',\n      'list', 'plural'\n    ].includes(singleKey)) {\n      let extraOpts, callback;\n      ({\n        value, options: opts, extraOpts, callback\n      } = getFormatterInfo({object: value[singleKey]}));\n\n      switch (singleKey) {\n      case 'date': case 'datetime':\n        expectsDatetime = true;\n        break;\n      case 'dateRange': case 'datetimeRange':\n        return new Intl.DateTimeFormat(\n          locale,\n          applyArgs({type: 'DATERANGE', options: extraOpts})\n        ).formatRange(...[value, opts].map((val) => {\n          return typeof val === 'number' ? new Date(val) : val;\n        }));\n      case 'region': case 'language': case 'script': case 'currency':\n        return new Intl.DisplayNames(\n          locale, {\n            ...applyArgs({type: singleKey.toUpperCase()}),\n            type: singleKey\n          }\n        ).of(value);\n      case 'relative':\n        // The second argument actually contains the primary options, so swap\n        [extraOpts, opts] = [opts, extraOpts];\n        return new Intl.RelativeTimeFormat(\n          locale, applyArgs({type: 'RELATIVE'})\n        ).format(value, extraOpts);\n\n      // ListFormat (with Collator)\n      case 'list':\n        if (callback) {\n          return sortList(\n            locale, value, callback,\n            applyArgs({type: 'LIST'}),\n            applyArgs({\n              type: 'LIST', options: extraOpts, checkArgOptions: true\n            })\n          );\n        }\n        return sortList(locale, value, applyArgs({type: 'LIST'}), applyArgs({\n          type: 'LIST', options: extraOpts, checkArgOptions: true\n        }));\n      default:\n        // Let `number` and `date` types drop through so their options\n        //  can be applied\n        // Let `plural` be treated as number (since value should be a number)\n        break;\n      }\n    }\n  }\n\n  // Dates\n  if (\n    value\n  ) {\n    if (\n      typeof value === 'number' &&\n      (expectsDatetime || (/^DATE(?:TIME)(?:\\||$)/u).test(arg))\n    ) {\n      value = new Date(value);\n    }\n    if (typeof value === 'object' && typeof value.getTime === 'function') {\n      return new Intl.DateTimeFormat(\n        locale,\n        applyArgs({type: 'DATETIME'})\n      ).format(value);\n    }\n  }\n\n  // Date range\n  if (Array.isArray(value)) {\n    const extraOpts = value[2];\n    return new Intl.DateTimeFormat(\n      locale,\n      applyArgs({type: 'DATERANGE', options: extraOpts})\n    ).formatRange(...value.slice(0, 2).map((val) => {\n      return typeof val === 'number' ? new Date(val) : val;\n    }));\n  }\n\n  // Numbers\n  if (typeof value === 'number') {\n    return new Intl.NumberFormat(\n      locale,\n      applyArgs({type: 'NUMBER'})\n    ).format(value);\n  }\n\n  // console.log('value', value);\n  throw new TypeError('Unknown formatter');\n};\n","import {getMessageForKeyByStyle} from './index.js';\nimport {parseJSONExtra} from './utils.js';\nimport {getFormatterInfo} from './defaultAllSubstitutions.js';\n\n/**\n * Base class for formatting.\n */\nexport class Formatter {\n}\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.key\n * @param {LocaleBody} cfg.body\n * @param {string} cfg.type\n * @param {\"richNested\"|\"rich\"|\"plain\"|\n *   \"plainNested\"|MessageStyleCallback} cfg.messageStyle\n * @returns {string|Element}\n */\nconst getSubstitution = ({key, body, type, messageStyle = 'richNested'}) => {\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const substitution = messageForKey({body}, key);\n  if (!substitution) {\n    throw new Error(`Key value not found for ${type} key: (${key})`);\n  }\n  // We don't allow a substitution function here or below as comes\n  //  from locale and locale content should not pose security concerns\n  return substitution.value;\n};\n\n/**\n * Formatter for local variables.\n */\nexport class LocalFormatter extends Formatter {\n  /**\n   * @param {LocalObject} locals\n   */\n  constructor (locals) {\n    super();\n    this.locals = locals;\n  }\n  /**\n   * @param {string} key\n   * @returns {string|Element}\n   */\n  getSubstitution (key) {\n    return getSubstitution({\n      key: key.slice(1), body: this.locals, type: 'local'\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    const components = key.slice(1).split('.');\n    let parent = this.locals;\n    return this.constructor.isMatchingKey(key) && components.every((cmpt) => {\n      const result = cmpt in parent;\n      parent = parent[cmpt];\n      return result;\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('-');\n  }\n}\n\n/**\n * Formatter for regular variables.\n */\nexport class RegularFormatter extends Formatter {\n  /**\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (substitutions) {\n    super();\n    this.substitutions = substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return this.constructor.isMatchingKey(key) && key in this.substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return (/^\\w/u).test(key);\n  }\n}\n\n/**\n * Formatter for switch variables.\n */\nexport class SwitchFormatter extends Formatter {\n  /**\n   * @param {Switches} switches\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (switches, {substitutions}) {\n    super();\n    this.switches = switches;\n    this.substitutions = substitutions;\n  }\n\n  /**\n   * @param {string} key\n   * @param {PlainObject} cfg\n   * @param {string} cfg.locale\n   * @param {string[]} cfg.usedKeys\n   * @param {string} cfg.arg\n   * @param {MissingSuppliedFormattersCallback} cfg.missingSuppliedFormatters\n   * @returns {string}\n   */\n  getSubstitution (key, {locale, usedKeys, arg, missingSuppliedFormatters}) {\n    const ky = this.constructor.getKey(key).slice(1);\n    // Expression might not actually use formatter, e.g., for singular,\n    //  the conditional might just write out \"one\"\n\n    const [objKey, body, keySegment] = this.getMatch(ky);\n    usedKeys.push(keySegment);\n\n    let type, opts;\n    if (objKey && objKey.includes('|')) {\n      [, type, opts] = objKey.split('|');\n    }\n    if (!body) {\n      missingSuppliedFormatters({\n        key,\n        formatter: this\n      });\n      return '\\\\{' + key + '}';\n    }\n\n    /*\n    if (!(ky in this.substitutions)) {\n      throw new Error(`Switch expecting formatter: ${ky}`);\n    }\n    */\n\n    const getNumberFormat = (value, defaultOptions) => {\n      const numberOpts = parseJSONExtra(opts);\n      return new Intl.NumberFormat(locale, {\n        ...defaultOptions, ...numberOpts\n      }).format(value);\n    };\n\n    const getPluralFormat = (value, defaultOptions) => {\n      const pluralOpts = parseJSONExtra(opts);\n      return new Intl.PluralRules(locale, {\n        ...defaultOptions, ...pluralOpts\n      }).select(value);\n    };\n\n    const formatterValue = this.substitutions[keySegment];\n\n    let match = formatterValue;\n    if (typeof formatterValue === 'number') {\n      switch (type) {\n      case 'NUMBER':\n        match = getNumberFormat(formatterValue);\n        break;\n      case 'PLURAL':\n        match = getPluralFormat(formatterValue);\n        break;\n      default:\n        match = new Intl.PluralRules(locale).select(formatterValue);\n        break;\n      }\n    } else if (formatterValue && typeof formatterValue === 'object') {\n      const singleKey = Object.keys(formatterValue)[0];\n      if (['number', 'plural'].includes(singleKey)) {\n        const {value, options} = getFormatterInfo({\n          object: formatterValue[singleKey]\n        });\n        if (!type) {\n          type = singleKey.toUpperCase();\n        }\n        const typeMatches = singleKey.toUpperCase() === type;\n        if (!typeMatches) {\n          throw new TypeError(\n            `Expecting type \"${\n              type.toLowerCase()\n            }\"; instead found \"${singleKey}\".`\n          );\n        }\n        // eslint-disable-next-line default-case\n        switch (type) {\n        case 'NUMBER':\n          match = getNumberFormat(value, options);\n          break;\n        case 'PLURAL':\n          match = getPluralFormat(value, options);\n          break;\n        }\n      }\n    }\n\n    // We do not want the default `richNested` here as that will split\n    //  up the likes of `0.0`\n    const messageStyle = 'richNested';\n\n    const preventNesting = (s) => {\n      return s.replace(/\\\\/gu, '\\\\\\\\').replace(/\\./gu, '\\\\.');\n    };\n\n    try {\n      return getSubstitution({\n        messageStyle,\n        key: match ? preventNesting(match) : arg,\n        body,\n        type: 'switch'\n      });\n    } catch (err) {\n      try {\n        return getSubstitution({\n          messageStyle, key: '*' + preventNesting(match), body, type: 'switch'\n        });\n      } catch (error) {\n        const k = Object.keys(body).find(\n          (switchKey) => switchKey.startsWith('*')\n        );\n        if (!k) {\n          throw new Error(`No defaults found for switch ${ky}`);\n        }\n        return getSubstitution({\n          messageStyle, key: preventNesting(k), body, type: 'switch'\n        });\n      }\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return key && this.constructor.isMatchingKey(key) &&\n      Boolean(this.getMatch(key.slice(1)).length);\n  }\n\n  /**\n  * @typedef {GenericArray} SwitchMatch\n  * @property {string} 0 objKey\n  * @property {LocaleBody} 1 body\n  * @property {string} 2 keySegment\n  */\n\n  /**\n   * @param {string} ky\n   * @returns {SwitchMatch}\n   */\n  getMatch (ky) {\n    const ks = ky.split('.');\n    return ks.reduce((obj, k, i) => {\n      if (i < ks.length - 1) {\n        if (!(k in obj)) {\n          throw new Error(`Switch key \"${k}\" not found (from \"~${ky}\")`);\n        }\n        return obj[k];\n      }\n      // Todo: Should throw on encountering duplicate fundamental keys (even\n      //  if there are different arguments, that should not be allowed)\n      const ret = Object.entries(obj).find(([switchKey]) => {\n        return k === this.constructor.getKey(switchKey);\n      });\n\n      return ret ? [...ret, k] : [];\n    }, this.switches);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('~');\n  }\n  /**\n   * @param {string} key\n   * @returns {string}\n   */\n  static getKey (key) {\n    const match = key.match(/^[^|]*/u);\n    return match && match[0];\n  }\n}\n","/**\n* @callback PromiseChainErrback\n* @param {(value: any) => Promise<any>} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @param {string} [errorMessage=\"Reached end of values array.\"]\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\npromiseChainForValues(['a', 'b', 'c'], (val) => {\n  return new Promise(function (resolve, reject) {\n    if (val === 'a') {\n      reject(new Error('missing'));\n    }\n    setTimeout(() => {\n      resolve(val);\n    }, 100);\n  });\n});\n */\nexport const promiseChainForValues = (\n  values, errBack, errorMessage = 'Reached end of values array.'\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(\n      'The `values` argument to `promiseChainForValues` must be an array.'\n    );\n  }\n  if (typeof errBack !== 'function') {\n    throw new TypeError(\n      'The `errBack` argument to `promiseChainForValues` must be a function.'\n    );\n  }\n  return (async () => {\n    let ret;\n    let p = Promise.reject(\n      new Error('Intentionally reject so as to begin checking chain')\n    );\n    let breaking;\n    while (true) {\n      const value = values.shift();\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        ret = await p;\n        break;\n      } catch (err) {\n        if (breaking) {\n          throw new Error(errorMessage);\n        }\n        // We allow one more try\n        if (!values.length) {\n          breaking = true;\n        }\n        // // eslint-disable-next-line no-await-in-loop\n        p = errBack(value);\n      }\n    }\n    return ret;\n  })();\n};\n","/**\n* @callback SubstitutionCallback\n* @param {PlainObject} cfg\n* @param {string} cfg.arg By default, accepts the third portion of the\n*   `formattingRegex` within `insertNodes`, i.e., to allow the locale to\n*   supply arguments back to the calling script.\n* @param {string} cfg.key The substitution key\n* @returns {string|Element} The replacement text or element\n*/\n\n/**\n * May have additional properties if supplying options to an underlying\n * formatter.\n * @typedef {GenericArray} ValueArray\n * @property {string|Node|number|Date} 0 The main value\n * @property {PlainObject} [1] The options related to the main value\n * @property {PlainObject} [2] Any additional options\n*/\n\n/**\n* @typedef {PlainObject} RelativeTimeInfo\n* @property {ValueArray} relative\n*/\n\n/**\n* @typedef {PlainObject} ListInfo\n* @property {ValueArray} list\n*/\n\n/**\n* @typedef {PlainObject} NumberInfo\n* @property {ValueArray} number\n*/\n\n/**\n* @typedef {PlainObject} DateInfo\n* @property {ValueArray} date\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringBodyObject\n*/\n\n/**\n* @typedef {PlainObject} SwitchCaseInfo\n* @property {boolean} [default=false] Whether this conditional is the default\n*/\n\n/**\n* @typedef {GenericArray} SwitchCase\n* @property {string} 0 The type\n* @property {string} 1 The message\n* @property {SwitchCaseInfo} [2] Info about the switch case\n*/\n\n/**\n* @typedef {PlainObject<string, SwitchCase>} Switch\n*/\n\n/**\n* @typedef {PlainObject<{string, Switch}>} Switches\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} [message] The locale message with any formatting\n*   place-holders; defaults to use of any single conditional\n* @property {string} [description] A description to add translators\n* @property {Switches} [switches] Conditionals\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringBodyObject\n*/\n\n/**\n * Takes a base path and locale and gives a URL.\n * @callback LocaleResolver\n * @param {string} localesBasePath (Trailing slash optional)\n * @param {string} locale BCP-47 language string\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|\n* SubstitutionCallback>} SubstitutionObject\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (localesBasePath, locale) => {\n  if (typeof localesBasePath !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `localesBasePath`.'\n    );\n  }\n  if (typeof locale !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `locale`.'\n    );\n  }\n  if ((/[./\\\\]/u).test(locale)) {\n    throw new TypeError(\n      'Locales cannot use file-reserved characters, `.`, `/` or `\\\\`'\n    );\n  }\n  return `${localesBasePath.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n","import {\n  LocalFormatter, RegularFormatter, SwitchFormatter\n} from './Formatter.js';\nimport {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {unescapeBackslashes, parseJSONExtra, processRegex} from './utils.js';\n\n/* eslint-disable max-len */\n/**\n * Callback to return a string or array of nodes and strings based on a localized\n * string, substitutions object, and other metadata.\n * @callback InsertNodesCallback\n * @param {PlainObject} cfg\n * @param {string} cfg.string The localized string\n * @param {boolean} [cfg.dom] If substitutions known to contain DOM, can be set\n *   to `true` to optimize\n * @param {string[]} [cfg.usedKeys=[]] Array for tracking which keys have been used\n * @param {SubstitutionObject} cfg.substitutions The formatting substitutions object\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions] The\n *   callback or array composed thereof for applying to each substitution.\n * @param {string} locale The successfully resolved locale\n * @param {Integer} [maximumLocalNestingDepth=3] Depth of local variable resolution to\n *   check before reporting a recursion error\n * @param {MissingSuppliedFormattersCallback} [cfg.missingSuppliedFormatters] Callback\n *   supplied key to throw if the supplied key is present (if\n *   `throwOnMissingSuppliedFormatters` is enabled). Defaults to no-op.\n * @param {CheckExtraSuppliedFormattersCallback} [cfg.checkExtraSuppliedFormatters] No\n *   argument callback to check if any formatters are not present in `string`\n *   (if `throwOnExtraSuppliedFormatters` is enabled). Defaults to no-op.\n * @returns {string|Array<Node|string>}\n */\n\n/**\n * @type {InsertNodesCallback}\n */\nexport const defaultInsertNodes = ({\n  /* eslint-enable max-len */\n  string, dom, usedKeys, substitutions, allSubstitutions, locale,\n  locals, switches,\n  maximumLocalNestingDepth = 3,\n  missingSuppliedFormatters,\n  checkExtraSuppliedFormatters\n}) => {\n  if (typeof maximumLocalNestingDepth !== 'number') {\n    throw new TypeError('`maximumLocalNestingDepth` must be a number.');\n  }\n\n  const addFunctionKeys = () => {\n    Object.entries(substitutions).forEach(([key, value]) => {\n      if (typeof value === 'function') {\n        usedKeys.push(key);\n      }\n    });\n  };\n  addFunctionKeys();\n\n  const localFormatter = new LocalFormatter(locals);\n  const regularFormatter = new RegularFormatter(substitutions);\n  const switchFormatter = new SwitchFormatter(switches, {substitutions});\n\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  const formattingRegex = /(\\\\*)\\{((?:[^}]|\\\\\\})*?)(?:(\\|)([^}]*))?\\}/gu;\n  if (allSubstitutions) {\n    allSubstitutions = Array.isArray(allSubstitutions)\n      ? allSubstitutions\n      : [allSubstitutions];\n  }\n\n  const getSubstitution = ({key, arg, substs}) => {\n    let substitution;\n    const isLocalKey = localFormatter.constructor.isMatchingKey(key);\n    if (isLocalKey) {\n      substitution = localFormatter.getSubstitution(key);\n    } else if (switchFormatter.constructor.isMatchingKey(key)) {\n      substitution = switchFormatter.getSubstitution(key, {\n        locale, usedKeys, arg,\n        missingSuppliedFormatters\n      });\n    } else {\n      substitution = substs[key];\n      if (typeof substitution === 'function') {\n        substitution = substitution({arg, key});\n      }\n    }\n    // Todo: Could support resolving locals within arguments\n    // Todo: Even for `null` `allSubstitutions`, we could have\n    //  a mode to throw for non-string/non-DOM (non-numbers?),\n    //  or whatever is not likely intended as a target for `toString()`.\n    if (allSubstitutions) {\n      substitution = allSubstitutions.reduce((subst, allSubst) => {\n        return allSubst({\n          value: subst, arg, key, locale\n        });\n      }, substitution);\n    } else if (arg && (/^(?:NUMBER|DATE(?:TIME|RANGE|TIMERANGE)?|REGION|LANGUAGE|SCRIPT|CURRENCY|RELATIVE|LIST)(?:\\||$)/u).test(arg)) {\n      substitution = defaultAllSubstitutions({\n        value: substitution, arg, key, locale\n      });\n    }\n    return substitution;\n  };\n\n  let recursiveLocalCount = 1;\n  const checkLocalVars = ({substitution, ky, arg, processSubsts}) => {\n    if (\n      typeof substitution === 'string' &&\n      substitution.includes('{')\n    ) {\n      if (recursiveLocalCount++ > maximumLocalNestingDepth) {\n        throw new TypeError('Too much recursion in local variables.');\n      }\n\n      if (localFormatter.constructor.isMatchingKey(ky)) {\n        let extraSubsts = substitutions;\n        let localFormatters;\n        if (arg) {\n          localFormatters = parseJSONExtra(arg);\n          extraSubsts = {\n            ...substitutions,\n            ...localFormatters\n          };\n        }\n        substitution = processSubsts({\n          str: substitution, substs: extraSubsts,\n          formatter: localFormatter\n        });\n        if (localFormatters) {\n          checkExtraSuppliedFormatters({substitutions: localFormatters});\n        }\n      } else if (switchFormatter.constructor.isMatchingKey(ky)) {\n        substitution = processSubsts({\n          str: substitution\n        });\n      }\n    }\n    return substitution;\n  };\n\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    // Run this block to optimize non-DOM substitutions\n    let returnsDOM = false;\n    const replace = ({\n      str, substs = substitutions,\n      formatter = regularFormatter\n    }) => {\n      return str.replace(formattingRegex, (_, esc, ky, pipe, arg) => {\n        if (esc.length % 2) {\n          return _;\n        }\n        if (missingSuppliedFormatters({\n          key: ky,\n          formatter\n        })) {\n          return _;\n        }\n        let substitution = getSubstitution({key: ky, arg, substs});\n\n        substitution = checkLocalVars({\n          substitution, ky, arg, processSubsts: replace\n        });\n\n        returnsDOM = returnsDOM ||\n          (substitution && typeof substitution === 'object' &&\n          'nodeType' in substitution);\n        usedKeys.push(ky);\n        return esc + substitution;\n      });\n    };\n    const ret = replace({str: string});\n    if (!returnsDOM) {\n      checkExtraSuppliedFormatters({substitutions});\n      usedKeys.length = 0;\n      addFunctionKeys();\n      return unescapeBackslashes(ret);\n    }\n    usedKeys.length = 0;\n    addFunctionKeys();\n  }\n\n  recursiveLocalCount = 1;\n  const processSubstitutions = ({\n    str, substs = substitutions, formatter = regularFormatter\n  }) => {\n    const nodes = [];\n\n    // Copy to ensure we are resetting index on each instance (manually\n    // resetting on `formattingRegex` is problematic with recursion that\n    // uses the same regex copy)\n    const regex = new RegExp(formattingRegex, 'gu');\n\n    const push = (...args) => {\n      nodes.push(...args);\n    };\n\n    processRegex(regex, str, {\n      extra: push,\n      onMatch (_, esc, ky, pipe, arg) {\n        if (missingSuppliedFormatters({\n          key: ky, formatter\n        })) {\n          push(_);\n        } else {\n          if (esc.length) {\n            push(esc);\n          }\n\n          let substitution = getSubstitution({key: ky, arg, substs});\n          substitution = checkLocalVars({\n            substitution, ky, arg, processSubsts: processSubstitutions\n          });\n          if (Array.isArray(substitution)) {\n            push(...substitution);\n          } else if (\n            // Clone so that multiple instances may be added (and no\n            // side effects to user code)\n            substitution && typeof substitution === 'object' &&\n            'nodeType' in substitution\n          ) {\n            push(substitution.cloneNode(true));\n          } else {\n            push(substitution);\n          }\n        }\n        usedKeys.push(ky);\n      }\n    });\n    return nodes;\n  };\n  const nodes = processSubstitutions({str: string});\n\n  checkExtraSuppliedFormatters({substitutions});\n  usedKeys.length = 0;\n  return nodes.map((node) => {\n    if (typeof node === 'string') {\n      return unescapeBackslashes(node);\n    }\n    return node;\n  });\n};\n","/**\n * @callback KeyCheckerConverterCallback\n * @param {string|string[]} key By default may be an array (if the type ends\n *   with \"Nested\") or a string, but a non-default validator may do otherwise.\n * @param {\"plain\"|\"plainNested\"|\"rich\"|\n *   \"richNested\"|MessageStyleCallback} messageStyle\n * @throws {TypeError}\n * @returns {string} The converted (or unconverted) key\n */\n\n/**\n * @type {KeyCheckerConverterCallback}\n */\nexport function defaultKeyCheckerConverter (key, messageStyle) {\n  if (Array.isArray(key) &&\n    key.every((k) => {\n      return typeof k === 'string';\n    }) &&\n    typeof messageStyle === 'string' && messageStyle.endsWith('Nested')\n  ) {\n    return key.map((k) => {\n      return k\n        .replace(/(?<backslashes>\\\\+)/gu, '\\\\$<backslashes>')\n        .replace(/\\./gu, '\\\\.');\n    }).join('.');\n  }\n  if (typeof key !== 'string') {\n    throw new TypeError(\n      '`key` is expected to be a string (or array of strings for nested style)'\n    );\n  }\n\n  return key;\n}\n","import {unescapeBackslashes, processRegex} from './utils.js';\n\n/**\n* @typedef {LocaleBody} LocalObject\n*/\n\n/**\n * May also contain language code and direction, translator name and\n * contact, etc., but no defaults currently apply besides reserving `locals`\n * @typedef {PlainObject} LocaleHead\n * @property {LocalObject} locals\n*/\n\n/**\n* @typedef {LocaleStringBodyObject|\n* PlainLocaleStringBodyObject|PlainObject} LocaleBody\n*/\n\n/**\n* @typedef {PlainObject} LocaleObject\n* @property {LocaleHead} [head]\n* @property {LocaleBody} body\n*/\n\n/**\n* @typedef {PlainObject} MessageStyleCallbackResult\n* @property {string} value Regardless of message style, will contain the\n*   string result\n* @property {LocaleStringSubObject} [info] Full info on the localized item\n*   (for rich message styles only)\n*/\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|MessageStyleCallbackResult} If `false`, will resort to default\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg]\n * @param {\"richNested\"|\"rich\"|\"plain\"|\"plainNested\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  /* eslint-enable max-len */\n  messageStyle = 'richNested'\n} = {}) => {\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'richNested'\n      ? (mainObj, key) => {\n        const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n        const keys = [];\n        // eslint-disable-next-line prefer-named-capture-group\n        const possiblyEscapedCharPattern = /(\\\\*)\\./gu;\n        const mergeWithPreviousOrStart = (val) => {\n          if (!keys.length) {\n            keys[0] = '';\n          }\n          keys[keys.length - 1] += val;\n        };\n        processRegex(possiblyEscapedCharPattern, key, {\n          // If odd, this is just an escaped dot, so merge content with\n          //   any previous\n          extra: mergeWithPreviousOrStart,\n          onMatch (_, esc) {\n            // If even, there are no backslashes, or they are just escaped\n            //  backslashes and not an escaped dot, so start anew, though\n            //  first merge any backslashes\n            mergeWithPreviousOrStart(esc);\n            keys.push('');\n          }\n        });\n        const keysUnescaped = keys.map((ky) => {\n          return unescapeBackslashes(ky);\n        });\n\n        let ret = false;\n        let currObj = obj;\n        keysUnescaped.some((ky, i, kys) => {\n          if (!currObj || typeof currObj !== 'object') {\n            return true;\n          }\n          if (\n            // If specified key is too deep, we should fail\n            i === kys.length - 1 &&\n            ky in currObj && currObj[ky] && typeof currObj[ky] === 'object' &&\n            'message' in currObj[ky] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof currObj[ky].message === 'string'\n          ) {\n            ret = {\n              value: currObj[ky].message,\n              info: currObj[ky]\n            };\n          }\n          currObj = currObj[ky];\n\n          return false;\n        });\n        return ret;\n      }\n      : (messageStyle === 'rich'\n        ? (mainObj, key) => {\n          const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n          if (\n            obj && typeof obj === 'object' &&\n            key in obj && obj[key] && typeof obj[key] === 'object' &&\n            'message' in obj[key] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof obj[key].message === 'string'\n          ) {\n            return {\n              value: obj[key].message,\n              info: obj[key]\n            };\n          }\n          return false;\n        }\n        : (messageStyle === 'plain'\n          ? (mainObj, key) => {\n            const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n            if (\n              obj && typeof obj === 'object' &&\n              key in obj && obj[key] && typeof obj[key] === 'string'\n            ) {\n              return {\n                value: obj[key]\n              };\n            }\n            return false;\n          }\n          : (messageStyle === 'plainNested'\n            ? (mainObj, key) => {\n              const obj = mainObj && typeof mainObj === 'object' &&\n                mainObj.body;\n              if (obj && typeof obj === 'object') {\n                // Should really be counting that it is an odd number\n                //  of backslashes only\n                const keys = key.split(/(?<!\\\\)\\./u);\n                const value = keys.reduce((o, k) => {\n                  if (o && o[k]) {\n                    return o[k];\n                  }\n                  return null;\n                }, obj);\n                if (value && typeof value === 'string') {\n                  return {value};\n                }\n              }\n              return false;\n            }\n            : (() => {\n              throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n            })()))\n      )\n    );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message] If present, this string will be the return value.\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {\"richNested\"|\"rich\"|\"plain\"|\"plainNested\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings; used to find a default if no string `message` is provided.\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n} = {}) => {\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  let str;\n  if (typeof message === 'string') {\n    str = message;\n  } else if (\n    defaults === false || defaults === undefined || defaults === null\n  ) {\n    str = false;\n  } else if (defaults && typeof defaults === 'object') {\n    str = messageForKey(defaults, key);\n    if (str) {\n      str = str.value;\n    }\n  } else {\n    throw new TypeError(\n      `Default locale strings must resolve to \\`false\\`, ` +\n      `nullish, or an object!`\n    );\n  }\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n","import {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {defaultInsertNodes} from './defaultInsertNodes.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/* eslint-disable max-len */\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {string} cfg.locale The (possibly already resolved) locale for use by\n *   configuring formatters\n * @param {LocalObject} [cfg.locals]\n * @param {LocalObject} [cfg.switches]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions=[defaultAllSubstitutions]]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  /* eslint-enable max-len */\n  string,\n  locale,\n  locals,\n  switches,\n  maximumLocalNestingDepth,\n  allSubstitutions = [\n    defaultAllSubstitutions\n  ],\n  insertNodes = defaultInsertNodes,\n  substitutions = false,\n  dom = false,\n  forceNodeReturn = false,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true\n} = {}) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'An options object with a `string` property set to a string must ' +\n      'be provided for `getDOMForLocaleString`.'\n    );\n  }\n  const stringOrTextNode = (str) => {\n    const _doc = getDocument();\n    return forceNodeReturn ? _doc.createTextNode(str) : str;\n  };\n\n  const usedKeys = [];\n\n  /**\n  * @callback CheckExtraSuppliedFormattersCallback\n  * @param {SubstitutionObject} substs\n  * @throws {Error} Upon an extra formatting key being found\n  * @returns {void}\n  */\n\n  /**\n   * @type {CheckExtraSuppliedFormattersCallback}\n   */\n  const checkExtraSuppliedFormatters = ({\n    substitutions: substs\n  }) => {\n    if (throwOnExtraSuppliedFormatters) {\n      Object.keys(substs).forEach((key) => {\n        if (!usedKeys.includes(key)) {\n          throw new Error(`Extra formatting key: ${key}`);\n        }\n      });\n    }\n  };\n\n  /**\n  * @callback MissingSuppliedFormattersCallback\n  * @param {string} key\n  * @param {SubstitutionObject} substs\n  * @throws {Error} If missing formatting key\n  * @returns {boolean}\n  */\n  /**\n   * @type {MissingSuppliedFormattersCallback}\n   */\n  const missingSuppliedFormatters = ({\n    key, formatter\n  }) => {\n    const matching = formatter.isMatch(key);\n    if (formatter.constructor.isMatchingKey(key) && !matching) {\n      if (throwOnMissingSuppliedFormatters) {\n        throw new Error(`Missing formatting key: ${key}`);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  if (\n    !substitutions && !allSubstitutions &&\n    !throwOnMissingSuppliedFormatters\n  ) {\n    return stringOrTextNode(string);\n  }\n  if (!substitutions) {\n    substitutions = {};\n  }\n\n  const nodes = insertNodes({\n    string, dom, usedKeys, substitutions, allSubstitutions, locale,\n    locals, switches,\n    missingSuppliedFormatters,\n    checkExtraSuppliedFormatters\n  });\n  if (typeof nodes === 'string') {\n    return stringOrTextNode(nodes);\n  }\n\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n\n  return container;\n};\n","/* globals intlDomLocale */\n\nimport {defaultLocaleResolver} from './defaultLocaleResolver.js';\nimport {promiseChainForValues} from './promiseChainForValues.js';\nimport {getFetch} from './shared.js';\n\nexport {setFetch, getFetch} from './shared.js';\n\n/**\n * Takes a locale and returns a new locale to check.\n * @callback LocaleMatcher\n * @param {string} locale The failed locale\n * @throws {Error} If there are no further hyphens left to check\n * @returns {string|Promise<string>} The new locale to check\n*/\n\n/**\n * @type {LocaleMatcher}\n */\nexport const defaultLocaleMatcher = (locale) => {\n  if (!locale.includes('-')) {\n    throw new Error('Locale not available');\n  }\n  // Try without hyphen, i.e., the \"lookup\" algorithm:\n  // See https://tools.ietf.org/html/rfc4647#section-3.4 and\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\n  return locale.replace(/-[^-]*$/u, '');\n};\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.locale\n * @param {string[]} cfg.locales\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleMatcher]\n * @returns {string|false}\n */\nexport const getMatchingLocale = ({\n  locale, locales, localeResolver = defaultLocaleMatcher\n}) => {\n  try {\n    while (!locales.includes(locale)) {\n      // Catch as `defaultLocaleMatcher` will throw if no hyphen found\n      locale = localeResolver(locale);\n    }\n  } catch (err) {\n    return false;\n  }\n  return locale;\n};\n\n/**\n* @typedef {PlainObject} LocaleObjectInfo\n* @property {LocaleObject} strings The successfully retrieved locale strings\n* @property {string} locale The successfully resolved locale\n*/\n\n/**\n * @callback LocaleStringFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<LocaleObjectInfo>}\n */\n\n/**\n *\n * @type {LocaleStringFinder}\n */\nexport const findLocaleStrings = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n};\n\n/**\n * @callback LocaleFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<string>} Resolves to the successfully resolved locale\n */\n\n/**\n *\n * @type {LocaleFinder}\n */\nexport const findLocale = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher,\n    headOnly: true\n  });\n};\n\n/**\n * @type {LocaleStringFinder|LocaleFinder} Also has a `headOnly` boolean\n *  property to determine whether to make a simple HEAD and resolve to\n *  the locale rather than locale and contents\n */\nconst _findLocale = async ({\n  locales = typeof intlDomLocale !== 'undefined'\n    ? [intlDomLocale]\n    : typeof navigator === 'undefined' ? [] : navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.',\n  localeMatcher = 'lookup',\n  headOnly = false\n}) => {\n  /**\n   * @callback getLocale\n   * @throws {SyntaxError|TypeError|Error}\n   * @param {string} locale\n   * @returns {Promise<LocaleObjectInfo>}\n   */\n  async function getLocale (locale) {\n    if (typeof locale !== 'string') {\n      throw new TypeError('Non-string locale type');\n    }\n    const url = localeResolver(localesBasePath, locale);\n    if (typeof url !== 'string') {\n      throw new TypeError(\n        '`localeResolver` expected to resolve to (URL) string.'\n      );\n    }\n    try {\n      const _fetch = getFetch();\n      const resp = await (headOnly\n        ? _fetch(url, {\n          method: 'HEAD'\n        })\n        : _fetch(url)\n      );\n\n      if (resp.status === 404) {\n        // Don't allow browser (tested in Firefox) to continue\n        //  and give `SyntaxError` with missing file or we won't be\n        //  able to try without the hyphen\n        throw new Error('Trying again');\n      }\n      if (headOnly) {\n        return locale;\n      }\n      const strings = await (resp.json());\n      return {\n        locale,\n        strings\n      };\n    } catch (err) {\n      if (err.name === 'SyntaxError') {\n        throw err;\n      }\n      const newLocale = await localeMatcher(locale);\n      return getLocale(newLocale);\n    }\n  }\n  if (localeMatcher === 'lookup') {\n    localeMatcher = defaultLocaleMatcher;\n  } else if (typeof localeMatcher !== 'function') {\n    throw new TypeError('`localeMatcher` must be \"lookup\" or a function!');\n  }\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    getLocale,\n    'No matching locale found for ' + [...locales, ...defaultLocales].join(', ')\n  );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\nimport {findLocaleStrings} from './findLocaleStrings.js';\nimport {getDOMForLocaleString} from './getDOMForLocaleString.js';\nimport {\n  getStringFromMessageAndDefaults\n} from './getStringFromMessageAndDefaults.js';\nimport {sort, sortList, list} from './collation.js';\nimport {defaultKeyCheckerConverter} from './defaultKeyCheckerConverter.js';\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present.\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {LocaleObject} cfg.strings\n * @param {string} cfg.resolvedLocale\n * @param {\"richNested\"|\"rich\"|\"plain\"|\"plainNested\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {KeyCheckerConverterCallback} [cfg.keyCheckerConverter]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18nServer = function i18nServer ({\n  /* eslint-enable max-len */\n  strings,\n  resolvedLocale,\n  messageStyle = 'richNested',\n  allSubstitutions: defaultAllSubstitutionsValue,\n  insertNodes,\n  keyCheckerConverter = defaultKeyCheckerConverter,\n  defaults: defaultDefaults,\n  substitutions: defaultSubstitutions,\n  maximumLocalNestingDepth,\n  dom: domDefaults = false,\n  forceNodeReturn: forceNodeReturnDefault = false,\n  throwOnMissingSuppliedFormatters:\n    throwOnMissingSuppliedFormattersDefault = true,\n  throwOnExtraSuppliedFormatters:\n    throwOnExtraSuppliedFormattersDefault = true\n}) {\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const formatter = (key, substitutions, {\n    allSubstitutions = defaultAllSubstitutionsValue,\n    defaults = defaultDefaults,\n    dom = domDefaults,\n    forceNodeReturn = forceNodeReturnDefault,\n    throwOnMissingSuppliedFormatters = throwOnMissingSuppliedFormattersDefault,\n    throwOnExtraSuppliedFormatters = throwOnExtraSuppliedFormattersDefault\n  } = {}) => {\n    key = keyCheckerConverter(key, messageStyle);\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message: message && typeof message.value === 'string'\n        ? message.value\n        : false,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      locals: strings.head && strings.head.locals,\n      switches: strings.head && strings.head.switches,\n      locale: resolvedLocale,\n      maximumLocalNestingDepth,\n      allSubstitutions,\n      insertNodes,\n      substitutions: {...defaultSubstitutions, ...substitutions},\n      dom,\n      forceNodeReturn,\n      throwOnMissingSuppliedFormatters,\n      throwOnExtraSuppliedFormatters\n    });\n  };\n\n  formatter.resolvedLocale = resolvedLocale;\n  formatter.strings = strings;\n\n  formatter.sort = (...args) => {\n    return sort(resolvedLocale, ...args);\n  };\n\n  formatter.sortList = (...args) => {\n    return sortList(\n      resolvedLocale, ...args\n    );\n  };\n\n  formatter.list = (...args) => {\n    return list(\n      resolvedLocale, ...args\n    );\n  };\n\n  return formatter;\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {LocaleStringFinder} [cfg.localeStringFinder=findLocaleStrings]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher=\"lookup\"]\n * @param {\"richNested\"|\"rich\"|\"plain\"|\"plainNested\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {KeyCheckerConverterCallback} [cfg.keyCheckerConverter]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localeStringFinder = findLocaleStrings,\n  localesBasePath,\n  localeResolver,\n  localeMatcher,\n  messageStyle,\n  allSubstitutions,\n  insertNodes,\n  keyCheckerConverter,\n  defaults,\n  substitutions,\n  maximumLocalNestingDepth,\n  dom,\n  forceNodeReturn,\n  throwOnMissingSuppliedFormatters,\n  throwOnExtraSuppliedFormatters\n} = {}) {\n  const {strings, locale: resolvedLocale} = await localeStringFinder({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n  if (!defaults && defaultLocales) {\n    let defaultLocale;\n    ({strings: defaults, locale: defaultLocale} = await localeStringFinder({\n      locales: defaultLocales,\n      defaultLocales: [],\n      localeResolver, localesBasePath, localeMatcher\n    }));\n    if (defaultLocale === resolvedLocale) {\n      defaults = null; // No need to fall back\n    }\n  }\n\n  return i18nServer({\n    strings,\n    resolvedLocale,\n    messageStyle,\n    allSubstitutions,\n    insertNodes,\n    keyCheckerConverter,\n    defaults,\n    substitutions,\n    maximumLocalNestingDepth,\n    dom,\n    forceNodeReturn,\n    throwOnMissingSuppliedFormatters,\n    throwOnExtraSuppliedFormatters\n  });\n};\n"],"names":["_jsonExtra","globalThis","jsonExtra","setJSONExtra","__jsonExtra","unescapeBackslashes","str","replace","esc","slice","length","parseJSONExtra","args","parse","processRegex","regex","_ref","match","onMatch","extra","betweenMatches","afterMatch","escapeAtOne","previousIndex","exec","_match2","_slicedToArray","_","lastIndex","startMatchPos","apply","_toConsumableArray","_fetch","fetch","setFetch","f","getFetch","_doc","document","setDocument","doc","getDocument","sort","locale","arrayOfItems","options","Intl","Collator","compare","list","ListFormat","format","sortList","map","listOptions","collationOptions","sortListSimple","d","randomId","Date","now","performance","c","r","Math","trunc","random","floor","toString","placeholderArray","i","concat","nodes","push","arguments","RegExp","idx","container","createDocumentFragment","append","getFormatterInfo","object","Array","isArray","_object","value","callback","extraOpts","_object2","defaultAllSubstitutions","_ref2","_Intl$DateTimeFormat","arg","key","opts","_typeof","applyArgs","_ref3","type","_ref3$options","_ref3$checkArgOptions","checkArgOptions","_arg$split2","split","userType","extraArgs","argOptions","_objectSpread","expectsDatetime","singleKey","Object","keys","includes","_getFormatterInfo","DateTimeFormat","formatRange","val","DisplayNames","toUpperCase","of","_ref4","RelativeTimeFormat","test","getTime","_Intl$DateTimeFormat2","NumberFormat","TypeError","Formatter","_createClass","_classCallCheck","getSubstitution","body","_ref$messageStyle","messageStyle","substitution","getMessageForKeyByStyle","messageForKey","Error","LocalFormatter","_Formatter","_inherits","_super","_createSuper","locals","_this","call","this","components","parent","constructor","isMatchingKey","every","cmpt","result","startsWith","RegularFormatter","_Formatter2","_super2","substitutions","_this2","SwitchFormatter","_Formatter3","_super3","switches","_this3","usedKeys","missingSuppliedFormatters","ky","getKey","_this$getMatch2","getMatch","objKey","keySegment","_objKey$split2","formatter","getNumberFormat","defaultOptions","numberOpts","getPluralFormat","pluralOpts","PluralRules","select","formatterValue","toLowerCase","preventNesting","s","err","error","k","find","switchKey","Boolean","_this4","ks","reduce","obj","ret","entries","_settle","pact","state","_Pact","o","bind","v","then","observer","prototype","onFulfilled","onRejected","e","_isSettledPact","thenable","promiseChainForValues","values","errBack","errorMessage","undefined","breaking","_interrupt","p","Promise","reject","update","stage","shouldContinue","updateValue","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","_for","shift","recover","_catch","direct","resolve","_await","_p","_result2","defaultLocaleResolver","localesBasePath","defaultInsertNodes","string","dom","allSubstitutions","_ref$maximumLocalNest","maximumLocalNestingDepth","checkExtraSuppliedFormatters","addFunctionKeys","forEach","localFormatter","regularFormatter","switchFormatter","formattingRegex","substs","subst","allSubst","recursiveLocalCount","checkLocalVars","_ref5","processSubsts","localFormatters","extraSubsts","returnsDOM","_ref6","_ref6$substs","_ref6$formatter","pipe","processSubstitutions","_ref7","_ref7$substs","_ref7$formatter","cloneNode","node","defaultKeyCheckerConverter","endsWith","_wrapRegExp","backslashes","join","mainObj","mergeWithPreviousOrStart","keysUnescaped","currObj","some","kys","message","info","getStringFromMessageAndDefaults","defaults","_ref$messageForKey","getDOMForLocaleString","_ref$allSubstitutions","_ref$insertNodes","insertNodes","_ref$substitutions","_ref$dom","_ref$forceNodeReturn","forceNodeReturn","_ref$throwOnMissingSu","throwOnMissingSuppliedFormatters","_ref$throwOnExtraSupp","throwOnExtraSuppliedFormatters","stringOrTextNode","createTextNode","matching","isMatch","_async","defaultLocaleMatcher","getMatchingLocale","locales","_ref$localeResolver","localeResolver","findLocaleStrings","defaultLocales","localeMatcher","_findLocale","findLocale","headOnly","getLocale","url","method","resp","status","json","strings","name","_ref4$locales","intlDomLocale","navigator","languages","_ref4$defaultLocales","_ref4$localeResolver","_ref4$localesBasePath","_ref4$localeMatcher","_ref4$headOnly","i18nServer","resolvedLocale","defaultAllSubstitutionsValue","_ref$keyCheckerConver","keyCheckerConverter","defaultDefaults","defaultSubstitutions","domDefaults","forceNodeReturnDefault","throwOnMissingSuppliedFormattersDefault","throwOnExtraSuppliedFormattersDefault","_ref2$allSubstitution","_ref2$defaults","_ref2$dom","_ref2$forceNodeReturn","_ref2$throwOnMissingS","_ref2$throwOnExtraSup","head","_len","_key","_len2","_key2","_len3","_key3","i18n","_ref3$localeStringFin","localeStringFinder","_localeStringFinder"],"mappings":"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"}