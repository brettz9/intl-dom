{"version":3,"file":"index.umd.min.js","sources":["../node_modules/json-6/dist/index.mjs","../src/utils.js","../src/shared.js","../src/collation.js","../src/defaultAllSubstitutions.js","../src/Formatter.js","../src/promiseChainForValues.js","../src/defaultLocaleResolver.js","../src/defaultInsertNodes.js","../src/getMessageForKeyByStyle.js","../src/getStringFromMessageAndDefaults.js","../src/getDOMForLocaleString.js","../src/findLocaleStrings.js","../src/i18n.js"],"sourcesContent":["function createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar json6 = createCommonjsModule(function (module, exports) {\n\nconst VALUE_UNDEFINED = -1;\nconst VALUE_UNSET = 0;\nconst VALUE_NULL = 1;\nconst VALUE_TRUE = 2;\nconst VALUE_FALSE = 3;\nconst VALUE_STRING = 4;\nconst VALUE_NUMBER = 5;\nconst VALUE_OBJECT = 6;\nconst VALUE_ARRAY = 7;\nconst VALUE_NEG_NAN = 8;\nconst VALUE_NAN = 9;\nconst VALUE_NEG_INFINITY = 10;\nconst VALUE_INFINITY = 11;\nconst VALUE_EMPTY = 13; // [,] makes an array with 'empty item'\n\nconst WORD_POS_RESET = 0;\nconst WORD_POS_TRUE_1 = 1;\nconst WORD_POS_TRUE_2 = 2;\nconst WORD_POS_TRUE_3 = 3;\nconst WORD_POS_FALSE_1 = 5;\nconst WORD_POS_FALSE_2 = 6;\nconst WORD_POS_FALSE_3 = 7;\nconst WORD_POS_FALSE_4 = 8;\nconst WORD_POS_NULL_1 = 9;\nconst WORD_POS_NULL_2 = 10;\nconst WORD_POS_NULL_3 = 11;\nconst WORD_POS_UNDEFINED_1 = 12;\nconst WORD_POS_UNDEFINED_2 = 13;\nconst WORD_POS_UNDEFINED_3 = 14;\nconst WORD_POS_UNDEFINED_4 = 15;\nconst WORD_POS_UNDEFINED_5 = 16;\nconst WORD_POS_UNDEFINED_6 = 17;\nconst WORD_POS_UNDEFINED_7 = 18;\nconst WORD_POS_UNDEFINED_8 = 19;\nconst WORD_POS_NAN_1 = 20;\nconst WORD_POS_NAN_2 = 21;\nconst WORD_POS_INFINITY_1 = 22;\nconst WORD_POS_INFINITY_2 = 23;\nconst WORD_POS_INFINITY_3 = 24;\nconst WORD_POS_INFINITY_4 = 25;\nconst WORD_POS_INFINITY_5 = 26;\nconst WORD_POS_INFINITY_6 = 27;\nconst WORD_POS_INFINITY_7 = 28;\n\nconst WORD_POS_FIELD = 29;\nconst WORD_POS_AFTER_FIELD = 30;\nconst WORD_POS_END = 31;\n\nconst CONTEXT_UNKNOWN = 0;\nconst CONTEXT_IN_ARRAY = 1;\nconst CONTEXT_OBJECT_FIELD = 3;\nconst CONTEXT_OBJECT_FIELD_VALUE = 4;\n\nconst contexts = [];\nfunction getContext() { var ctx = contexts.pop(); if( !ctx ) ctx = { context : CONTEXT_UNKNOWN, elements : null, element_array : null }; return ctx; }\nfunction dropContext(ctx) { contexts.push( ctx ); }\n\nconst buffers = [];\nfunction getBuffer() { var buf = buffers.pop(); if( !buf ) buf = { buf:null, n:0 }; else buf.n = 0; return buf; }\nfunction dropBuffer(buf) { buffers.push( buf ); }\n\nvar JSON6 = ( exports );\n\nJSON6.escape = function(string) {\n\tvar n;\n\tvar output = '';\n\tif( !string ) return string;\n\tfor( n = 0; n < string.length; n++ ) {\n\t\tif( ( string[n] == '\"' ) || ( string[n] == '\\\\' ) || ( string[n] == '`' )|| ( string[n] == '\\'' )) {\n\t\t\toutput += '\\\\';\n\t\t}\n\t\toutput += string[n];\n\t}\n\treturn output;\n};\n\n\nJSON6.begin = function( cb, reviver ) {\n\n\tconst val = { name : null,\t  // name of this value (if it's contained in an object)\n\t\t \tvalue_type: VALUE_UNSET, // value from above indiciating the type of this value\n\t \t\tstring : '',   // the string value of this value (strings and number types only)\n\t\t\tcontains : null,\n\t\t};\n\n\tconst pos = { line:1, col:1 };\n\tlet\tn = 0;\n\tlet     str;\n\tvar word = WORD_POS_RESET,\n\t\tstatus = true,\n\t\tnegative = false,\n\t\tresult = null,\n\t\telements = undefined,\n\t\telement_array = [],\n\t\tcontext_stack = {\n\t\t\tfirst : null,\n\t\t\tlast : null,\n\t\t\tsaved : null,\n\t\t\tpush(node) {\n\t\t\t\tvar recover = this.saved;\n\t\t\t\tif( recover ) { this.saved = recover.next; recover.node = node; recover.next = null; recover.prior = this.last; }\n\t\t\t\telse { recover = { node : node, next : null, prior : this.last }; }\n\t\t\t\tif( !this.last ) this.first = recover;\n\t\t\t\tthis.last = recover;\n\t\t\t},\n\t\t\tpop() {\n\t\t\t\tvar result = this.last;\n\t\t\t\tif( !result ) return null;\n\t\t\t\tif( !(this.last = result.prior ) ) this.first = null;\n\t\t\t\tresult.next = this.saved; this.saved = result;\n\t\t\t\treturn result.node;\n\t\t\t}\n\t\t},\n\n\t\tparse_context = CONTEXT_UNKNOWN,\n\t\tcomment = 0,\n\t\tfromHex = false,\n\t\tdecimal = false,\n\t\texponent = false,\n\t\texponent_sign = false,\n\t\texponent_digit = false,\n\t\tinQueue = {\n\t\t\tfirst : null,\n\t\t\tlast : null,\n\t\t\tsaved : null,\n\t\t\tpush(node) {\n\t\t\t\tvar recover = this.saved;\n\t\t\t\tif( recover ) { this.saved = recover.next; recover.node = node; recover.next = null; recover.prior = this.last; }\n\t\t\t\telse { recover = { node : node, next : null, prior : this.last }; }\n\t\t\t\tif( !this.last ) this.first = recover;\n\t\t\t\tthis.last = recover;\n\t\t\t},\n\t\t\tshift() {\n\t\t\t\tvar result = this.first;\n\t\t\t\tif( !result ) return null;\n\t\t\t\tif( !(this.first = result.next ) ) this.last = null;\n\t\t\t\tresult.next = this.saved; this.saved = result;\n\t\t\t\treturn result.node;\n\t\t\t},\n\t\t\tunshift(node) {\n\t\t\t\tvar recover = this.saved;\n\t\t\t\tif( recover ) { this.saved = recover.next; recover.node = node; recover.next = this.first; recover.prior = null; }\n\t\t\t\telse { recover = { node : node, next : this.first, prior : null }; }\n\t\t\t\tif( !this.first ) this.last = recover;\n\t\t\t\tthis.first = recover;\n\t\t\t}\n\t\t},\n\t\tgatheringStringFirstChar = null,\n\t\tgatheringString = false,\n\t\tgatheringNumber = false,\n\t\tstringEscape = false,\n\t\tcr_escaped = false,\n\t\tunicodeWide = false,\n\t\tstringUnicode = false,\n\t\tstringHex = false,\n\t\thex_char = 0,\n\t\thex_char_len = 0,\n\t\tstringOct = false,\n\t\tcompleted = false\n\t\t;\n\n\treturn {\n\t\tvalue() {\n\t\t\tvar r = result;\n\t\t\tresult = undefined;\n\t\t\treturn r;\n\t\t},\n\t\treset() {\n\t\t\tword = WORD_POS_RESET;\n\t\t\tstatus = true;\n\t\t\tif( inQueue.last ) inQueue.last.next = inQueue.save;\n\t\t\tinQueue.save = inQueue.first;\n\t\t\tinQueue.first = inQueue.last = null;\n\t\t\tif( context_stack.last ) context_stack.last.next = context_stack.save;\n\t\t\tcontext_stack.save = inQueue.first;\n\t\t\tcontext_stack.first = context_stack.last = null;//= [];\n\t\t\telement_array = null;\n\t\t\telements = undefined;\n\t\t\tparse_context = CONTEXT_UNKNOWN;\n\t\t\tval.value_type = VALUE_UNSET;\n\t\t\tval.name = null;\n\t\t\tval.string = '';\n\t\t\tpos.line = 1;\n\t\t\tpos.col = 1;\n\t\t\tnegative = false;\n\t\t\tcomment = 0;\n\t\t\tcompleted = false;\n\t\t\tgatheringString = false;\n\t\t\tstringEscape = false;  // string stringEscape intro\n\t\t\tcr_escaped = false;   // carraige return escaped\n\t\t\t//stringUnicode = false;  // reading \\u\n\t\t\t//unicodeWide = false;  // reading \\u{} in string\n\t\t\t//stringHex = false;  // reading \\x in string\n\t\t\t//stringOct = false;  // reading \\[0-3]xx in string\n\t\t},\n\t\twrite(msg) {\n\t\t\tvar retcode;\n\t\t\tif (typeof msg !== \"string\") msg = String(msg);\n\t\t\tfor( retcode = this._write(msg,false); retcode > 0; retcode = this._write() ) {\n\t\t\t\tif( result ) {\n\t\t\t\t\tif( typeof reviver === 'function' ) (function walk(holder, key) {\n\t\t\t\t\t\tvar k, v, value = holder[key];\n\t\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\t\tfor (k in value) {\n\t\t\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\t\t\tv = walk(value, k);\n\t\t\t\t\t\t\t\t\tif (v !== undefined) {\n\t\t\t\t\t\t\t\t\t\tvalue[k] = v;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdelete value[k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn reviver.call(holder, key, value);\n\t\t\t\t\t}({'': result}, ''));\n\t\t\t\t\tcb( result );\n\t\t\t\t\tresult = undefined;\n\t\t\t\t}\n\t\t\t\tif( retcode < 2 )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t\t_write(msg,complete_at_end) {\n\t\t\tvar cInt;\n\t\t\tvar input;\n\t\t\tvar buf;\n\t\t\tvar retval = 0;\n\n\t\t\tfunction throwError( leader, c ) {\n\t\t\t\tthrow new Error( `${leader} '${String.fromCodePoint( c )}' unexpected at ${n} (near '${buf.substr(n>4?(n-4):0,n>4?3:(n-1))}[${String.fromCodePoint( c )}]${buf.substr(n, 10)}') [${pos.line}:${pos.col}]`);\n\t\t\t}\n\n\t\t\tfunction RESET_VAL()  {\n\t\t\t\tval.value_type = VALUE_UNSET;\n\t\t\t\tval.string = '';\n\t\t\t}\n\n\t\t\tfunction numberConvert( string ) {\n\t\t\t\tif( string.length > 1 ) {\n\t\t\t\t\tif( !fromHex && !decimal && !exponent ) {\n\t\t\t\t\t\tif( string.charCodeAt(0) === 48/*'0'*/ )\n\t\t\t\t\t\t\treturn (negative?-1:1) * Number( \"0o\" + string );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (negative?-1:1) * Number( string );\n\t\t\t}\n\n\t\t\tfunction arrayPush() {\n\t\t\t\tswitch( val.value_type ){\n\t\t\t\tcase VALUE_NUMBER:\n\t\t\t\t\telement_array.push( numberConvert(val.string) );//(negative?-1:1) * Number( val.string ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_STRING:\n\t\t\t\t\telement_array.push( val.string );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_TRUE:\n\t\t\t\t\telement_array.push( true );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_FALSE:\n\t\t\t\t\telement_array.push( false );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NEG_NAN:\n\t\t\t\t\telement_array.push( -NaN );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NAN:\n\t\t\t\t\telement_array.push( NaN );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NEG_INFINITY:\n\t\t\t\t\telement_array.push( -Infinity );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_INFINITY:\n\t\t\t\t\telement_array.push( Infinity );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NULL:\n\t\t\t\t\telement_array.push( null );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_UNDEFINED:\n\t\t\t\t\telement_array.push( undefined );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_EMPTY:\n\t\t\t\t\telement_array.push( undefined );\n\t\t\t\t\tdelete element_array[element_array.length-1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_OBJECT:\n\t\t\t\t\telement_array.push( val.contains );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_ARRAY:\n\t\t\t\t\telement_array.push( val.contains );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log( \"Unhandled array push.\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction objectPush() {\n\t\t\t\tswitch( val.value_type ){\n\t\t\t\tcase VALUE_NUMBER:\n\t\t\t\t\telements[val.name] = numberConvert(val.string);//(negative?-1:1) * Number( val.string );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_STRING:\n\t\t\t\t\telements[val.name] = ( val.string );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_TRUE:\n\t\t\t\t\telements[val.name] = ( true );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_FALSE:\n\t\t\t\t\telements[val.name] = ( false );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NEG_NAN:\n\t\t\t\t\telements[val.name] = ( -NaN );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NAN:\n\t\t\t\t\telements[val.name] = ( NaN );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NEG_INFINITY:\n\t\t\t\t\telements[val.name] = ( -Infinity );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_INFINITY:\n\t\t\t\t\telements[val.name] = ( Infinity );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NULL:\n\t\t\t\t\telements[val.name] = ( null );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_UNDEFINED:\n\t\t\t\t\telements[val.name] = ( undefined );\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_OBJECT:\n\t\t\t\t\telements[val.name] = val.contains;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_ARRAY:\n\t\t\t\t\telements[val.name] = val.contains;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction gatherString( start_c ) {\n\t\t\t\tlet retval = 0;\n\t\t\t\twhile( retval == 0 && ( n < buf.length ) )\n\t\t\t\t{\n\t\t\t\t\tstr = buf.charAt(n);\n\t\t\t\t\tlet cInt = buf.codePointAt(n++);\n\t\t\t\t\tif( cInt >= 0x10000 ) { str += buf.charAt(n); n++; }\n\t\t\t\t\t//console.log( \"gathering....\", stringEscape, str, cInt, unicodeWide, stringHex, stringUnicode, hex_char_len );\n\t\t\t\t\tpos.col++;\n\t\t\t\t\tif( cInt == start_c )//( cInt == 34/*'\"'*/ ) || ( cInt == 39/*'\\''*/ ) || ( cInt == 96/*'`'*/ ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( stringEscape ) { val.string += str; stringEscape = false; }\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tretval = -1;\n\t\t\t\t\t\t\tif( stringOct )\n\t\t\t\t\t\t\t\tthrowError( \"Incomplete Octal sequence\", cInt );\n\t\t\t\t\t\t\telse if( stringHex )\n\t\t\t\t\t\t\t\tthrowError( \"Incomplete hexidecimal sequence\", cInt );\n\t\t\t\t\t\t\telse if( stringUnicode )\n\t\t\t\t\t\t\t\tthrowError( \"Incomplete unicode sequence\", cInt );\n\t\t\t\t\t\t\telse if( unicodeWide )\n\t\t\t\t\t\t\t\tthrowError( \"Incomplete long unicode sequence\", cInt );\n\t\t\t\t\t\t\tretval = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse if( stringEscape ) {\n\t\t\t\t\t\tif( stringOct ) {\n\t\t\t\t\t\t\tif( hex_char_len < 3 && cInt >= 48/*'0'*/ && cInt <= 57/*'9'*/ ) {\n\t\t\t\t\t\t\t\thex_char *= 8;\n\t\t\t\t\t\t\t\thex_char += cInt - 0x30;\n\t\t\t\t\t\t\t\thex_char_len++;\n\t\t\t\t\t\t\t\tif( hex_char_len === 3 ) {\n\t\t\t\t\t\t\t\t\tval.string += String.fromCodePoint( hex_char );\n\t\t\t\t\t\t\t\t\tstringOct = false;\n\t\t\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif( hex_char > 255 ) {\n\t\t\t\t\t\t\t\t\tthrowError( \"(escaped character, parsing octal escape val=%d) fault while parsing\", cInt );\n\t\t\t\t\t\t\t\t\tretval = -1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tval.string += String.fromCodePoint( hex_char );\n\t\t\t\t\t\t\t\tstringOct = false;\n\t\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( unicodeWide ) {\n\t\t\t\t\t\t\tif( cInt == 125/*'}'*/ ) {\n\t\t\t\t\t\t\t\tval.string += String.fromCodePoint( hex_char );\n\t\t\t\t\t\t\t\tunicodeWide = false;\n\t\t\t\t\t\t\t\tstringUnicode = false;\n\t\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thex_char *= 16;\n\t\t\t\t\t\t\tif( cInt >= 48/*'0'*/ && cInt <= 57/*'9'*/ )      hex_char += cInt - 0x30;\n\t\t\t\t\t\t\telse if( cInt >= 65/*'A'*/ && cInt <= 70/*'F'*/ ) hex_char += ( cInt - 65 ) + 10;\n\t\t\t\t\t\t\telse if( cInt >= 97/*'a'*/ && cInt <= 102/*'f'*/ ) hex_char += ( cInt - 97 ) + 10;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrowError( \"(escaped character, parsing hex of \\\\u)\", cInt );\n\t\t\t\t\t\t\t\tretval = -1;\n\t\t\t\t\t\t\t\tunicodeWide = false;\n\t\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( stringHex || stringUnicode ) {\n\t\t\t\t\t\t\tif( hex_char_len === 0 && cInt === 123/*'{'*/ ) {\n\t\t\t\t\t\t\t\tunicodeWide = true;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( hex_char_len < 2 || ( stringUnicode && hex_char_len < 4 ) ) {\n\t\t\t\t\t\t\t\thex_char *= 16;\n\t\t\t\t\t\t\t\tif( cInt >= 48/*'0'*/ && cInt <= 57/*'9'*/ )      hex_char += cInt - 0x30;\n\t\t\t\t\t\t\t\telse if( cInt >= 65/*'A'*/ && cInt <= 70/*'F'*/ ) hex_char += ( cInt - 65 ) + 10;\n\t\t\t\t\t\t\t\telse if( cInt >= 97/*'a'*/ && cInt <= 102/*'f'*/ ) hex_char += ( cInt - 97 ) + 10;\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthrowError( stringUnicode?\"(escaped character, parsing hex of \\\\u)\":\"(escaped character, parsing hex of \\\\x)\", cInt );\n\t\t\t\t\t\t\t\t\tretval = -1;\n\t\t\t\t\t\t\t\t\tstringHex = false;\n\t\t\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\thex_char_len++;\n\t\t\t\t\t\t\t\tif( stringUnicode ) {\n\t\t\t\t\t\t\t\t\tif( hex_char_len == 4 ) {\n\t\t\t\t\t\t\t\t\t\tval.string += String.fromCodePoint( hex_char );\n\t\t\t\t\t\t\t\t\t\tstringUnicode = false;\n\t\t\t\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if( hex_char_len == 2 ) {\n\t\t\t\t\t\t\t\t\tval.string += String.fromCodePoint( hex_char );\n\t\t\t\t\t\t\t\t\tstringHex = false;\n\t\t\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch( cInt )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 13/*'\\r'*/:\n\t\t\t\t\t\t\tcr_escaped = true;\n\t\t\t\t\t\t\tpos.col = 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcase 10/*'\\n'*/:\n\t\t\t\t\t\tcase 2028: // LS (Line separator)\n\t\t\t\t\t\tcase 2029: // PS (paragraph separate)\n\t\t\t\t\t\t\tpos.line++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 116/*'t'*/:\n\t\t\t\t\t\t\tval.string += '\\t';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 98/*'b'*/:\n\t\t\t\t\t\t\tval.string += '\\b';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 110/*'n'*/:\n\t\t\t\t\t\t\tval.string += '\\n';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 114/*'r'*/:\n\t\t\t\t\t\t\tval.string += '\\r';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 102/*'f'*/:\n\t\t\t\t\t\t\tval.string += '\\f';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 48/*'0'*/: case 49/*'1'*/: case 50/*'2'*/: case 51/*'3'*/:\n\t\t\t\t\t\t\tstringOct = true;\n\t\t\t\t\t\t\thex_char = cInt - 48;\n\t\t\t\t\t\t\thex_char_len = 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcase 120/*'x'*/:\n\t\t\t\t\t\t\tstringHex = true;\n\t\t\t\t\t\t\thex_char_len = 0;\n\t\t\t\t\t\t\thex_char = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcase 117/*'u'*/:\n\t\t\t\t\t\t\tstringUnicode = true;\n\t\t\t\t\t\t\thex_char_len = 0;\n\t\t\t\t\t\t\thex_char = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t//case 47/*'/'*/:\n\t\t\t\t\t\t//case 92/*'\\\\'*/:\n\t\t\t\t\t\t//case 34/*'\"'*/:\n\t\t\t\t\t\t//case 39/*\"'\"*/:\n\t\t\t\t\t\t//case 96/*'`'*/:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tval.string += str;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//console.log( \"other...\" );\n\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if( cInt === 92/*'\\\\'*/ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( stringEscape ) {\n\t\t\t\t\t\t\tval.string += '\\\\';\n\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstringEscape = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif( cr_escaped ) {\n\t\t\t\t\t\t\tcr_escaped = false;\n\t\t\t\t\t\t\tif( cInt == 10/*'\\n'*/ ) {\n\t\t\t\t\t\t\t\tpos.line++;\n\t\t\t\t\t\t\t\tpos.col = 1;\n\t\t\t\t\t\t\t\tstringEscape = false;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpos.line++;\n\t\t\t\t\t\t\t\tpos.col = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval.string += str;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn retval;\n\t\t\t}\n\n\n\t\t\tfunction collectNumber() {\n\t\t\t\tlet _n;\n\t\t\t\twhile( (_n = n) < buf.length )\n\t\t\t\t{\n\t\t\t\t\tstr = buf.charAt(_n);\n\t\t\t\t\tlet cInt = buf.codePointAt(n++);\n\t\t\t\t\tif( cInt >= 0x10000 ) { throwError( \"fault while parsing number;\", cInt ); str += buf.charAt(n); n++; }\n\t\t\t\t\tif( cInt == 95 /*_*/ )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpos.col++;\n\t\t\t\t\t// leading zeros should be forbidden.\n\t\t\t\t\tif( cInt >= 48/*'0'*/ && cInt <= 57/*'9'*/ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( exponent ) {\n\t\t\t\t\t\t\texponent_digit = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval.string += str;\n\t\t\t\t\t} else if( cInt == 45/*'-'*/ || cInt == 43/*'+'*/ ) {\n\t\t\t\t\t\tif( val.string.length == 0 || ( exponent && !exponent_sign && !exponent_digit ) ) {\n\t\t\t\t\t\t\tval.string += str;\n\t\t\t\t\t\t\texponent_sign = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatus = false; \n\t\t\t\t\t\t\tthrowError( \"fault while parsing number;\", cInt );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if( cInt == 46/*'.'*/ ) {\n\t\t\t\t\t\tif( !decimal && !fromHex && !exponent ) {\n\t\t\t\t\t\t\tval.string += str;\n\t\t\t\t\t\t\tdecimal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\tthrowError( \"fault while parsing number;\", cInt );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if( cInt == 120/*'x'*/ || cInt == 98/*'b'*/ || cInt == 111/*'o'*/\n\t\t\t\t\t         || cInt == 88/*'X'*/ || cInt == 66/*'B'*/ || cInt == 79/*'O'*/ ) {\n\t\t\t\t\t\t// hex conversion.\n\t\t\t\t\t\tif( !fromHex && val.string == '0' ) {\n\t\t\t\t\t\t\tfromHex = true;\n\t\t\t\t\t\t\tval.string += str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\tthrowError( \"fault while parsing number;\", cInt );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if( ( cInt == 101/*'e'*/ ) || ( cInt == 69/*'E'*/ ) ) {\n\t\t\t\t\t\tif( !exponent ) {\n\t\t\t\t\t\t\tval.string += str;\n\t\t\t\t\t\t\texponent = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\tthrowError( \"fault while parsing number;\", cInt );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif( cInt == 32/*' '*/ || cInt == 160/* &nbsp */ || cInt == 13 || cInt == 10 || cInt == 9\n\t\t\t\t\t\t  || cInt == 0xFEFF || cInt == 44/*','*/ || cInt == 125/*'}'*/ || cInt == 93/*']'*/\n\t\t\t\t\t\t  || cInt == 58/*':'*/ ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif( complete_at_end ) {\n\t\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\t\tthrowError( \"fault while parsing number;\", cInt );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tn = _n;\n\t                \n\t\t\t\tif( (!complete_at_end) && n == buf.length )\n\t\t\t\t{\n\t\t\t\t\tgatheringNumber = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tgatheringNumber = false;\n\t\t\t\t\tval.value_type = VALUE_NUMBER;\n\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN ) {\n\t\t\t\t\t\tcompleted = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif( !status )\n\t\t\t\treturn -1;\n\n\t\t\tif( msg && msg.length ) {\n\t\t\t\tinput = getBuffer();\n\t\t\t\tinput.buf = msg;\n\t\t\t\tinQueue.push( input );\n\t\t\t} else {\n\t\t\t\tif( gatheringNumber ) {\n\t\t\t\t\t//console.log( \"Force completed.\")\n\t\t\t\t\tgatheringNumber = false;\n\t\t\t\t\tval.value_type = VALUE_NUMBER;\n\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN ) {\n\t\t\t\t\t\tcompleted = true;\n\t\t\t\t\t}\n\t\t\t\t\tretval = 1;  // if returning buffers, then obviously there's more in this one.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile( status && ( input = inQueue.shift() ) ) {\n\t\t\t\tn = input.n;\n\t\t\t\tbuf = input.buf;\n\t\t\t\tif( gatheringString ) {\n\t\t\t\t\tlet string_status = gatherString( gatheringStringFirstChar );\n\t\t\t\t\tif( string_status < 0 )\n\t\t\t\t\t\tstatus = false;\n\t\t\t\t\telse if( string_status > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tgatheringString = false;\n\t\t\t\t\t\tif( status ) val.value_type = VALUE_STRING;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( gatheringNumber ) {\n\t\t\t\t\tcollectNumber();\n\t\t\t\t}\n\n\t\t\t\twhile( !completed && status && ( n < buf.length ) )\n\t\t\t\t{\n\t\t\t\t\tstr = buf.charAt(n);\n\t\t\t\t\tcInt = buf.codePointAt(n++);\n\t\t\t\t\tif( cInt >= 0x10000 ) { str += buf.charAt(n); n++; }\n\t\t\t\t\tpos.col++;\n\t\t\t\t\tif( comment ) {\n\t\t\t\t\t\tif( comment == 1 ) {\n\t\t\t\t\t\t\tif( cInt == 42/*'*'*/ ) { comment = 3; continue; }\n\t\t\t\t\t\t\tif( cInt != 47/*'/'*/ ) {\n\t\t\t\t\t\t\t\tthrowError( \"fault while parsing;\", cInt );\n\t\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse comment = 2;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( comment == 2 ) {\n\t\t\t\t\t\t\tif( cInt == 10/*'\\n'*/ ) { comment = 0; continue; }\n\t\t\t\t\t\t\telse continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( comment == 3 ){\n\t\t\t\t\t\t\tif( cInt == 42/*'*'*/ ) { comment = 4; continue; }\n\t\t\t\t\t\t\telse continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( comment == 4 ) {\n\t\t\t\t\t\t\tif( cInt == 47/*'/'*/ ) { comment = 0; continue; }\n\t\t\t\t\t\t\telse { if( cInt != 42/*'*'*/ ) comment = 3; continue; }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch( cInt )\n\t\t\t\t\t{\n\t\t\t\t\tcase 47/*'/'*/:\n\t\t\t\t\t\tif( !comment ) comment = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 123/*'{'*/:\n\t\t\t\t\t\tif( word == WORD_POS_FIELD || word == WORD_POS_AFTER_FIELD || ( parse_context == CONTEXT_OBJECT_FIELD && word == WORD_POS_RESET ) ) {\n\t\t\t\t\t\t\tthrowError( \"fault while parsing; getting field name unexpected \", cInt );\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet old_context = getContext();\n\n\t\t\t\t\t\t\tval.value_type = VALUE_OBJECT;\n\t\t\t\t\t\t\tlet tmpobj = {};\n\t\t\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN )\n\t\t\t\t\t\t\t\tresult = elements = tmpobj;\n\t\t\t\t\t\t\t//else if( parse_context == CONTEXT_IN_ARRAY )\n\t\t\t\t\t\t\t//\telement_array.push( tmpobj );\n\t\t\t\t\t\t\telse if( parse_context == CONTEXT_OBJECT_FIELD_VALUE )\n\t\t\t\t\t\t\t\telements[val.name] = tmpobj;\n\n\t\t\t\t\t\t\told_context.context = parse_context;\n\t\t\t\t\t\t\told_context.elements = elements;\n\t\t\t\t\t\t\told_context.element_array = element_array;\n\t\t\t\t\t\t\told_context.name = val.name;\n\t\t\t\t\t\t\telements = tmpobj;\n\t\t\t\t\t\t\tcontext_stack.push( old_context );\n\t\t\t\t\t\t\tRESET_VAL();\n\t\t\t\t\t\t\tparse_context = CONTEXT_OBJECT_FIELD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 91/*'['*/:\n\t\t\t\t\t\tif( parse_context == CONTEXT_OBJECT_FIELD || word == WORD_POS_FIELD || word == WORD_POS_AFTER_FIELD ) {\n\t\t\t\t\t\t\tthrowError( \"Fault while parsing; while getting field name unexpected\", cInt );\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet old_context = getContext();\n\n\t\t\t\t\t\t\tval.value_type = VALUE_ARRAY;\n\t\t\t\t\t\t\tlet tmparr = [];\n\t\t\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN )\n\t\t\t\t\t\t\t\tresult = element_array = tmparr;\n\t\t\t\t\t\t\t//else if( parse_context == CONTEXT_IN_ARRAY )\n\t\t\t\t\t\t\t//\telement_array.push( tmparr );\n\t\t\t\t\t\t\telse if( parse_context == CONTEXT_OBJECT_FIELD_VALUE )\n\t\t\t\t\t\t\t\telements[val.name] = tmparr;\n\n\t\t\t\t\t\t\told_context.context = parse_context;\n\t\t\t\t\t\t\told_context.elements = elements;\n\t\t\t\t\t\t\told_context.element_array = element_array;\n\t\t\t\t\t\t\told_context.name = val.name;\n\t\t\t\t\t\t\telement_array = tmparr;\n\t\t\t\t\t\t\tcontext_stack.push( old_context );\n\n\t\t\t\t\t\t\tRESET_VAL();\n\t\t\t\t\t\t\tparse_context = CONTEXT_IN_ARRAY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 58/*':'*/:\n\t\t\t\t\t\t//if(_DEBUG_PARSING) console.log( \"colon context:\", parse_context );\n\t\t\t\t\t\tif( parse_context == CONTEXT_OBJECT_FIELD )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( word != WORD_POS_RESET\n\t\t\t\t\t\t\t\t&& word != WORD_POS_FIELD\n\t\t\t\t\t\t\t\t&& word != WORD_POS_AFTER_FIELD ) {\n\t\t\t\t\t\t\t\t// allow starting a new word\n\t\t\t\t\t\t\t\tstatus = FALSE;\n\t\t\t\t\t\t\t\tthorwError( `fault while parsing; unquoted keyword used as object field name (state:${word})`, cInt );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tword = WORD_POS_RESET;\n\t\t\t\t\t\t\tval.name = val.string;\n\t\t\t\t\t\t\tval.string = '';\n\t\t\t\t\t\t\tparse_context = CONTEXT_OBJECT_FIELD_VALUE;\n\t\t\t\t\t\t\tval.value_type = VALUE_UNSET;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( parse_context == CONTEXT_IN_ARRAY )\n\t\t\t\t\t\t\t\tthrowError(  \"(in array, got colon out of string):parsing fault;\", cInt );\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tthrowError( \"(outside any object, got colon out of string):parsing fault;\", cInt );\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 125/*'}'*/:\n\t\t\t\t\t\t//if(_DEBUG_PARSING) console.log( \"close bracket context:\", word, parse_context );\n\t\t\t\t\t\tif( word == WORD_POS_END ) {\n\t\t\t\t\t\t\t// allow starting a new word\n\t\t\t\t\t\t\tword = WORD_POS_RESET;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// coming back after pushing an array or sub-object will reset the contxt to FIELD, so an end with a field should still push value.\n\t\t\t\t\t\tif( ( parse_context == CONTEXT_OBJECT_FIELD ) ) {\n\t\t\t\t\t\t\tRESET_VAL();\n\t\t\t\t\t\t\tlet old_context = context_stack.pop();\n\t\t\t\t\t\t\tparse_context = old_context.context; // this will restore as IN_ARRAY or OBJECT_FIELD\n\t\t\t\t\t\t\telements = old_context.elements;\n\t\t\t\t\t\t\telement_array = old_context.element_array;\n\t\t\t\t\t\t\tdropContext( old_context );\n\t\t\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN ) {\n\t\t\t\t\t\t\t\tcompleted = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( ( parse_context == CONTEXT_OBJECT_FIELD_VALUE ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( val.value_type != VALUE_UNSET ) {\n\t\t\t\t\t\t\t\tobjectPush();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tval.value_type = VALUE_OBJECT;\n\t\t\t\t\t\t\tval.contains = elements;\n\n\t\t\t\t\t\t\t//let old_context = context_stack.pop();\n\t\t\t\t\t\t\tvar old_context = context_stack.pop();\n\t\t\t\t\t\t\tval.name = old_context.name;\n\t\t\t\t\t\t\tparse_context = old_context.context; // this will restore as IN_ARRAY or OBJECT_FIELD\n\t\t\t\t\t\t\telements = old_context.elements;\n\t\t\t\t\t\t\telement_array = old_context.element_array;\n\t\t\t\t\t\t\tdropContext( old_context );\n\t\t\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN ) {\n\t\t\t\t\t\t\t\tcompleted = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrowError( \"Fault while parsing; unexpected\", cInt );\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnegative = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 93/*']'*/:\n\t\t\t\t\t\tif( word == WORD_POS_END ) word = WORD_POS_RESET;\n\t\t\t\t\t\tif( parse_context == CONTEXT_IN_ARRAY )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( val.value_type != VALUE_UNSET ) {\n\t\t\t\t\t\t\t\tarrayPush();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//RESET_VAL();\n\t\t\t\t\t\t\tval.value_type = VALUE_ARRAY;\n\t\t\t\t\t\t\tval.contains = element_array;\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar old_context = context_stack.pop();\n\t\t\t\t\t\t\t\tval.name = old_context.name;\n\t\t\t\t\t\t\t\tparse_context = old_context.context;\n\t\t\t\t\t\t\t\telements = old_context.elements;\n\t\t\t\t\t\t\t\telement_array = old_context.element_array;\n\t\t\t\t\t\t\t\tdropContext( old_context );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN ) {\n\t\t\t\t\t\t\t\tcompleted = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrowError( `bad context ${parse_context}; fault while parsing`, cInt );// fault\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnegative = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 44/*','*/:\n\t\t\t\t\t\tif( word == WORD_POS_END ) word = WORD_POS_RESET;  // allow collect new keyword\n\t\t\t\t\t\tif( parse_context == CONTEXT_IN_ARRAY )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( val.value_type == VALUE_UNSET )\n\t\t\t\t\t\t\t\tval.value_type = VALUE_EMPTY; // in an array, elements after a comma should init as undefined...\n\n\t\t\t\t\t\t\tif( val.value_type != VALUE_UNSET ) {\n\t\t\t\t\t\t\t\tarrayPush();\n\t\t\t\t\t\t\t\tRESET_VAL();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// undefined allows [,,,] to be 4 values and [1,2,3,] to be 4 values with an undefined at end.\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( parse_context == CONTEXT_OBJECT_FIELD_VALUE )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparse_context = CONTEXT_OBJECT_FIELD;\n\t\t\t\t\t\t\tif( val.value_type != VALUE_UNSET ) {\n\t\t\t\t\t\t\t\tobjectPush();\n\t\t\t\t\t\t\t\tRESET_VAL();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\tthrowError( \"bad context; excessive commas while parsing;\", cInt );// fault\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnegative = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif( parse_context == CONTEXT_OBJECT_FIELD ) {\n\t\t\t\t\t\t\tswitch( cInt )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 96://'`':\n\t\t\t\t\t\t\tcase 34://'\"':\n\t\t\t\t\t\t\tcase 39://'\\'':\n\t\t\t\t\t\t\t\tif( word == WORD_POS_RESET ) {\n\t\t\t\t\t\t\t\t\tlet string_status = gatherString(cInt );\n\t\t\t\t\t\t\t\t\tif( string_status ) {\n\t\t\t\t\t\t\t\t\t\tval.value_type = VALUE_STRING;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tgatheringStringFirstChar = cInt;\n\t\t\t\t\t\t\t\t\t\tgatheringString = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthrowError( \"fault while parsing; quote not at start of field name\", cInt );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 10://'\\n':\n\t\t\t\t\t\t\t\tpos.line++;\n\t\t\t\t\t\t\t\tpos.col = 1;\n\t\t\t\t\t\t\t\t// fall through to normal space handling - just updated line/col position\n\t\t\t\t\t\t\tcase 13://'\\r':\n\t\t\t\t\t\t\tcase 32://' ':\n\t\t\t\t\t\t\tcase 160://&nbsp:\n\t\t\t\t\t\t\tcase 9://'\\t':\n\t\t\t\t\t\t\tcase 0xFEFF: // ZWNBS is WS though\n\t\t\t\t\t\t\t\tif( word == WORD_POS_END ) { // allow collect new keyword\n\t\t\t\t\t\t\t\t\tword = WORD_POS_RESET;\n\t\t\t\t\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN ) {\n\t\t\t\t\t\t\t\t\t\tcompleted = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( word == WORD_POS_RESET || word == WORD_POS_AFTER_FIELD )  // ignore leading and trailing whitepsace\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse if( word == WORD_POS_FIELD ) {\n\t\t\t\t\t\t\t\t\tword = WORD_POS_AFTER_FIELD;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\t\t\tthrowError( \"fault while parsing; whitepsace unexpected\", cInt );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// skip whitespace\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif( word == WORD_POS_AFTER_FIELD ) {\n\t\t\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\t\t\tthrowError( \"fault while parsing; character unexpected\", cInt );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( word == WORD_POS_RESET ) word = WORD_POS_FIELD;\n\t\t\t\t\t\t\t\tval.string += str;\n\t\t\t\t\t\t\t\tbreak; // default\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse switch( cInt )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 96://'`':\n\t\t\t\t\t\tcase 34://'\"':\n\t\t\t\t\t\tcase 39://'\\'':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet string_status = gatherString( cInt );\n\t\t\t\t\t\t\tif( string_status ) {\n\t\t\t\t\t\t\t\tval.value_type = VALUE_STRING;\n\t\t\t\t\t\t\t\tword = WORD_POS_END;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgatheringStringFirstChar = cInt;\n\t\t\t\t\t\t\t\tgatheringString = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 10://'\\n':\n\t\t\t\t\t\t\tpos.line++;\n\t\t\t\t\t\t\tpos.col = 1;\n\t\t\t\t\t\tcase 32://' ':\n\t\t\t\t\t\tcase 160:// &nbsp \n\t\t\t\t\t\tcase 9://'\\t':\n\t\t\t\t\t\tcase 13://'\\r':\n\t\t\t\t\t\tcase 0xFEFF://'\\uFEFF':\n\t\t\t\t\t\t\tif( word == WORD_POS_END ) {\n\t\t\t\t\t\t\t\tword = WORD_POS_RESET;\n\t\t\t\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN ) {\n\t\t\t\t\t\t\t\t\tcompleted = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( word == WORD_POS_RESET )\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse if( word == WORD_POS_FIELD ) {\n\t\t\t\t\t\t\t\tword = WORD_POS_AFTER_FIELD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\t\tthrowError( \"fault parsing whitespace\", cInt );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t//----------------------------------------------------------\n\t\t\t\t\t//  catch characters for true/false/null/undefined which are values outside of quotes\n\t\t\t\t\t\tcase 116://'t':\n\t\t\t\t\t\t\tif( word == WORD_POS_RESET ) word = WORD_POS_TRUE_1;\n\t\t\t\t\t\t\telse if( word == WORD_POS_INFINITY_6 ) word = WORD_POS_INFINITY_7;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 114://'r':\n\t\t\t\t\t\t\tif( word == WORD_POS_TRUE_1 ) word = WORD_POS_TRUE_2;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 117://'u':\n\t\t\t\t\t\t\tif( word == WORD_POS_TRUE_2 ) word = WORD_POS_TRUE_3;\n\t\t\t\t\t\t\telse if( word == WORD_POS_NULL_1 ) word = WORD_POS_NULL_2;\n\t\t\t\t\t\t\telse if( word == WORD_POS_RESET ) word = WORD_POS_UNDEFINED_1;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 101://'e':\n\t\t\t\t\t\t\tif( word == WORD_POS_TRUE_3 ) {\n\t\t\t\t\t\t\t\tval.value_type = VALUE_TRUE;\n\t\t\t\t\t\t\t\tword = WORD_POS_END;\n\t\t\t\t\t\t\t} else if( word == WORD_POS_FALSE_4 ) {\n\t\t\t\t\t\t\t\tval.value_type = VALUE_FALSE;\n\t\t\t\t\t\t\t\tword = WORD_POS_END;\n\t\t\t\t\t\t\t} else if( word == WORD_POS_UNDEFINED_3 ) word = WORD_POS_UNDEFINED_4;\n\t\t\t\t\t\t\telse if( word == WORD_POS_UNDEFINED_7 ) word = WORD_POS_UNDEFINED_8;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 110://'n':\n\t\t\t\t\t\t\tif( word == WORD_POS_RESET ) word = WORD_POS_NULL_1;\n\t\t\t\t\t\t\telse if( word == WORD_POS_UNDEFINED_1 ) word = WORD_POS_UNDEFINED_2;\n\t\t\t\t\t\t\telse if( word == WORD_POS_UNDEFINED_6 ) word = WORD_POS_UNDEFINED_7;\n\t\t\t\t\t\t\telse if( word == WORD_POS_INFINITY_1 ) word = WORD_POS_INFINITY_2;\n\t\t\t\t\t\t\telse if( word == WORD_POS_INFINITY_4 ) word = WORD_POS_INFINITY_5;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 100://'d':\n\t\t\t\t\t\t\tif( word == WORD_POS_UNDEFINED_2 ) word = WORD_POS_UNDEFINED_3;\n\t\t\t\t\t\t\telse if( word == WORD_POS_UNDEFINED_8 ) { val.value_type=VALUE_UNDEFINED; word = WORD_POS_END; }\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 105://'i':\n\t\t\t\t\t\t\tif( word == WORD_POS_UNDEFINED_5 ) word = WORD_POS_UNDEFINED_6;\n\t\t\t\t\t\t\telse if( word == WORD_POS_INFINITY_3 ) word = WORD_POS_INFINITY_4;\n\t\t\t\t\t\t\telse if( word == WORD_POS_INFINITY_5 ) word = WORD_POS_INFINITY_6;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 108://'l':\n\t\t\t\t\t\t\tif( word == WORD_POS_NULL_2 ) word = WORD_POS_NULL_3;\n\t\t\t\t\t\t\telse if( word == WORD_POS_NULL_3 ) {\n\t\t\t\t\t\t\t\tval.value_type = VALUE_NULL;\n\t\t\t\t\t\t\t\tword = WORD_POS_END;\n\t\t\t\t\t\t\t} else if( word == WORD_POS_FALSE_2 ) word = WORD_POS_FALSE_3;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 102://'f':\n\t\t\t\t\t\t\tif( word == WORD_POS_RESET ) word = WORD_POS_FALSE_1;\n\t\t\t\t\t\t\telse if( word == WORD_POS_UNDEFINED_4 ) word = WORD_POS_UNDEFINED_5;\n\t\t\t\t\t\t\telse if( word == WORD_POS_INFINITY_2 ) word = WORD_POS_INFINITY_3;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 97://'a':\n\t\t\t\t\t\t\tif( word == WORD_POS_FALSE_1 ) word = WORD_POS_FALSE_2;\n\t\t\t\t\t\t\telse if( word == WORD_POS_NAN_1 ) word = WORD_POS_NAN_2;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 115://'s':\n\t\t\t\t\t\t\tif( word == WORD_POS_FALSE_3 ) word = WORD_POS_FALSE_4;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 73://'I':\n\t\t\t\t\t\t\tif( word == WORD_POS_RESET ) word = WORD_POS_INFINITY_1;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 78://'N':\n\t\t\t\t\t\t\tif( word == WORD_POS_RESET ) word = WORD_POS_NAN_1;\n\t\t\t\t\t\t\telse if( word == WORD_POS_NAN_2 ) { val.value_type = negative ? VALUE_NEG_NAN : VALUE_NAN; negative = false; word = WORD_POS_END; }\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 121://'y':\n\t\t\t\t\t\t\tif( word == WORD_POS_INFINITY_7 ) { val.value_type = negative ? VALUE_NEG_INFINITY : VALUE_INFINITY; negative = false; word = WORD_POS_END; }\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 45://'-':\n\t\t\t\t\t\t\tif( word == WORD_POS_RESET ) negative = !negative;\n\t\t\t\t\t\t\telse { status = false; throwError( \"fault parsing\", cInt ); }// fault\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t//\n \t \t \t \t \t//----------------------------------------------------------\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif( ( cInt >= 48/*'0'*/ && cInt <= 57/*'9'*/ ) || ( cInt == 43/*'+'*/ ) || ( cInt == 46/*'.'*/ ) || ( cInt == 45/*'-'*/ ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfromHex = false;\n\t\t\t\t\t\t\t\texponent = false;\n\t\t\t\t\t\t\t\texponent_sign = false;\n\t\t\t\t\t\t\t\texponent_digit = false;\n\t\t\t\t\t\t\t\tdecimal = false;\n\t\t\t\t\t\t\t\tval.string = str;\n\t\t\t\t\t\t\t\tinput.n = n;\n\t\t\t\t\t\t\t\tcollectNumber();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus = false;\n\t\t\t\t\t\t\t\tthrowError( \"fault parsing\", cInt );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak; // default\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak; // default of high level switch\n\t\t\t\t\t}\n\t\t\t\t\tif( completed ) {\n\t\t\t\t\t\tif( word == WORD_POS_END ) {\n\t\t\t\t\t\t\tword = WORD_POS_RESET;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( n == buf.length ) {\n\t\t\t\t\tdropBuffer( input );\n\t\t\t\t\tif( gatheringString || gatheringNumber || parse_context == CONTEXT_OBJECT_FIELD ) {\n\t\t\t\t\t\tretval = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif( parse_context == CONTEXT_UNKNOWN && ( val.value_type != VALUE_UNSET || result ) ) {\n\t\t\t\t\t\t\tcompleted = true;\n\t\t\t\t\t\t\tretval = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// put these back into the stack.\n\t\t\t\t\tinput.n = n;\n\t\t\t\t\tinQueue.unshift( input );\n\t\t\t\t\tretval = 2;  // if returning buffers, then obviously there's more in this one.\n\t\t\t\t}\n\t\t\t\tif( completed )\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif( !status ) return -1;\n\t\t\tif( completed && val.value_type != VALUE_UNSET ) {\n\t\t\t\tswitch( val.value_type ) {\n\t\t\t\tcase VALUE_NUMBER:\n\t\t\t\t\tresult = numberConvert(val.string);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_STRING:\n\t\t\t\t\tresult = val.string;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_TRUE:\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_FALSE:\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NULL:\n\t\t\t\t\tresult = null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_UNDEFINED:\n\t\t\t\t\tresult = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NAN:\n\t\t\t\t\tresult = NaN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NEG_NAN:\n\t\t\t\t\tresult = -NaN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_INFINITY:\n\t\t\t\t\tresult = Infinity;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_NEG_INFINITY:\n\t\t\t\t\tresult = -Infinity;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_OBJECT: // never happens\n\t\t\t\t\tresult = val.contains;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VALUE_ARRAY: // never happens\n\t\t\t\t\tresult = val.contains;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnegative = false;\n\t\t\t\tval.string = '';\n\t\t\t\tval.value_type = VALUE_UNSET;\n\t\t\t}\n\t\t\tcompleted = false;\n\t\t\treturn retval;\n\t\t}\n\t}\n};\n\n\n\nconst _parser = [Object.freeze( JSON6.begin() )];\nvar _parse_level = 0;\nJSON6.parse = function( msg, reviver ) {\n\t//var parser = JSON6.begin();\n\tvar parse_level = _parse_level++;\n\tvar parser;\n\tif( _parser.length <= parse_level )\n\t\t_parser.push( Object.freeze( JSON6.begin() ) );\n\tparser = _parser[parse_level];\n\tif (typeof msg !== \"string\") msg = String(msg);\n\tparser.reset();\n\tif( parser._write( msg, true ) > 0 )\n\t{\n\t\tvar result = parser.value();\n\t\tvar reuslt = typeof reviver === 'function' ? (function walk(holder, key) {\n\t\t\tvar k, v, value = holder[key];\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tfor (k in value) {\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\tv = walk(value, k);\n\t\t\t\t\t\tif (v !== undefined) {\n\t\t\t\t\t\t\tvalue[k] = v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete value[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn reviver.call(holder, key, value);\n\t\t}({'': result}, '')) : result;\n\t\t_parse_level--;\n\t\treturn result;\n\t}\n\treturn undefined;\n};\nJSON6.stringify = JSON.stringify;\n});\n\nvar lib = json6;\n\nexport default lib;\n","// We want it to work in the browser, so commenting out\n// import jsonExtra from 'json5';\n// import jsonExtra from 'json-6';\n\n// We need this for the browser version to work, but this breaks nyc;\n//  see https://github.com/standard-things/esm/issues/839\n// import jsonExtra from '../node_modules/json-6/dist/index.mjs';\nimport jsonExtra from 'json-6';\n\nexport const unescapeBackslashes = (str) => {\n  return str.replace(/\\\\+/gu, (esc) => {\n    return esc.slice(0, esc.length / 2);\n  });\n};\n\nexport const parseJSONExtra = (args) => {\n  return jsonExtra.parse(\n    // Doesn't actually currently allow explicit brackets,\n    //  but in case we change our regex to allow inner brackets\n    '{' + (args || '').replace(/^\\{/u, '').replace(/\\}$/u, '') + '}'\n  );\n};\n\n// Todo: Extract to own library (RegExtras?)\nexport const processRegex = (regex, str, {\n  onMatch,\n  extra,\n  betweenMatches,\n  afterMatch,\n  escapeAtOne\n}) => {\n  let match;\n  let previousIndex = 0;\n  if (extra) {\n    betweenMatches = extra;\n    afterMatch = extra;\n    escapeAtOne = extra;\n  }\n  while ((match = regex.exec(str)) !== null) {\n    const [_, esc] = match;\n    const {lastIndex} = regex;\n\n    const startMatchPos = lastIndex - _.length;\n    if (startMatchPos > previousIndex) {\n      betweenMatches(str.slice(previousIndex, startMatchPos));\n    }\n\n    if (escapeAtOne && esc.length % 2) {\n      previousIndex = lastIndex;\n      escapeAtOne(_);\n      continue;\n    }\n    onMatch(...match);\n    previousIndex = lastIndex;\n  }\n  if (previousIndex !== str.length) { // Get text at end\n    afterMatch(str.slice(previousIndex));\n  }\n};\n","/* globals fetch, document */\nlet _fetch = typeof fetch !== 'undefined'\n  // istanbul ignore next\n  ? fetch\n  : null;\n\n/**\n * @param {fetch} f\n * @returns {void}\n */\nexport const setFetch = (f) => {\n  _fetch = f;\n};\n\n/**\n * @returns {fetch}\n */\nexport const getFetch = () => {\n  return _fetch;\n};\n\nlet _doc = typeof document !== 'undefined'\n  // istanbul ignore next\n  ? document\n  : null;\n\n/**\n * @param {document} doc\n * @returns {void}\n */\nexport const setDocument = (doc) => {\n  _doc = doc;\n};\n\n/**\n * @returns {document}\n */\nexport const getDocument = () => {\n  return _doc;\n};\n","/* globals performance */\nimport {processRegex} from './utils.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/**\n *\n * @returns {string}\n */\nfunction generateUUID () { //  Adapted from original: public domain/MIT: http://stackoverflow.com/a/8809472/271577\n  let d = new Date().getTime();\n  /* istanbul ignore next */\n  if (typeof performance !== 'undefined' &&\n      typeof performance.now === 'function'\n  ) {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, function (c) {\n    /* eslint-disable no-bitwise */\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n    /* eslint-enable no-bitwise */\n  });\n}\n\nexport const sort = (locale, arrayOfItems, options) => {\n  return arrayOfItems.sort(new Intl.Collator(\n    locale,\n    options\n  ).compare);\n};\n\nexport const list = (locale, arrayOfItems, options) => {\n  return new Intl.ListFormat(\n    locale, options\n  ).format(arrayOfItems);\n};\n\nexport const sortListSimple = (\n  locale, arrayOfItems, listOptions, collationOptions\n) => {\n  sort(locale, arrayOfItems, collationOptions);\n  return list(locale, arrayOfItems, listOptions);\n};\n\nexport const sortList = (\n  locale, arrayOfItems, map, listOptions, collationOptions\n) => {\n  if (typeof map !== 'function') {\n    return sortListSimple(locale, arrayOfItems, map, listOptions);\n  }\n  sort(locale, arrayOfItems, collationOptions);\n\n  const randomId = generateUUID();\n\n  const placeholderArray = [...arrayOfItems].map(\n    (_, i) => `<<${randomId}${i}>>`\n  );\n  const nodes = [];\n  const push = (...args) => {\n    nodes.push(...args);\n  };\n\n  processRegex(\n    // // eslint-disable-next-line prefer-named-capture-group\n    new RegExp(`<<${randomId}(\\\\d)>>`, 'gu'),\n    list(locale, placeholderArray, listOptions), {\n      betweenMatches: push,\n      afterMatch: push,\n      onMatch (_, idx) {\n        push(map(arrayOfItems[idx], idx));\n      }\n    }\n  );\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n  return container;\n};\n","import {parseJSONExtra} from './utils.js';\nimport {sortList} from './collation.js';\n\nexport const getFormatterInfo = ({object}) => {\n  if (Array.isArray(object)) {\n    if (typeof object[1] === 'function') {\n      const [value, callback, options, extraOpts] = object;\n      return {value, callback, options, extraOpts};\n    }\n    const [value, options, extraOpts] = object;\n    return {value, options, extraOpts};\n  }\n  return {value: object};\n};\n\n/* eslint-disable max-len */\n/**\n * Callback to give replacement text based on a substitution value.\n * @callback AllSubstitutionCallback\n * @param {PlainObject} cfg\n * @param {string|Node|number|Date|RelativeTimeInfo|ListInfo|NumberInfo|DateInfo} cfg.value Contains\n *   the value returned by the individual substitution\n * @param {string} cfg.arg See `cfg.arg` of {@link SubstitutionCallback}.\n * @param {string} cfg.key The substitution key Not currently in use\n * @param {string} cfg.locale The locale\n * @returns {string|Element} The replacement text or element\n*/\n/* eslint-enable max-len */\n\n/**\n * @type {AllSubstitutionCallback}\n */\nexport const defaultAllSubstitutions = ({value, arg, key, locale}) => {\n  // Strings or DOM Nodes\n  if (\n    typeof value === 'string' || (value && typeof value === 'object' &&\n    'nodeType' in value)\n  ) {\n    return value;\n  }\n\n  let opts;\n\n  const applyArgs = ({type, options = opts, checkArgOptions = false}) => {\n    if (typeof arg === 'string') {\n      let [userType, extraArgs, argOptions] = arg.split('|');\n      // Alias\n      if (userType === 'DATE') {\n        userType = 'DATETIME';\n      }\n      if (userType === type) {\n        if (!extraArgs) {\n          options = {};\n        } else if (!checkArgOptions || argOptions) {\n          // Todo: Allow escaping and restoring of pipe symbol\n          options = {\n            ...options,\n            ...parseJSONExtra(\n              checkArgOptions && argOptions ? argOptions : extraArgs\n            )\n          };\n        }\n      }\n    }\n    return options;\n  };\n\n  if (value && typeof value === 'object') {\n    const singleKey = Object.keys(value)[0];\n    if ([\n      'number', 'date', 'datetime', 'relative', 'list', 'plural'\n    ].includes(singleKey)) {\n      let extraOpts, callback;\n      ({\n        value, options: opts, extraOpts, callback\n      } = getFormatterInfo({object: value[singleKey]}));\n\n      switch (singleKey) {\n      case 'relative':\n        // The second argument actually contains the primary options, so swap\n        [extraOpts, opts] = [opts, extraOpts];\n        return new Intl.RelativeTimeFormat(\n          locale, applyArgs({type: 'RELATIVE'})\n        ).format(value, extraOpts);\n\n      // ListFormat (with Collator)\n      case 'list':\n        if (callback) {\n          return sortList(\n            locale, value, callback,\n            applyArgs({type: 'LIST'}),\n            applyArgs({\n              type: 'LIST', options: extraOpts, checkArgOptions: true\n            })\n          );\n        }\n        return sortList(locale, value, applyArgs({type: 'LIST'}), applyArgs({\n          type: 'LIST', options: extraOpts, checkArgOptions: true\n        }));\n      default:\n        // Let `number` and `date` types drop through so their options\n        //  can be applied\n        // Let `plural` be treated as number (since value should be a number)\n        break;\n      }\n    }\n  }\n\n  // Numbers\n  if (typeof value === 'number') {\n    return new Intl.NumberFormat(\n      locale,\n      applyArgs({type: 'NUMBER'})\n    ).format(value);\n  }\n\n  // Dates\n  if (\n    value && typeof value === 'object' &&\n    typeof value.getTime === 'function'\n  ) {\n    return new Intl.DateTimeFormat(\n      locale,\n      applyArgs({type: 'DATETIME'})\n    ).format(value);\n  }\n\n  // console.log('value', value);\n  throw new TypeError('Unknown formatter');\n};\n","import {getMessageForKeyByStyle} from './index.js';\nimport {parseJSONExtra} from './utils.js';\nimport {getFormatterInfo} from './defaultAllSubstitutions.js';\n\n/**\n * Base class for formatting.\n */\nexport class Formatter {\n}\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.key\n * @param {LocaleBody} cfg.body\n * @param {string} cfg.type\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} cfg.messageStyle\n * @returns {string|Element}\n */\nconst getSubstitution = ({key, body, type, messageStyle = 'richNested'}) => {\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const substitution = messageForKey({body}, key);\n  if (!substitution) {\n    throw new Error(`Key value not found for ${type} key: (${key})`);\n  }\n  // We don't allow a substitution function here or below as comes\n  //  from locale and locale content should not pose security concerns\n  return substitution.value;\n};\n\n/**\n * Formatter for local variables.\n */\nexport class LocalFormatter extends Formatter {\n  /**\n   * @param {LocalObject} locals\n   */\n  constructor (locals) {\n    super();\n    this.locals = locals;\n  }\n  /**\n   * @param {string} key\n   * @returns {string|Element}\n   */\n  getSubstitution (key) {\n    return getSubstitution({\n      key: key.slice(1), body: this.locals, type: 'local'\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    const components = key.slice(1).split('.');\n    let parent = this.locals;\n    return this.constructor.isMatchingKey(key) && components.every((cmpt) => {\n      const result = cmpt in parent;\n      parent = parent[cmpt];\n      return result;\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('-');\n  }\n}\n\n/**\n * Formatter for regular variables.\n */\nexport class RegularFormatter extends Formatter {\n  /**\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (substitutions) {\n    super();\n    this.substitutions = substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return this.constructor.isMatchingKey(key) && key in this.substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return (/^\\w/u).test(key);\n  }\n}\n\n/**\n * Formatter for switch variables.\n */\nexport class SwitchFormatter extends Formatter {\n  /**\n   * @param {Switches} switches\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (switches, {substitutions}) {\n    super();\n    this.switches = switches;\n    this.substitutions = substitutions;\n  }\n\n  /**\n   * @param {string} key\n   * @param {PlainObject} cfg\n   * @param {string} cfg.locale\n   * @param {string[]} cfg.usedKeys\n   * @param {string} cfg.arg\n   * @param {MissingSuppliedFormattersCallback} cfg.missingSuppliedFormatters\n   * @returns {string}\n   */\n  getSubstitution (key, {locale, usedKeys, arg, missingSuppliedFormatters}) {\n    const ky = this.constructor.getKey(key).slice(1);\n    // Expression might not actually use formatter, e.g., for singular,\n    //  the conditional might just write out \"one\"\n\n    const [objKey, body, keySegment] = this.getMatch(ky);\n    usedKeys.push(keySegment);\n\n    let type, opts;\n    if (objKey && objKey.includes('|')) {\n      [, type, opts] = objKey.split('|');\n    }\n    if (!body) {\n      missingSuppliedFormatters({\n        key,\n        formatter: this\n      });\n      return '\\\\{' + key + '}';\n    }\n\n    /*\n    if (!(ky in this.substitutions)) {\n      throw new Error(`Switch expecting formatter: ${ky}`);\n    }\n    */\n\n    const getNumberFormat = (value, defaultOptions) => {\n      const numberOpts = parseJSONExtra(opts);\n      return new Intl.NumberFormat(locale, {\n        ...defaultOptions, ...numberOpts\n      }).format(value);\n    };\n\n    const getPluralFormat = (value, defaultOptions) => {\n      const pluralOpts = parseJSONExtra(opts);\n      return new Intl.PluralRules(locale, {\n        ...defaultOptions, ...pluralOpts\n      }).select(value);\n    };\n\n    const formatterValue = this.substitutions[keySegment];\n\n    let match = formatterValue;\n    if (typeof formatterValue === 'number') {\n      switch (type) {\n      case 'NUMBER':\n        match = getNumberFormat(formatterValue);\n        break;\n      case 'PLURAL':\n        match = getPluralFormat(formatterValue);\n        break;\n      default:\n        match = new Intl.PluralRules(locale).select(formatterValue);\n        break;\n      }\n    } else if (formatterValue && typeof formatterValue === 'object') {\n      const singleKey = Object.keys(formatterValue)[0];\n      if (['number', 'plural'].includes(singleKey)) {\n        const {value, options} = getFormatterInfo({\n          object: formatterValue[singleKey]\n        });\n        if (!type) {\n          type = singleKey.toUpperCase();\n        }\n        const typeMatches = singleKey.toUpperCase() === type;\n        if (!typeMatches) {\n          throw new TypeError(\n            `Expecting type \"${\n              type.toLowerCase()\n            }\"; instead found \"${singleKey}\".`\n          );\n        }\n        // eslint-disable-next-line default-case\n        switch (type) {\n        case 'NUMBER':\n          match = getNumberFormat(value, options);\n          break;\n        case 'PLURAL':\n          match = getPluralFormat(value, options);\n          break;\n        }\n      }\n    }\n\n    // We do not want the default `richNested` here as that will split\n    //  up the likes of `0.0`\n    const messageStyle = 'richNested';\n\n    const preventNesting = (s) => {\n      return s.replace(/\\\\/gu, '\\\\\\\\').replace(/\\./gu, '\\\\.');\n    };\n\n    try {\n      return getSubstitution({\n        messageStyle,\n        key: match ? preventNesting(match) : arg,\n        body,\n        type: 'switch'\n      });\n    } catch (err) {\n      try {\n        return getSubstitution({\n          messageStyle, key: '*' + preventNesting(match), body, type: 'switch'\n        });\n      } catch (error) {\n        const k = Object.keys(body).find(\n          (switchKey) => switchKey.startsWith('*')\n        );\n        if (!k) {\n          throw new Error(`No defaults found for switch ${ky}`);\n        }\n        return getSubstitution({\n          messageStyle, key: preventNesting(k), body, type: 'switch'\n        });\n      }\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return key && this.constructor.isMatchingKey(key) &&\n      Boolean(this.getMatch(key.slice(1)).length);\n  }\n\n  /**\n  * @typedef {GenericArray} SwitchMatch\n  * @property {string} 0 objKey\n  * @property {LocaleBody} 1 body\n  * @property {string} 2 keySegment\n  */\n\n  /**\n   * @param {string} ky\n   * @returns {SwitchMatch}\n   */\n  getMatch (ky) {\n    const ks = ky.split('.');\n    return ks.reduce((obj, k, i) => {\n      if (i < ks.length - 1) {\n        if (!(k in obj)) {\n          throw new Error(`Switch key \"${k}\" not found (from \"~${ky}\")`);\n        }\n        return obj[k];\n      }\n      // Todo: Should throw on encountering duplicate fundamental keys (even\n      //  if there are different arguments, that should not be allowed)\n      const ret = Object.entries(obj).find(([switchKey]) => {\n        return k === this.constructor.getKey(switchKey);\n      });\n\n      return ret ? ret.concat(k) : [];\n    }, this.switches);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('~');\n  }\n  /**\n   * @param {string} key\n   * @returns {string}\n   */\n  static getKey (key) {\n    const match = key.match(/^[^|]*/u);\n    return match && match[0];\n  }\n}\n","/**\n* @callback PromiseChainErrback\n* @param {any} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @param {string} [errorMessage=\"Reached end of values array.\"]\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\n promiseChainForValues(['a', 'b', 'c'], (val) => {\n   return new Promise(function (resolve, reject) {\n     if (val === 'a') {\n       reject(new Error('missing'));\n     }\n     setTimeout(() => {\n       resolve(val);\n     }, 100);\n   });\n });\n */\nexport const promiseChainForValues = (\n  values, errBack, errorMessage = 'Reached end of values array.'\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(\n      'The `values` argument to `promiseChainForValues` must be an array.'\n    );\n  }\n  if (typeof errBack !== 'function') {\n    throw new TypeError(\n      'The `errBack` argument to `promiseChainForValues` must be a function.'\n    );\n  }\n  return (async () => {\n    let ret;\n    let p = Promise.reject(\n      new Error('Intentionally reject so as to begin checking chain')\n    );\n    let breaking;\n    while (true) {\n      const value = values.shift();\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        ret = await p;\n        break;\n      } catch (err) {\n        if (breaking) {\n          throw new Error(errorMessage);\n        }\n        // We allow one more try\n        if (!values.length) {\n          breaking = true;\n        }\n        // // eslint-disable-next-line no-await-in-loop\n        p = errBack(value);\n      }\n    }\n    return ret;\n  })();\n};\n","/**\n* @callback SubstitutionCallback\n* @param {PlainObject} cfg\n* @param {string} cfg.arg By default, accepts the third portion of the\n*   `formattingRegex` within `insertNodes`, i.e., to allow the locale to\n*   supply arguments back to the calling script.\n* @param {string} cfg.key The substitution key\n* @returns {string|Element} The replacement text or element\n*/\n\n/**\n * May have additional properties if supplying options to an underlying\n * formatter.\n * @typedef {GenericArray} ValueArray\n * @property {string|Node|number|Date} 0 The main value\n * @property {PlainObject} [1] The options related to the main value\n * @property {PlainObject} [2] Any additional options\n*/\n\n/**\n* @typedef {PlainObject} RelativeTimeInfo\n* @property {ValueArray} relative\n*/\n\n/**\n* @typedef {PlainObject} ListInfo\n* @property {ValueArray} list\n*/\n\n/**\n* @typedef {PlainObject} NumberInfo\n* @property {ValueArray} number\n*/\n\n/**\n* @typedef {PlainObject} DateInfo\n* @property {ValueArray} date\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringBodyObject\n*/\n\n/**\n* @typedef {PlainObject} SwitchCaseInfo\n* @property {boolean} [default=false] Whether this conditional is the default\n*/\n\n/**\n* @typedef {GenericArray} SwitchCase\n* @property {string} 0 The type\n* @property {string} 1 The message\n* @property {SwitchCaseInfo} [2] Info about the switch case\n*/\n\n/**\n* @typedef {PlainObject<string, SwitchCase>} Switch\n*/\n\n/**\n* @typedef {PlainObject<{string, Switch}>} Switches\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} [message] The locale message with any formatting\n*   place-holders; defaults to use of any single conditional\n* @property {string} [description] A description to add translators\n* @property {Switches} [switches] Conditionals\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringBodyObject\n*/\n\n/**\n * Takes a base path and locale and gives a URL.\n * @callback LocaleResolver\n * @param {string} localesBasePath (Trailing slash optional)\n * @param {string} locale BCP-47 language string\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|SubstitutionCallback>}\n*   SubstitutionObject\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (localesBasePath, locale) => {\n  if (typeof localesBasePath !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `localesBasePath`.'\n    );\n  }\n  if (typeof locale !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `locale`.'\n    );\n  }\n  if ((/[./\\\\]/u).test(locale)) {\n    throw new TypeError(\n      'Locales cannot use file-reserved characters, `.`, `/` or `\\\\`'\n    );\n  }\n  return `${localesBasePath.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n","import {\n  LocalFormatter, RegularFormatter, SwitchFormatter\n} from './Formatter.js';\nimport {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {unescapeBackslashes, parseJSONExtra, processRegex} from './utils.js';\n\n/* eslint-disable max-len */\n/**\n * Callback to return a string or array of nodes and strings based on a localized\n * string, substitutions object, and other metadata.\n * @callback InsertNodesCallback\n * @param {PlainObject} cfg\n * @param {string} cfg.string The localized string\n * @param {boolean} [cfg.dom] If substitutions known to contain DOM, can be set\n *   to `true` to optimize\n * @param {string[]} [cfg.usedKeys=[]] Array for tracking which keys have been used\n * @param {SubstitutionObject} cfg.substitutions The formatting substitutions object\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions] The\n *   callback or array composed thereof for applying to each substitution.\n * @param {string} locale The successfully resolved locale\n * @param {Integer} [maximumLocalNestingDepth=3] Depth of local variable resolution to\n *   check before reporting a recursion error\n * @param {MissingSuppliedFormattersCallback} [cfg.missingSuppliedFormatters] Callback\n *   supplied key to throw if the supplied key is present (if\n *   `throwOnMissingSuppliedFormatters` is enabled). Defaults to no-op.\n * @param {CheckExtraSuppliedFormattersCallback} [cfg.checkExtraSuppliedFormatters] No\n *   argument callback to check if any formatters are not present in `string`\n *   (if `throwOnExtraSuppliedFormatters` is enabled). Defaults to no-op.\n * @returns {string|Array<Node|string>}\n */\n\n/**\n * @type {InsertNodesCallback}\n */\nexport const defaultInsertNodes = ({\n  /* eslint-enable max-len */\n  string, dom, usedKeys, substitutions, allSubstitutions, locale,\n  locals, switches,\n  maximumLocalNestingDepth = 3,\n  missingSuppliedFormatters,\n  checkExtraSuppliedFormatters\n}) => {\n  if (typeof maximumLocalNestingDepth !== 'number') {\n    throw new TypeError('`maximumLocalNestingDepth` must be a number.');\n  }\n  const localFormatter = new LocalFormatter(locals);\n  const regularFormatter = new RegularFormatter(substitutions);\n  const switchFormatter = new SwitchFormatter(switches, {substitutions});\n\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  const formattingRegex = /(\\\\*)\\{((?:[^}]|\\\\\\})*?)(?:(\\|)([^}]*))?\\}/gu;\n  if (allSubstitutions) {\n    allSubstitutions = Array.isArray(allSubstitutions)\n      ? allSubstitutions\n      : [allSubstitutions];\n  }\n\n  const getSubstitution = ({key, arg, substs}) => {\n    let substitution;\n    const isLocalKey = localFormatter.constructor.isMatchingKey(key);\n    if (isLocalKey) {\n      substitution = localFormatter.getSubstitution(key);\n    } else if (switchFormatter.constructor.isMatchingKey(key)) {\n      substitution = switchFormatter.getSubstitution(key, {\n        locale, usedKeys, arg,\n        missingSuppliedFormatters\n      });\n    } else {\n      substitution = substs[key];\n      if (typeof substitution === 'function') {\n        substitution = substitution({arg, key});\n      }\n    }\n    // Todo: Could support resolving locals within arguments\n    // Todo: Even for `null` `allSubstitutions`, we could have\n    //  a mode to throw for non-string/non-DOM (non-numbers?),\n    //  or whatever is not likely intended as a target for `toString()`.\n    if (allSubstitutions) {\n      substitution = allSubstitutions.reduce((subst, allSubst) => {\n        return allSubst({\n          value: subst, arg, key, locale\n        });\n      }, substitution);\n    } else if (arg && arg.match(/^(?:NUMBER|DATE(?:TIME)?|RELATIVE|LIST)(?:\\||$)/u)) {\n      substitution = defaultAllSubstitutions({\n        value: substitution, arg, key, locale\n      });\n    }\n    return substitution;\n  };\n\n  let recursiveLocalCount = 1;\n  const checkLocalVars = ({substitution, ky, arg, processSubsts}) => {\n    if (\n      typeof substitution === 'string' &&\n      substitution.includes('{')\n    ) {\n      if (recursiveLocalCount++ > maximumLocalNestingDepth) {\n        throw new TypeError('Too much recursion in local variables.');\n      }\n\n      if (localFormatter.constructor.isMatchingKey(ky)) {\n        let extraSubsts = substitutions;\n        let localFormatters;\n        if (arg) {\n          localFormatters = parseJSONExtra(arg);\n          extraSubsts = {\n            ...substitutions,\n            ...localFormatters\n          };\n        }\n        substitution = processSubsts({\n          str: substitution, substs: extraSubsts,\n          formatter: localFormatter\n        });\n        if (localFormatters) {\n          checkExtraSuppliedFormatters({substitutions: localFormatters});\n        }\n      } else if (switchFormatter.constructor.isMatchingKey(ky)) {\n        substitution = processSubsts({\n          str: substitution\n        });\n      }\n    }\n    return substitution;\n  };\n\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    // Run this block to optimize non-DOM substitutions\n    let returnsDOM = false;\n    const replace = ({\n      str, substs = substitutions,\n      formatter = regularFormatter\n    }) => {\n      return str.replace(formattingRegex, (_, esc, ky, pipe, arg) => {\n        if (esc.length % 2) {\n          return _;\n        }\n        if (missingSuppliedFormatters({\n          key: ky,\n          formatter\n        })) {\n          return _;\n        }\n        let substitution = getSubstitution({key: ky, arg, substs});\n\n        substitution = checkLocalVars({\n          substitution, ky, arg, processSubsts: replace\n        });\n\n        returnsDOM = returnsDOM ||\n          (substitution && typeof substitution === 'object' &&\n          'nodeType' in substitution);\n        usedKeys.push(ky);\n        return esc + substitution;\n      });\n    };\n    const ret = replace({str: string});\n    if (!returnsDOM) {\n      checkExtraSuppliedFormatters({substitutions});\n      usedKeys.length = 0;\n      return unescapeBackslashes(ret);\n    }\n    usedKeys.length = 0;\n  }\n\n  recursiveLocalCount = 1;\n  const processSubstitutions = ({\n    str, substs = substitutions, formatter = regularFormatter\n  }) => {\n    const nodes = [];\n\n    // Copy to ensure we are resetting index on each instance (manually\n    // resetting on `formattingRegex` is problematic with recursion that\n    // uses the same regex copy)\n    const regex = new RegExp(formattingRegex, 'gu');\n\n    const push = (...args) => {\n      nodes.push(...args);\n    };\n\n    processRegex(regex, str, {\n      extra: push,\n      onMatch (_, esc, ky, pipe, arg) {\n        if (missingSuppliedFormatters({\n          key: ky, formatter\n        })) {\n          push(_);\n        } else {\n          if (esc.length) {\n            push(esc);\n          }\n\n          let substitution = getSubstitution({key: ky, arg, substs});\n          substitution = checkLocalVars({\n            substitution, ky, arg, processSubsts: processSubstitutions\n          });\n          if (Array.isArray(substitution)) {\n            push(...substitution);\n          } else if (\n            // Clone so that multiple instances may be added (and no\n            // side effects to user code)\n            substitution && typeof substitution === 'object' &&\n            'nodeType' in substitution\n          ) {\n            push(substitution.cloneNode(true));\n          } else {\n            push(substitution);\n          }\n        }\n        usedKeys.push(ky);\n      }\n    });\n    return nodes;\n  };\n  const nodes = processSubstitutions({str: string});\n\n  checkExtraSuppliedFormatters({substitutions});\n  usedKeys.length = 0;\n  return nodes.map((node) => {\n    if (typeof node === 'string') {\n      return unescapeBackslashes(node);\n    }\n    return node;\n  });\n};\n","import {unescapeBackslashes, processRegex} from './utils.js';\n\n/**\n* @typedef {LocaleBody} LocalObject\n*/\n\n/**\n * May also contain language code and direction, translator name and\n * contact, etc., but no defaults currently apply besides reserving `locals`\n * @typedef {PlainObject} LocaleHead\n * @property {LocalObject} locals\n*/\n\n/**\n* @typedef {LocaleStringBodyObject|PlainLocaleStringBodyObject|PlainObject}\n* LocaleBody\n*/\n\n/**\n* @typedef {PlainObject} LocaleObject\n* @property {LocaleHead} [head]\n* @property {LocaleBody} body\n*/\n\n/**\n* @typedef {PlainObject} MessageStyleCallbackResult\n* @property {string} value Regardless of message style, will contain the\n*   string result\n* @property {LocaleStringSubObject} [info] Full info on the localized item\n*   (for rich message styles only)\n*/\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|MessageStyleCallbackResult} If `false`, will resort to default\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='richNested']\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  /* eslint-enable max-len */\n  messageStyle = 'richNested'\n} = {}) => {\n  // Todo: Support `plainNested` style\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'richNested'\n      ? (mainObj, key) => {\n        const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n        const keys = [];\n        // eslint-disable-next-line prefer-named-capture-group\n        const possiblyEscapedCharPattern = /(\\\\*)\\./gu;\n        const mergeWithPreviousOrStart = (val) => {\n          if (!keys.length) {\n            keys[0] = '';\n          }\n          keys[keys.length - 1] += val;\n        };\n        processRegex(possiblyEscapedCharPattern, key, {\n          // If odd, this is just an escaped dot, so merge content with\n          //   any previous\n          extra: mergeWithPreviousOrStart,\n          onMatch (_, esc) {\n            // If even, there are no backslashes, or they are just escaped\n            //  backslashes and not an escaped dot, so start anew, though\n            //  first merge any backslashes\n            mergeWithPreviousOrStart(esc);\n            keys.push('');\n          }\n        });\n        const keysUnescaped = keys.map((ky) => {\n          return unescapeBackslashes(ky);\n        });\n\n        let ret = false;\n        let currObj = obj;\n        keysUnescaped.some((ky, i, kys) => {\n          if (!currObj || typeof currObj !== 'object') {\n            return true;\n          }\n          if (\n            // If specified key is too deep, we should fail\n            i === kys.length - 1 &&\n            ky in currObj && currObj[ky] && typeof currObj[ky] === 'object' &&\n            'message' in currObj[ky] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof currObj[ky].message === 'string'\n          ) {\n            ret = {\n              value: currObj[ky].message,\n              info: currObj[ky]\n            };\n          }\n          currObj = currObj[ky];\n\n          return false;\n        });\n        return ret;\n      }\n      : (messageStyle === 'rich'\n        ? (mainObj, key) => {\n          const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n          if (\n            obj && typeof obj === 'object' &&\n            key in obj && obj[key] && typeof obj[key] === 'object' &&\n            'message' in obj[key] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof obj[key].message === 'string'\n          ) {\n            return {\n              value: obj[key].message,\n              info: obj[key]\n            };\n          }\n          return false;\n        }\n        : (messageStyle === 'plain'\n          ? (mainObj, key) => {\n            const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n            if (\n              obj && typeof obj === 'object' &&\n              key in obj && obj[key] && typeof obj[key] === 'string'\n            ) {\n              return {\n                value: obj[key]\n              };\n            }\n            return false;\n          }\n          : (() => {\n            throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n          })())\n      )\n    );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message] If present, this string will be the return value.\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='richNested']\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings; used to find a default if no string `message` is provided.\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n} = {}) => {\n  if (typeof key !== 'string') {\n    throw new TypeError(\n      'An options object with a `key` string is expected on ' +\n      '`getStringFromMessageAndDefaults`'\n    );\n  }\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  let str;\n  if (typeof message === 'string') {\n    str = message;\n  } else if (\n    defaults === false || defaults === undefined || defaults === null\n  ) {\n    str = false;\n  } else if (defaults && typeof defaults === 'object') {\n    str = messageForKey({body: defaults}, key);\n    if (str) {\n      str = str.value;\n    }\n  } else {\n    throw new TypeError(\n      `Default locale strings must resolve to \\`false\\`, ` +\n      `nullish, or an object!`\n    );\n  }\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n","import {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {defaultInsertNodes} from './defaultInsertNodes.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/* eslint-disable max-len */\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {string} cfg.locale The (possibly already resolved) locale for use by\n *   configuring formatters\n * @param {LocalObject} [cfg.locals]\n * @param {LocalObject} [cfg.switches]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions=[defaultAllSubstitutions]]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  /* eslint-enable max-len */\n  string,\n  locale,\n  locals,\n  switches,\n  maximumLocalNestingDepth,\n  allSubstitutions = [\n    defaultAllSubstitutions\n  ],\n  insertNodes = defaultInsertNodes,\n  substitutions = false,\n  dom = false,\n  forceNodeReturn = false,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true\n} = {}) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'An options object with a `string` property set to a string must ' +\n      'be provided for `getDOMForLocaleString`.'\n    );\n  }\n  const stringOrTextNode = (str) => {\n    const _doc = getDocument();\n    return forceNodeReturn ? _doc.createTextNode(str) : str;\n  };\n\n  const usedKeys = [];\n\n  /**\n  * @callback CheckExtraSuppliedFormattersCallback\n  * @param {SubstitutionObject} substs\n  * @throws {Error} Upon an extra formatting key being found\n  * @returns {void}\n  */\n\n  /**\n   * @type {CheckExtraSuppliedFormattersCallback}\n   */\n  const checkExtraSuppliedFormatters = ({\n    substitutions: substs\n  }) => {\n    if (throwOnExtraSuppliedFormatters) {\n      Object.keys(substs).forEach((key) => {\n        if (!usedKeys.includes(key)) {\n          throw new Error(`Extra formatting key: ${key}`);\n        }\n      });\n    }\n  };\n\n  /**\n  * @callback MissingSuppliedFormattersCallback\n  * @param {string} key\n  * @param {SubstitutionObject} substs\n  * @throws {Error} If missing formatting key\n  * @returns {boolean}\n  */\n  /**\n   * @type {MissingSuppliedFormattersCallback}\n   */\n  const missingSuppliedFormatters = ({\n    key, formatter\n  }) => {\n    const matching = formatter.isMatch(key);\n    if (formatter.constructor.isMatchingKey(key) && !matching) {\n      if (throwOnMissingSuppliedFormatters) {\n        throw new Error(`Missing formatting key: ${key}`);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  if (\n    !substitutions && !allSubstitutions &&\n    !throwOnMissingSuppliedFormatters\n  ) {\n    return stringOrTextNode(string);\n  }\n  if (!substitutions) {\n    substitutions = {};\n  }\n\n  const nodes = insertNodes({\n    string, dom, usedKeys, substitutions, allSubstitutions, locale,\n    locals, switches,\n    missingSuppliedFormatters,\n    checkExtraSuppliedFormatters\n  });\n  if (typeof nodes === 'string') {\n    return stringOrTextNode(nodes);\n  }\n\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n\n  return container;\n};\n","/* globals intlDomLocale */\n\nimport {defaultLocaleResolver} from './defaultLocaleResolver.js';\nimport {promiseChainForValues} from './promiseChainForValues.js';\nimport {getFetch} from './shared.js';\n\nexport {setFetch, getFetch} from './shared.js';\n\n/**\n * Takes a locale and returns a new locale to check.\n * @callback LocaleMatcher\n * @param {string} locale The failed locale\n * @throws If there are no further hyphens left to check\n * @returns {string|Promise<string>} The new locale to check\n*/\n\n/**\n * @type {LocaleMatcher}\n */\nexport const defaultLocaleMatcher = (locale) => {\n  if (!locale.includes('-')) {\n    throw new Error('Locale not available');\n  }\n  // Try without hyphen, i.e., the \"lookup\" algorithm:\n  // See https://tools.ietf.org/html/rfc4647#section-3.4 and\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\n  return locale.replace(/-[^-]*$/u, '');\n};\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.locale\n * @param {string[]} cfg.locales\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleMatcher}]\n * @returns {string|false}\n */\nexport const getMatchingLocale = ({\n  locale, locales, localeResolver = defaultLocaleMatcher\n}) => {\n  try {\n    while (!locales.includes(locale)) {\n      // Catch as `defaultLocaleMatcher` will throw if no hyphen found\n      locale = localeResolver(locale);\n    }\n  } catch (err) {\n    return false;\n  }\n  return locale;\n};\n\n/**\n* @typedef {PlainObject} LocaleObjectInfo\n* @property {LocaleObject} strings The successfully retrieved locale strings\n* @property {string} locale The successfully resolved locale\n*/\n\n/**\n * @callback LocaleStringFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<LocaleObjectInfo>}\n */\n\n/**\n *\n * @type {LocaleStringFinder}\n */\nexport const findLocaleStrings = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n};\n\n/**\n * @callback LocaleFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<string>} Resolves to the successfully resolved locale\n */\n\n/**\n *\n * @type {LocaleFinder}\n */\nexport const findLocale = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher,\n    headOnly: true\n  });\n};\n\n/**\n * @type {LocaleStringFinder|LocaleFinder} Also has a `headOnly` boolean\n *  property to determine whether to make a simple HEAD and resolve to\n *  the locale rather than locale and contents\n */\nconst _findLocale = async ({\n  locales = typeof intlDomLocale !== 'undefined'\n    ? [intlDomLocale]\n    : typeof navigator === 'undefined' ? [] : navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.',\n  localeMatcher = 'lookup',\n  headOnly = false\n}) => {\n  /**\n   * @callback getLocale\n   * @throws {SyntaxError|TypeError|Error}\n   * @param {string} locale\n   * @returns {Promise<LocaleObjectInfo>}\n   */\n  async function getLocale (locale) {\n    if (typeof locale !== 'string') {\n      throw new TypeError('Non-string locale type');\n    }\n    const url = localeResolver(localesBasePath, locale);\n    if (typeof url !== 'string') {\n      throw new TypeError(\n        '`localeResolver` expected to resolve to (URL) string.'\n      );\n    }\n    try {\n      const _fetch = getFetch();\n      const resp = await (headOnly\n        ? _fetch(url, {\n          method: 'HEAD'\n        })\n        : _fetch(url)\n      );\n\n      if (resp.status === 404) {\n        // Don't allow browser (tested in Firefox) to continue\n        //  and give `SyntaxError` with missing file or we won't be\n        //  able to try without the hyphen\n        throw new Error('Trying again');\n      }\n      if (headOnly) {\n        return locale;\n      }\n      const strings = await (resp.json());\n      return {\n        locale,\n        strings\n      };\n    } catch (err) {\n      if (err.name === 'SyntaxError') {\n        throw err;\n      }\n      const newLocale = await localeMatcher(locale);\n      return getLocale(newLocale);\n    }\n  }\n  if (localeMatcher === 'lookup') {\n    localeMatcher = defaultLocaleMatcher;\n  } else if (typeof localeMatcher !== 'function') {\n    throw new TypeError('`localeMatcher` must be \"lookup\" or a function!');\n  }\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    getLocale,\n    'No matching locale found!'\n  );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\nimport {findLocaleStrings} from './findLocaleStrings.js';\nimport {getDOMForLocaleString} from './getDOMForLocaleString.js';\nimport {\n  getStringFromMessageAndDefaults\n} from './getStringFromMessageAndDefaults.js';\nimport {sort, sortList, list} from './collation.js';\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present.\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {LocaleObject} cfg.strings\n * @param {string} cfg.resolvedLocale\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='richNested']\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18nServer = function i18nServer ({\n  /* eslint-enable max-len */\n  strings,\n  resolvedLocale,\n  messageStyle,\n  allSubstitutions: defaultAllSubstitutionsValue,\n  insertNodes,\n  defaults: defaultDefaults,\n  substitutions: defaultSubstitutions,\n  maximumLocalNestingDepth,\n  dom: domDefaults = false,\n  forceNodeReturn: forceNodeReturnDefault = false,\n  throwOnMissingSuppliedFormatters:\n    throwOnMissingSuppliedFormattersDefault = true,\n  throwOnExtraSuppliedFormatters:\n    throwOnExtraSuppliedFormattersDefault = true\n}) {\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const formatter = (key, substitutions, {\n    allSubstitutions = defaultAllSubstitutionsValue,\n    defaults = defaultDefaults,\n    dom = domDefaults,\n    forceNodeReturn = forceNodeReturnDefault,\n    throwOnMissingSuppliedFormatters = throwOnMissingSuppliedFormattersDefault,\n    throwOnExtraSuppliedFormatters = throwOnExtraSuppliedFormattersDefault\n  } = {}) => {\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message: (message && message.value) || false,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      locals: strings.head && strings.head.locals,\n      switches: strings.head && strings.head.switches,\n      locale: resolvedLocale,\n      maximumLocalNestingDepth,\n      allSubstitutions,\n      insertNodes,\n      substitutions: {...defaultSubstitutions, ...substitutions},\n      dom,\n      forceNodeReturn,\n      throwOnMissingSuppliedFormatters,\n      throwOnExtraSuppliedFormatters\n    });\n  };\n\n  formatter.resolvedLocale = resolvedLocale;\n  formatter.strings = strings;\n\n  formatter.sort = (...args) => {\n    return sort(resolvedLocale, ...args);\n  };\n\n  formatter.sortList = (...args) => {\n    return sortList(\n      resolvedLocale, ...args\n    );\n  };\n\n  formatter.list = (...args) => {\n    return list(\n      resolvedLocale, ...args\n    );\n  };\n\n  return formatter;\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {LocaleStringFinder} [cfg.localeStringFinder=findLocaleStrings]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher='lookup']\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='richNested']\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localeStringFinder = findLocaleStrings,\n  localesBasePath,\n  localeResolver,\n  localeMatcher,\n  messageStyle,\n  allSubstitutions,\n  insertNodes,\n  defaults,\n  substitutions,\n  maximumLocalNestingDepth,\n  dom,\n  forceNodeReturn,\n  throwOnMissingSuppliedFormatters,\n  throwOnExtraSuppliedFormatters\n} = {}) {\n  const {strings, locale: resolvedLocale} = await localeStringFinder({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n\n  return i18nServer({\n    strings,\n    resolvedLocale,\n    messageStyle,\n    allSubstitutions,\n    insertNodes,\n    defaults,\n    substitutions,\n    maximumLocalNestingDepth,\n    dom,\n    forceNodeReturn,\n    throwOnMissingSuppliedFormatters,\n    throwOnExtraSuppliedFormatters\n  });\n};\n"],"names":["lib","fn","module","exports","createCommonjsModule","contexts","getContext","ctx","pop","context","elements","element_array","dropContext","push","buffers","dropBuffer","buf","JSON6","escape","string","n","output","length","begin","cb","reviver","val","name","value_type","contains","pos","line","col","str","word","status","negative","result","undefined","context_stack","first","last","saved","node","recover","this","next","prior","parse_context","comment","fromHex","decimal","exponent","exponent_sign","exponent_digit","inQueue","shift","unshift","gatheringStringFirstChar","gatheringString","gatheringNumber","stringEscape","cr_escaped","unicodeWide","stringUnicode","stringHex","hex_char","hex_char_len","stringOct","completed","value","r","reset","save","write","msg","retcode","String","_write","walk","holder","key","k","v","Object","prototype","hasOwnProperty","call","complete_at_end","cInt","input","retval","throwError","leader","c","Error","fromCodePoint","substr","RESET_VAL","numberConvert","charCodeAt","Number","arrayPush","NaN","Infinity","console","log","objectPush","gatherString","start_c","charAt","codePointAt","collectNumber","_n","getBuffer","string_status","old_context","tmpobj","tmparr","FALSE","thorwError","_parser","freeze","_parse_level","parse","parser","parse_level","stringify","JSON","unescapeBackslashes","replace","esc","slice","parseJSONExtra","args","jsonExtra","processRegex","regex","match","onMatch","extra","betweenMatches","afterMatch","escapeAtOne","previousIndex","exec","_","lastIndex","startMatchPos","_fetch","fetch","getFetch","_doc","document","getDocument","sort","locale","arrayOfItems","options","Intl","Collator","compare","list","ListFormat","format","sortList","map","listOptions","collationOptions","sortListSimple","d","randomId","Date","getTime","performance","now","Math","random","floor","toString","placeholderArray","_toConsumableArray","i","nodes","RegExp","idx","container","createDocumentFragment","append","getFormatterInfo","object","Array","isArray","callback","extraOpts","defaultAllSubstitutions","opts","arg","_typeof","applyArgs","type","checkArgOptions","split","userType","extraArgs","argOptions","singleKey","keys","includes","RelativeTimeFormat","NumberFormat","DateTimeFormat","TypeError","Formatter","getSubstitution","body","messageStyle","substitution","getMessageForKeyByStyle","messageForKey","LocalFormatter","locals","components","parent","constructor","isMatchingKey","every","cmpt","startsWith","RegularFormatter","substitutions","test","SwitchFormatter","switches","usedKeys","missingSuppliedFormatters","ky","getKey","getMatch","objKey","keySegment","formatter","getNumberFormat","defaultOptions","numberOpts","getPluralFormat","pluralOpts","PluralRules","select","formatterValue","toUpperCase","toLowerCase","preventNesting","s","err","error","find","switchKey","Boolean","ks","reduce","obj","ret","entries","_this4","concat","then","direct","Promise","resolve","e","pact","state","o","_settle","bind","observer","_Pact","onFulfilled","onRejected","_this","thenable","update","stage","shouldContinue","_isSettledPact","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","f","arguments","apply","promiseChainForValues","values","errBack","errorMessage","_async","breaking","p","defaultLocaleResolver","localesBasePath","defaultInsertNodes","dom","allSubstitutions","maximumLocalNestingDepth","checkExtraSuppliedFormatters","localFormatter","regularFormatter","switchFormatter","formattingRegex","substs","subst","allSubst","recursiveLocalCount","checkLocalVars","processSubsts","localFormatters","extraSubsts","returnsDOM","pipe","processSubstitutions","cloneNode","mainObj","mergeWithPreviousOrStart","keysUnescaped","currObj","some","kys","message","info","getStringFromMessageAndDefaults","defaults","getDOMForLocaleString","insertNodes","forceNodeReturn","throwOnMissingSuppliedFormatters","throwOnExtraSuppliedFormatters","stringOrTextNode","createTextNode","forEach","matching","isMatch","defaultLocaleMatcher","findLocaleStrings","locales","defaultLocales","localeResolver","localeMatcher","_findLocale","getLocale","url","headOnly","method","resp","json","strings","intlDomLocale","navigator","languages","i18nServer","resolvedLocale","defaultAllSubstitutionsValue","defaultDefaults","defaultSubstitutions","domDefaults","forceNodeReturnDefault","throwOnMissingSuppliedFormattersDefault","throwOnExtraSuppliedFormattersDefault","head","localeStringFinder","doc"],"mappings":"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"}