{"version":3,"file":"index.umd.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n* @callback PromiseChainErrback\n* @param {any} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\n promiseChainForValues(['a', 'b', 'c'], (val) => {\n   return new Promise(function (resolve, reject) {\n     if (val === 'a') {\n       reject(new Error('missing'));\n     }\n     setTimeout(() => {\n       resolve(val);\n     }, 100);\n   });\n });\n */\nexport const promiseChainForValues = async (values, errBack) => {\n  let ret;\n  let p = Promise.reject(\n    new Error('Intentionally reject so as to begin checking chain')\n  );\n  while (true) {\n    const value = values.shift();\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      ret = await p;\n      break;\n    } catch (err) {\n      p = errBack(value);\n    }\n  }\n  return ret;\n};\n\n/**\n* @callback SubstitutionCallback\n* @param {string} arg Accepts the second portion of the `bracketRegex` of\n*   `i18n`, i.e., the non-bracketed segments of text from the locale string\n*   following a bracketed segment.\n* @returns {string} The replacement text\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringObject\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} message The locale message with any formatting\n*   place-holders\n* @property {string} description A description to add translators\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringObject\n*/\n\n/**\n * @callback LocaleResolver\n * @param {string} locale BCP-47 language string\n * @param {string} localesBasePth (Trailing slash optional)\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|SubstitutionCallback>}\n*   SubstitutionObject\n*/\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (locale, localesBasePth) => {\n  return `${localesBasePth.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleStringObject|PlainLocaleStringObject|PlainObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|string} If `false`, will resort to default\n*/\n\n/**\n * @param {PlainObject} [cfg]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  messageStyle = 'rich'\n} = {}) => {\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'rich'\n      ? (obj, key) => {\n        if (key in obj && obj[key] && 'message' in obj[key] &&\n          // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n          typeof obj[key].message === 'string'\n        ) {\n          return obj[key].message;\n        }\n        return false;\n      }\n      : (messageStyle === 'plain'\n        ? (obj, key) => {\n          if (key in obj && obj[key] && typeof obj[key] === 'string') {\n            return obj[key];\n          }\n          return false;\n        }\n        : (() => {\n          throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n        })()\n      )\n    );\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message]\n * @param {false|LocaleStringObject|PlainLocaleStringObject|PlainObject} [cfg.defaults]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n}) => {\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  const str = typeof message === 'string'\n    ? message\n    : (defaults === false\n      ? (() => {\n        throw new Error(`Key value not found for key: (${key})`);\n      })()\n      : (defaults && typeof defaults === 'object'\n        ? messageForKey(defaults, key)\n        : (() => {\n          throw new TypeError(\n            `Default locale strings must resolve to \\`false\\` or an object!`\n          );\n        })()\n      )\n    );\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {RegExp} [cfg.bracketRegex=/\\{([^}]*?)(?:\\|([^}]*))?\\}/gu]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnUnsuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnUnsubstitutedFormatters=true]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  string,\n  substitutions,\n  dom,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true,\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  bracketRegex = /\\{([^}]*?)(?:\\|([^}]*))?\\}/gu,\n  forceNodeReturn = false\n}) => {\n  if (!substitutions) {\n    return forceNodeReturn ? document.createTextNode(string) : string;\n  }\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    let returnsDOM = false;\n    // Run this block to optimize non-DOM substitutions\n    const ret = string.replace(bracketRegex, (_, ky, arg) => {\n      let substitution = substitutions[ky];\n      if (typeof substitution === 'function') {\n        substitution = substitution(arg);\n      }\n      returnsDOM = returnsDOM ||\n        (substitution && substitution.nodeType === 1);\n      return substitution;\n    });\n    if (!returnsDOM) {\n      return ret;\n    }\n  }\n  const nodes = [];\n  let result;\n  let previousIndex = 0;\n  while ((result = bracketRegex.exec(string)) !== null) {\n    const {lastIndex} = bracketRegex;\n    const [bracketedKey, ky, arg] = result;\n    let substitution = substitutions[ky];\n    if (typeof substitution === 'function') {\n      substitution = substitution(arg);\n    }\n    const startBracketPos = lastIndex - bracketedKey.length;\n    if (startBracketPos > previousIndex) {\n      nodes.push(string.slice(previousIndex, startBracketPos));\n    }\n    nodes.push(substitution);\n    previousIndex = lastIndex;\n  }\n  if (previousIndex !== string.length) { // Get text at end\n    nodes.push(string.slice(previousIndex));\n  }\n\n  const container = document.createDocumentFragment();\n\n  // console.log('nodes', nodes);\n  container.append(...nodes);\n  return container;\n};\n\n/**\n * @param {PlainObject} [cfg]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @returns {Promise<LocaleStringObject|PlainLocaleStringObject|PlainObject>}\n */\nexport const findLocaleStrings = async ({\n  locales = navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.'\n}) => {\n  // eslint-disable-next-line no-return-await\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    async function getLocale (locale) {\n      const url = localeResolver(locale, localesBasePath);\n      try {\n        return await (await fetch(url)).json();\n      } catch (err) {\n        if (!locale.includes('-')) {\n          throw new Error('Locale not available');\n        }\n        // Try without hyphen\n        return getLocale(locale.replace(/-.*$/u, ''));\n      }\n    }\n  );\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {false|LocaleStringObject|PlainLocaleStringObject|PlainObject} [cfg.defaults]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @param {RegExp} [cfg.bracketRegex=/\\{([^}]*?)(?:\\|([^}]*))?\\}/gu]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localesBasePath,\n  localeResolver,\n  defaults,\n  messageStyle,\n  bracketRegex,\n  forceNodeReturn\n}) {\n  const strings = await findLocaleStrings({\n    locales, defaultLocales, localeResolver, localesBasePath\n  });\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  return (key, substitutions, {dom} = {}) => {\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      substitutions,\n      forceNodeReturn,\n      dom,\n      bracketRegex\n    });\n  };\n};\n"],"names":["promiseChainForValues","values","errBack","p","Promise","reject","Error","value","shift","ret","defaultLocaleResolver","locale","localesBasePth","replace","getMessageForKeyByStyle","messageStyle","obj","key","message","TypeError","getStringFromMessageAndDefaults","defaults","messageForKey","str","_typeof","getDOMForLocaleString","string","substitutions","dom","throwOnExtraSuppliedFormatters","throwOnMissingSuppliedFormatters","bracketRegex","forceNodeReturn","document","createTextNode","returnsDOM","_","ky","arg","substitution","nodeType","result","nodes","previousIndex","exec","lastIndex","bracketedKey","startBracketPos","length","push","slice","container","createDocumentFragment","append","findLocaleStrings","locales","navigator","languages","defaultLocales","localeResolver","localesBasePath","url","fetch","json","includes","getLocale","i18n","strings"],"mappings":"qjDAiCaA,EAAqB,4CAAG,WAAOC,EAAQC,6FAE9CC,EAAIC,QAAQC,OACd,IAAIC,MAAM,qEAGJC,EAAQN,EAAOO,0BAGPL,gBAAZM,gEAGAN,EAAID,EAAQK,2DAGTE,kHAfyB,GAyErBC,EAAwB,SAACC,EAAQC,mBAClCA,EAAeC,QAAQ,MAAQ,yBAAgBF,qBAgB9CG,EAA0B,wEAEnC,OADFC,aAAAA,aAAe,eAEgB,mBAAjBA,EACVA,EACkB,SAAjBA,EACC,SAACC,EAAKC,YACFA,KAAOD,GAAOA,EAAIC,IAAQ,YAAaD,EAAIC,IAEjB,iBAArBD,EAAIC,GAAKC,UAETF,EAAIC,GAAKC,SAIA,UAAjBH,EACC,SAACC,EAAKC,YACFA,KAAOD,GAAOA,EAAIC,IAA4B,iBAAbD,EAAIC,KAChCD,EAAIC,IAIZ,iBACK,IAAIE,2CAAsCJ,IAD/C,IAiBEK,EAAkC,gBAE7CF,IAAAA,QACAG,IAAAA,SACAN,IAAAA,iBACAO,cAAAA,aAAgBR,EAAwB,CAACC,aAAAA,MACzCE,IAAAA,IAGMM,EAAyB,iBAAZL,EACfA,GACc,IAAbG,EACE,iBACK,IAAIf,8CAAuCW,QADhD,GAGAI,GAAgC,WAApBG,EAAOH,GAClBC,EAAcD,EAAUJ,GACvB,iBACK,IAAIE,0EADT,OAOG,IAARI,QACI,IAAIjB,8CAAuCW,eAE5CM,GAgBIE,EAAwB,gBACnCC,IAAAA,OACAC,IAAAA,cACAC,IAAAA,IAEAC,KADAC,mCACAD,iCAGAE,cAAAA,aAAe,4SACfC,oBAEKL,uBACsBM,SAASC,eAAeR,GAAUA,MAGxDE,EAAK,KACJO,GAAa,EAEX1B,EAAMiB,EAAOb,QAAQkB,GAAc,SAACK,EAAGC,EAAIC,OAC3CC,EAAeZ,EAAcU,SACL,mBAAjBE,IACTA,EAAeA,EAAaD,IAE9BH,EAAaA,GACVI,GAA0C,IAA1BA,EAAaC,SACzBD,SAEJJ,SACI1B,UAIPgC,EADEC,EAAQ,GAEVC,EAAgB,EAC4B,QAAxCF,EAASV,EAAaa,KAAKlB,KAAmB,KAC7CmB,EAAad,EAAbc,cACyBJ,KAAzBK,OAAcT,OAAIC,OACrBC,EAAeZ,EAAcU,GACL,mBAAjBE,IACTA,EAAeA,EAAaD,QAExBS,EAAkBF,EAAYC,EAAaE,OAC7CD,EAAkBJ,GACpBD,EAAMO,KAAKvB,EAAOwB,MAAMP,EAAeI,IAEzCL,EAAMO,KAAKV,GACXI,EAAgBE,EAEdF,IAAkBjB,EAAOsB,QAC3BN,EAAMO,KAAKvB,EAAOwB,MAAMP,QAGpBQ,EAAYlB,SAASmB,gCAG3BD,EAAUE,aAAVF,EAAoBT,GACbS,GAWIG,EAAiB,4CAAG,6HAC/BC,QAAAA,aAAUC,UAAUC,gBACpBC,eAAAA,aAAiB,CAAC,eAClBC,eAAAA,aAAiBjD,QACjBkD,gBAAAA,aAAkB,eAGL5D,cACPuD,KAAYG,gDAChB,WAA0B/C,gGAClBkD,EAAMF,EAAehD,EAAQiD,qBAEbE,MAAMD,iCAAME,kFAE3BpD,EAAOqD,SAAS,4BACb,IAAI1D,MAAM,yDAGX2D,EAAUtD,EAAOE,QAAQ,uKAAS,wEAT9BoD,2CAAAA,4IATW,GAqCjBC,EAAI,4CAAG,6HAElBX,IAAAA,QACAG,IAAAA,eACAE,IAAAA,gBACAD,IAAAA,eACAtC,IAAAA,SACAN,IAAAA,aACAgB,IAAAA,aACAC,IAAAA,yBAEsBsB,EAAkB,CACtCC,QAAAA,EAASG,eAAAA,EAAgBC,eAAAA,EAAgBC,gBAAAA,eADrCO,WAG6B,WAAnB3C,EAAO2C,yBACf,IAAIhD,6DAENG,EAAgBR,EAAwB,CAACC,aAAAA,uBACxC,SAACE,EAAKU,gEAAuB,GAAPC,IAAAA,IACrBV,EAAUI,EAAc6C,EAASlD,GACjCS,EAASN,EAAgC,CAC7CF,QAAAA,EACAG,SAAAA,EACAC,cAAAA,EACAL,IAAAA,WAGKQ,EAAsB,CAC3BC,OAAAA,EACAC,cAAAA,EACAK,gBAAAA,EACAJ,IAAAA,EACAG,aAAAA,qGAhCW"}