{"version":3,"file":"index.umd.min.js","sources":["../node_modules/json-6/dist/index.mjs","../src/utils.js","../src/shared.js","../src/collation.js","../src/defaultAllSubstitutions.js","../src/Formatter.js","../src/promiseChainForValues.js","../src/defaultLocaleResolver.js","../src/defaultInsertNodes.js","../src/getMessageForKeyByStyle.js","../src/getStringFromMessageAndDefaults.js","../src/getDOMForLocaleString.js","../src/findLocaleStrings.js","../src/i18n.js"],"sourcesContent":["function createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t  path: basedir,\n\t  exports: {},\n\t  require: function (path, base) {\n      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n    }\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar json6 = createCommonjsModule(function (module, exports) {\n\n  const VALUE_UNDEFINED = -1;\n  const VALUE_UNSET = 0;\n  const VALUE_NULL = 1;\n  const VALUE_TRUE = 2;\n  const VALUE_FALSE = 3;\n  const VALUE_STRING = 4;\n  const VALUE_NUMBER = 5;\n  const VALUE_OBJECT = 6;\n  const VALUE_ARRAY = 7;\n  const VALUE_NEG_NAN = 8;\n  const VALUE_NAN = 9;\n  const VALUE_NEG_INFINITY = 10;\n  const VALUE_INFINITY = 11; // const VALUE_DATE = 12  // unused yet\n\n  const VALUE_EMPTY = 13; // [,] makes an array with 'empty item'\n\n  const WORD_POS_RESET = 0;\n  const WORD_POS_TRUE_1 = 1;\n  const WORD_POS_TRUE_2 = 2;\n  const WORD_POS_TRUE_3 = 3;\n  const WORD_POS_FALSE_1 = 5;\n  const WORD_POS_FALSE_2 = 6;\n  const WORD_POS_FALSE_3 = 7;\n  const WORD_POS_FALSE_4 = 8;\n  const WORD_POS_NULL_1 = 9;\n  const WORD_POS_NULL_2 = 10;\n  const WORD_POS_NULL_3 = 11;\n  const WORD_POS_UNDEFINED_1 = 12;\n  const WORD_POS_UNDEFINED_2 = 13;\n  const WORD_POS_UNDEFINED_3 = 14;\n  const WORD_POS_UNDEFINED_4 = 15;\n  const WORD_POS_UNDEFINED_5 = 16;\n  const WORD_POS_UNDEFINED_6 = 17;\n  const WORD_POS_UNDEFINED_7 = 18;\n  const WORD_POS_UNDEFINED_8 = 19;\n  const WORD_POS_NAN_1 = 20;\n  const WORD_POS_NAN_2 = 21;\n  const WORD_POS_INFINITY_1 = 22;\n  const WORD_POS_INFINITY_2 = 23;\n  const WORD_POS_INFINITY_3 = 24;\n  const WORD_POS_INFINITY_4 = 25;\n  const WORD_POS_INFINITY_5 = 26;\n  const WORD_POS_INFINITY_6 = 27;\n  const WORD_POS_INFINITY_7 = 28;\n  const WORD_POS_FIELD = 29;\n  const WORD_POS_AFTER_FIELD = 30;\n  const WORD_POS_END = 31;\n  const CONTEXT_UNKNOWN = 0;\n  const CONTEXT_IN_ARRAY = 1; // const CONTEXT_IN_OBJECT = 2\n\n  const CONTEXT_OBJECT_FIELD = 3;\n  const CONTEXT_OBJECT_FIELD_VALUE = 4;\n  const contexts = [];\n\n  function getContext() {\n    return contexts.pop() || {\n      context: CONTEXT_UNKNOWN,\n      elements: null,\n      element_array: null\n    };\n  }\n\n  function dropContext(ctx) {\n    contexts.push(ctx);\n  }\n\n  const buffers = [];\n\n  function getBuffer() {\n    let buf = buffers.pop();\n    if (!buf) buf = {\n      buf: null,\n      n: 0\n    };else buf.n = 0;\n    return buf;\n  }\n\n  function dropBuffer(buf) {\n    buffers.push(buf);\n  }\n\n  const JSON6 =  exports // istanbul ignore next\n  ;\n  /*\n  let _DEBUG_LL = true;\n  let _DEBUG_PARSING = true;\n  let _DEBUG_PARSING_STACK = true;\n  \n  const log = function(type) {\n  \tif (type === '_DEBUG_PARSING' && !_DEBUG_PARSING) {\n  \t\treturn;\n  \t}\n  \tif (type === '_DEBUG_PARSING_STACK' && !_DEBUG_PARSING_STACK) {\n  \t\treturn;\n  \t}\n  \tif (type === '_DEBUG_LL' && !_DEBUG_LL) {\n  \t\treturn;\n  \t}\n  \tconsole.log.apply(console, [].slice.call(arguments, 1));\n  };\n  */\n\n  JSON6.escape = function (string) {\n    let output = '';\n    if (!string) return string;\n\n    for (let n = 0; n < string.length; n++) {\n      if (string[n] == '\"' || string[n] == '\\\\' || string[n] == '`' || string[n] == '\\'') {\n        output += '\\\\';\n      }\n\n      output += string[n];\n    }\n\n    return output;\n  };\n\n  JSON6.begin = function (cb, reviver) {\n    const val = {\n      name: null,\n      // name of this value (if it's contained in an object)\n      value_type: VALUE_UNSET,\n      // value from above indiciating the type of this value\n      string: '',\n      // the string value of this value (strings and number types only)\n      contains: null\n    };\n    const pos = {\n      line: 1,\n      col: 1\n    };\n    let n = 0;\n    let word = WORD_POS_RESET,\n        status = true,\n        negative = false,\n        result = null,\n        elements = undefined,\n        element_array = [],\n        parse_context = CONTEXT_UNKNOWN,\n        comment = 0,\n        fromHex = false,\n        decimal = false,\n        exponent = false,\n        exponent_sign = false,\n        exponent_digit = false,\n        gatheringStringFirstChar = null,\n        gatheringString = false,\n        gatheringNumber = false,\n        stringEscape = false,\n        cr_escaped = false,\n        unicodeWide = false,\n        stringUnicode = false,\n        stringHex = false,\n        hex_char = 0,\n        hex_char_len = 0,\n        completed = false;\n    const context_stack = {\n      first: null,\n      last: null,\n      saved: null,\n\n      push(node) {\n        let recover = this.saved;\n\n        if (recover) {\n          this.saved = recover.next;\n          recover.node = node;\n          recover.next = null;\n          recover.prior = this.last;\n        } else {\n          recover = {\n            node: node,\n            next: null,\n            prior: this.last\n          };\n        }\n\n        if (!this.last) this.first = recover;\n        this.last = recover;\n      },\n\n      pop() {\n        const result = this.last;\n        if (!(this.last = result.prior)) this.first = null;\n        result.next = this.saved;\n        this.saved = result;\n        return result.node;\n      }\n\n    };\n    const inQueue = {\n      first: null,\n      last: null,\n      saved: null,\n\n      push(node) {\n        let recover = this.saved;\n\n        if (recover) {\n          this.saved = recover.next;\n          recover.node = node;\n          recover.next = null;\n          recover.prior = this.last;\n        } else {\n          recover = {\n            node: node,\n            next: null,\n            prior: this.last\n          };\n        }\n\n        if (!this.last) this.first = recover;else this.last.next = recover;\n        this.last = recover;\n      },\n\n      shift() {\n        const result = this.first;\n        if (!result) return null;\n        this.first = result.next;\n        if (!this.first) this.last = null;\n        result.next = this.saved;\n        this.saved = result; // node is in saved...\n\n        return result.node;\n      },\n\n      unshift(node) {\n        // usage in this module, recover will ALWAYS have a saved to use.\n        const recover = this.saved; //if( recover ) {\n\n        this.saved = recover.next;\n        recover.node = node;\n        recover.next = this.first;\n        recover.prior = null; //} else { recover = { node : node, next : this.first, prior : null }; }\n\n        if (!this.first) this.last = recover;\n        this.first = recover;\n      }\n\n    };\n\n    function throwEndError(leader\n    /* , c */\n    ) {\n      throw new Error(`${leader} at ${n} [${pos.line}:${pos.col}]`);\n    }\n\n    return {\n      finalError() {\n        if (comment !== 0) {\n          // most of the time everything's good.\n          switch (comment) {\n            case 1:\n              return throwEndError(\"Comment began at end of document\");\n\n            case 2:\n              console.log(\"Warning: '//' comment without end of line ended document\");\n              break;\n\n            case 3:\n              return throwEndError(\"Open comment '/*' is missing close at end of document\");\n\n            case 4:\n              return throwEndError(\"Incomplete '/* *' close at end of document\");\n          }\n        }\n\n        if (gatheringString) throwEndError(\"Incomplete string\");\n      },\n\n      value() {\n        this.finalError();\n        const r = result;\n        result = undefined;\n        return r;\n      },\n\n      reset() {\n        word = WORD_POS_RESET;\n        status = true;\n        if (inQueue.last) inQueue.last.next = inQueue.save;\n        inQueue.save = inQueue.first;\n        inQueue.first = inQueue.last = null;\n        if (context_stack.last) context_stack.last.next = context_stack.save;\n        context_stack.save = inQueue.first;\n        context_stack.first = context_stack.last = null; //= [];\n\n        element_array = null;\n        elements = undefined;\n        parse_context = CONTEXT_UNKNOWN;\n        val.value_type = VALUE_UNSET;\n        val.name = null;\n        val.string = '';\n        pos.line = 1;\n        pos.col = 1;\n        negative = false;\n        comment = 0;\n        completed = false;\n        gatheringString = false;\n        stringEscape = false; // string stringEscape intro\n\n        cr_escaped = false; // carraige return escaped\n        //stringUnicode = false;  // reading \\u\n        //unicodeWide = false;  // reading \\u{} in string\n        //stringHex = false;  // reading \\x in string\n      },\n\n      write(msg) {\n        let retcode;\n        if (msg !== undefined && typeof msg !== \"string\") msg = String(msg);\n        if (!status) throw new Error(\"Parser is in an error state, please reset.\");\n\n        for (retcode = this._write(msg, false); retcode > 0; retcode = this._write()) {\n          this.finalError();\n          if (typeof reviver === 'function') (function walk(holder, key) {\n            const value = holder[key];\n\n            if (value && typeof value === 'object') {\n              for (const k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                  const v = walk(value, k);\n\n                  if (v !== undefined) {\n                    value[k] = v;\n                  } else {\n                    delete value[k];\n                  }\n                }\n              }\n            }\n\n            return reviver.call(holder, key, value);\n          })({\n            '': result\n          }, '');\n          cb(result);\n          result = undefined;\n          if (retcode < 2) break;\n        }\n\n        if (retcode) this.finalError();\n      },\n\n      _write(msg, complete_at_end) {\n        let input;\n        let buf;\n        let retval = 0;\n\n        function throwError(leader, c) {\n          throw new Error(`${leader} '${String.fromCodePoint(c)}' unexpected at ${n} (near '${buf.substr(n > 4 ? n - 4 : 0, n > 4 ? 3 : n - 1)}[${String.fromCodePoint(c)}]${buf.substr(n, 10)}') [${pos.line}:${pos.col}]`);\n        }\n\n        function RESET_VAL() {\n          val.value_type = VALUE_UNSET;\n          val.string = '';\n        }\n\n        function arrayPush() {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              element_array.push((negative ? -1 : 1) * Number(val.string));\n              break;\n\n            case VALUE_STRING:\n              element_array.push(val.string);\n              break;\n\n            case VALUE_TRUE:\n              element_array.push(true);\n              break;\n\n            case VALUE_FALSE:\n              element_array.push(false);\n              break;\n\n            case VALUE_NEG_NAN:\n              element_array.push(-NaN);\n              break;\n\n            case VALUE_NAN:\n              element_array.push(NaN);\n              break;\n\n            case VALUE_NEG_INFINITY:\n              element_array.push(-Infinity);\n              break;\n\n            case VALUE_INFINITY:\n              element_array.push(Infinity);\n              break;\n\n            case VALUE_NULL:\n              element_array.push(null);\n              break;\n\n            case VALUE_UNDEFINED:\n              element_array.push(undefined);\n              break;\n\n            case VALUE_EMPTY:\n              element_array.push(undefined);\n              delete element_array[element_array.length - 1];\n              break;\n\n            case VALUE_OBJECT:\n              element_array.push(val.contains);\n              break;\n\n            case VALUE_ARRAY:\n              element_array.push(val.contains);\n              break;\n          }\n        }\n\n        function objectPush() {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              elements[val.name] = (negative ? -1 : 1) * Number(val.string);\n              break;\n\n            case VALUE_STRING:\n              elements[val.name] = val.string;\n              break;\n\n            case VALUE_TRUE:\n              elements[val.name] = true;\n              break;\n\n            case VALUE_FALSE:\n              elements[val.name] = false;\n              break;\n\n            case VALUE_NEG_NAN:\n              elements[val.name] = -NaN;\n              break;\n\n            case VALUE_NAN:\n              elements[val.name] = NaN;\n              break;\n\n            case VALUE_NEG_INFINITY:\n              elements[val.name] = -Infinity;\n              break;\n\n            case VALUE_INFINITY:\n              elements[val.name] = Infinity;\n              break;\n\n            case VALUE_NULL:\n              elements[val.name] = null;\n              break;\n\n            case VALUE_UNDEFINED:\n              elements[val.name] = undefined;\n              break;\n\n            case VALUE_OBJECT:\n              elements[val.name] = val.contains;\n              break;\n\n            case VALUE_ARRAY:\n              elements[val.name] = val.contains;\n              break;\n          }\n        }\n\n        function gatherString(start_c) {\n          let retval = 0;\n\n          while (retval == 0 && n < buf.length) {\n            let str = buf.charAt(n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              str += buf.charAt(n);\n              n++;\n            } //console.log( \"gathering....\", stringEscape, str, cInt, unicodeWide, stringHex, stringUnicode, hex_char_len );\n\n\n            pos.col++;\n\n            if (cInt == start_c) {\n              //( cInt == 34/*'\"'*/ ) || ( cInt == 39/*'\\''*/ ) || ( cInt == 96/*'`'*/ ) )\n              if (stringEscape) {\n                if (stringHex) throwError(\"Incomplete hexidecimal sequence\", cInt);else if (unicodeWide) throwError(\"Incomplete long unicode sequence\", cInt);else if (stringUnicode) throwError(\"Incomplete unicode sequence\", cInt);\n\n                if (cr_escaped) {\n                  cr_escaped = false; // \\\\ \\r  '  :end string, the backslash was used for \\r\n\n                  retval = 1; // complete string.\n                } else val.string += str; // escaped start quote\n\n\n                stringEscape = false;\n              } else {\n                // quote matches, not escaped, and not processing escape...\n                retval = 1;\n              }\n            } else if (stringEscape) {\n              if (unicodeWide) {\n                if (cInt == 125\n                /*'}'*/\n                ) {\n                    val.string += String.fromCodePoint(hex_char);\n                    unicodeWide = false;\n                    stringUnicode = false;\n                    stringEscape = false;\n                    continue;\n                  }\n\n                hex_char *= 16;\n                if (cInt >= 48\n                /*'0'*/\n                && cInt <= 57\n                /*'9'*/\n                ) hex_char += cInt - 0x30;else if (cInt >= 65\n                /*'A'*/\n                && cInt <= 70\n                /*'F'*/\n                ) hex_char += cInt - 65 + 10;else if (cInt >= 97\n                /*'a'*/\n                && cInt <= 102\n                /*'f'*/\n                ) hex_char += cInt - 97 + 10;else {\n                  throwError(\"(escaped character, parsing hex of \\\\u)\", cInt);\n                }\n                continue;\n              } else if (stringHex || stringUnicode) {\n                if (hex_char_len === 0 && cInt === 123\n                /*'{'*/\n                ) {\n                    unicodeWide = true;\n                    continue;\n                  }\n\n                hex_char *= 16;\n                if (cInt >= 48\n                /*'0'*/\n                && cInt <= 57\n                /*'9'*/\n                ) hex_char += cInt - 0x30;else if (cInt >= 65\n                /*'A'*/\n                && cInt <= 70\n                /*'F'*/\n                ) hex_char += cInt - 65 + 10;else if (cInt >= 97\n                /*'a'*/\n                && cInt <= 102\n                /*'f'*/\n                ) hex_char += cInt - 97 + 10;else {\n                  throwError(stringUnicode ? \"(escaped character, parsing hex of \\\\u)\" : \"(escaped character, parsing hex of \\\\x)\", cInt);\n                }\n                hex_char_len++;\n\n                if (stringUnicode) {\n                  if (hex_char_len == 4) {\n                    val.string += String.fromCodePoint(hex_char);\n                    stringUnicode = false;\n                    stringEscape = false;\n                  }\n                } else if (hex_char_len == 2) {\n                  val.string += String.fromCodePoint(hex_char);\n                  stringHex = false;\n                  stringEscape = false;\n                }\n\n                continue;\n              }\n\n              switch (cInt) {\n                case 13\n                /*'\\r'*/\n                :\n                  cr_escaped = true;\n                  pos.col = 1;\n                  continue;\n\n                case 0x2028: // LS (Line separator)\n\n                case 0x2029:\n                  // PS (paragraph separator)\n                  pos.col = 1;\n                // no return to get newline reset, so reset line pos.\n                // Fallthrough\n\n                case 10\n                /*'\\n'*/\n                :\n                  if (cr_escaped) {\n                    // \\\\ \\r \\n\n                    cr_escaped = false;\n                  } else {\n                    // \\\\ \\n\n                    pos.col = 1;\n                  }\n\n                  pos.line++;\n                  break;\n\n                case 116\n                /*'t'*/\n                :\n                  val.string += '\\t';\n                  break;\n\n                case 98\n                /*'b'*/\n                :\n                  val.string += '\\b';\n                  break;\n\n                case 48\n                /*'0'*/\n                :\n                  val.string += '\\0';\n                  break;\n\n                case 110\n                /*'n'*/\n                :\n                  val.string += '\\n';\n                  break;\n\n                case 114\n                /*'r'*/\n                :\n                  val.string += '\\r';\n                  break;\n\n                case 102\n                /*'f'*/\n                :\n                  val.string += '\\f';\n                  break;\n\n                case 120\n                /*'x'*/\n                :\n                  stringHex = true;\n                  hex_char_len = 0;\n                  hex_char = 0;\n                  continue;\n\n                case 117\n                /*'u'*/\n                :\n                  stringUnicode = true;\n                  hex_char_len = 0;\n                  hex_char = 0;\n                  continue;\n\n                default:\n                  val.string += str;\n                  break;\n              } //console.log( \"other...\" );\n\n\n              stringEscape = false;\n            } else if (cInt === 92\n            /*'\\\\'*/\n            ) {\n                stringEscape = true;\n              } else {\n              if (cr_escaped) {\n                cr_escaped = false; // \\\\ \\r <any other character>\n\n                pos.line++;\n                pos.col = 2; // newline, plus one character.\n              }\n\n              val.string += str;\n            }\n          }\n\n          return retval;\n        }\n\n        function collectNumber() {\n          let _n;\n\n          while ((_n = n) < buf.length) {\n            const str = buf.charAt(_n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              throwError(\"fault while parsing number;\", cInt);\n            } //log('_DEBUG_PARSING', \"in getting number:\", n, cInt, String.fromCodePoint(cInt) );\n\n\n            if (cInt == 95\n            /*_*/\n            ) continue;\n            pos.col++; // leading zeros should be forbidden.\n\n            if (cInt >= 48\n            /*'0'*/\n            && cInt <= 57\n            /*'9'*/\n            ) {\n                if (exponent) {\n                  exponent_digit = true;\n                }\n\n                val.string += str;\n              } else if (cInt == 45\n            /*'-'*/\n            || cInt == 43\n            /*'+'*/\n            ) {\n                if (val.string.length == 0 || exponent && !exponent_sign && !exponent_digit) {\n                  val.string += str;\n                  exponent_sign = true;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 46\n            /*'.'*/\n            ) {\n                if (!decimal && !fromHex && !exponent) {\n                  val.string += str;\n                  decimal = true;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 120\n            /*'x'*/\n            || cInt == 98\n            /*'b'*/\n            || cInt == 111\n            /*'o'*/\n            || cInt == 88\n            /*'X'*/\n            || cInt == 66\n            /*'B'*/\n            || cInt == 79\n            /*'O'*/\n            ) {\n                // hex conversion.\n                if (!fromHex && val.string == '0') {\n                  fromHex = true;\n                  val.string += str;\n                } else {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt); // break;\n                }\n              } else if (cInt == 101\n            /*'e'*/\n            || cInt == 69\n            /*'E'*/\n            ) {\n              if (!exponent) {\n                val.string += str;\n                exponent = true;\n              } else {\n                status = false;\n                throwError(\"fault while parsing number;\", cInt); // break;\n              }\n            } else {\n              if (cInt == 32\n              /*' '*/\n              || cInt == 160\n              /* &nbsp */\n              || cInt == 13 || cInt == 10 || cInt == 9 || cInt == 0xFEFF || cInt == 44\n              /*','*/\n              || cInt == 125\n              /*'}'*/\n              || cInt == 93\n              /*']'*/\n              || cInt == 58\n              /*':'*/\n              ) {\n                  break;\n                } else {\n                if (complete_at_end) {\n                  status = false;\n                  throwError(\"fault while parsing number;\", cInt);\n                }\n\n                break;\n              }\n            }\n          }\n\n          n = _n;\n\n          if (!complete_at_end && n == buf.length) {\n            gatheringNumber = true;\n          } else {\n            gatheringNumber = false;\n            val.value_type = VALUE_NUMBER;\n\n            if (parse_context == CONTEXT_UNKNOWN) {\n              completed = true;\n            }\n          }\n        }\n\n        if (!status) return -1;\n\n        if (msg && msg.length) {\n          input = getBuffer();\n          input.buf = msg;\n          inQueue.push(input);\n        } else {\n          if (gatheringNumber) {\n            //console.log( \"Force completed.\")\n            gatheringNumber = false;\n            val.value_type = VALUE_NUMBER;\n\n            if (parse_context == CONTEXT_UNKNOWN) {\n              completed = true;\n            } else {\n              throw new Error(\"context stack is not empty at flush\");\n            }\n\n            retval = 1; // if returning buffers, then obviously there's more in this one.\n          }\n        }\n\n        while (status && (input = inQueue.shift())) {\n          n = input.n;\n          buf = input.buf;\n\n          if (gatheringString) {\n            const string_status = gatherString(gatheringStringFirstChar);\n\n            if (string_status > 0) {\n              gatheringString = false;\n              val.value_type = VALUE_STRING;\n            }\n          }\n\n          if (gatheringNumber) {\n            collectNumber();\n          }\n\n          while (!completed && status && n < buf.length) {\n            let str = buf.charAt(n);\n            const cInt = buf.codePointAt(n++);\n\n            if (cInt >= 0x10000) {\n              str += buf.charAt(n);\n              n++;\n            } //// log('_DEBUG_PARSING', \"parsing at \", cInt, str );\n            //log('_DEBUG_LL', \"processing: \", cInt, str, pos, comment, parse_context, word, val );\n\n\n            pos.col++;\n\n            if (comment) {\n              // '/'\n              if (comment == 1) {\n                // '/'\n                if (cInt == 42\n                /*'*'*/\n                ) {\n                    comment = 3;\n                  } // '/*'\n                else if (cInt != 47\n                  /*'/'*/\n                  ) {\n                      // '//'(NOT)\n                      throwError(\"fault while parsing;\", cInt);\n                    } else comment = 2; // '//' (valid)\n\n              } else if (comment == 2) {\n                // '// ...'\n                if (cInt == 10\n                /*'\\n'*/\n                || cInt == 13\n                /*'\\r'*/\n                ) comment = 0;\n              } else if (comment == 3) {\n                // '/*... '\n                if (cInt == 42\n                /*'*'*/\n                ) comment = 4;\n              } else {\n                // if( comment == 4 ) { // '/* ... *'\n                if (cInt == 47\n                /*'/'*/\n                ) comment = 0;else comment = 3; // any other char, goto expect * to close */\n              }\n\n              continue;\n            }\n\n            switch (cInt) {\n              case 47\n              /*'/'*/\n              :\n                comment = 1;\n                break;\n\n              case 123\n              /*'{'*/\n              :\n                if (word == WORD_POS_FIELD || word == WORD_POS_AFTER_FIELD || parse_context == CONTEXT_OBJECT_FIELD && word == WORD_POS_RESET) {\n                  throwError(\"fault while parsing; getting field name unexpected \", cInt); // break;\n                }\n\n                {\n                  const old_context = getContext(); //log('_DEBUG_PARSING', \"Begin a new object; previously pushed into elements; but wait until trailing comma or close previously:%d\", val.value_type );\n\n                  val.value_type = VALUE_OBJECT;\n                  const tmpobj = {};\n                  if (parse_context == CONTEXT_UNKNOWN) result = elements = tmpobj;\n                  old_context.context = parse_context;\n                  old_context.elements = elements;\n                  old_context.element_array = element_array;\n                  old_context.name = val.name;\n                  elements = tmpobj; //log('_DEBUG_PARSING_STACK',\"push context (open object): \", context_stack.length );\n\n                  context_stack.push(old_context);\n                  RESET_VAL();\n                  parse_context = CONTEXT_OBJECT_FIELD;\n                }\n                break;\n\n              case 91\n              /*'['*/\n              :\n                if (parse_context == CONTEXT_OBJECT_FIELD || word == WORD_POS_FIELD || word == WORD_POS_AFTER_FIELD) {\n                  throwError(\"Fault while parsing; while getting field name unexpected\", cInt); // break;\n                }\n\n                if (val.value_type == VALUE_UNSET || val.value_type == VALUE_UNDEFINED) {\n                  const old_context = getContext(); //log('_DEBUG_PARSING', \"Begin a new array; previously pushed into elements; but wait until trailing comma or close previously:%d\", val.value_type );\n\n                  val.value_type = VALUE_ARRAY;\n                  const tmparr = [];\n                  if (parse_context == CONTEXT_UNKNOWN) result = element_array = tmparr; //else if( parse_context == CONTEXT_IN_ARRAY )\n                  //    element_array.push( tmparr );\n                  else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) elements[val.name] = tmparr;\n                  old_context.context = parse_context;\n                  old_context.elements = elements;\n                  old_context.element_array = element_array;\n                  old_context.name = val.name;\n                  element_array = tmparr; //log('_DEBUG_PARSING_STACK', \"push context (open array): \", context_stack.length );\n\n                  context_stack.push(old_context);\n                  RESET_VAL();\n                  parse_context = CONTEXT_IN_ARRAY;\n                } else {\n                  throwError(\"Unexpected array open after previous value\", cInt);\n                }\n\n                break;\n\n              case 58\n              /*':'*/\n              :\n                ////log('_DEBUG_PARSING', \"colon context:\", parse_context );\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  word = WORD_POS_RESET;\n                  val.name = val.string;\n                  val.string = '';\n                  parse_context = CONTEXT_OBJECT_FIELD_VALUE;\n                  val.value_type = VALUE_UNSET;\n                } else {\n                  if (parse_context == CONTEXT_IN_ARRAY) throwError(\"(in array, got colon out of string):parsing fault;\", cInt);else throwError(\"(outside any object, got colon out of string):parsing fault;\", cInt);\n                }\n\n                break;\n\n              case 125\n              /*'}'*/\n              :\n                ////log('_DEBUG_PARSING', \"close bracket context:\", word, parse_context );\n                if (word == WORD_POS_END) {\n                  // allow starting a new word\n                  word = WORD_POS_RESET;\n                } // coming back after pushing an array or sub-object will reset the context to FIELD, so an end with a field should still push value.\n\n\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  //log('_DEBUG_PARSING', \"close object; empty object %d\", val.value_type );\n                  //RESET_VAL();\n                  val.value_type = VALUE_OBJECT;\n                  val.contains = elements;\n                  const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close obj)\", context_stack.length, old_context );\n\n                  val.name = old_context.name;\n                  parse_context = old_context.context; // this will restore as IN_ARRAY or OBJECT_FIELD\n\n                  elements = old_context.elements;\n                  element_array = old_context.element_array;\n                  dropContext(old_context);\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) {\n                  // first, add the last value\n                  //log('_DEBUG_PARSING', \"close object; push item '%s' %d\", val.name, val.value_type );\n                  if (val.value_type != VALUE_UNSET) {\n                    objectPush();\n                  } else {\n                    throwError(\"Fault while parsing field value, close with no value\", cInt);\n                  }\n\n                  val.value_type = VALUE_OBJECT;\n                  val.contains = elements;\n                  const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close object)\", context_stack.length, old_context );\n\n                  val.name = old_context.name;\n                  parse_context = old_context.context; // this will restore as IN_ARRAY or OBJECT_FIELD\n\n                  elements = old_context.elements;\n                  element_array = old_context.element_array;\n                  dropContext(old_context);\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else {\n                  throwError(\"Fault while parsing; unexpected\", cInt);\n                }\n\n                negative = false;\n                break;\n\n              case 93\n              /*']'*/\n              :\n                if (word == WORD_POS_END) word = WORD_POS_RESET;\n\n                if (parse_context == CONTEXT_IN_ARRAY) {\n                  //log('_DEBUG_PARSING', \"close array, push last element: %d\", val.value_type );\n                  if (val.value_type != VALUE_UNSET) {\n                    arrayPush();\n                  }\n\n                  val.value_type = VALUE_ARRAY;\n                  val.contains = element_array;\n                  {\n                    const old_context = context_stack.pop(); //log('_DEBUG_PARSING_STACK',\"object pop stack (close array)\", context_stack.length );\n\n                    val.name = old_context.name;\n                    parse_context = old_context.context;\n                    elements = old_context.elements;\n                    element_array = old_context.element_array;\n                    dropContext(old_context);\n                  }\n\n                  if (parse_context == CONTEXT_UNKNOWN) {\n                    completed = true;\n                  }\n                } else {\n                  throwError(`bad context ${parse_context}; fault while parsing`, cInt); // fault\n                }\n\n                negative = false;\n                break;\n\n              case 44\n              /*','*/\n              :\n                if (word == WORD_POS_END) word = WORD_POS_RESET; // allow collect new keyword\n                //log('_DEBUG_PARSING', \"comma context:\", parse_context, val );\n\n                if (parse_context == CONTEXT_IN_ARRAY) {\n                  if (val.value_type == VALUE_UNSET) val.value_type = VALUE_EMPTY; // in an array, elements after a comma should init as undefined...\n                  //log('_DEBUG_PARSING', \"back in array; push item %d\", val.value_type );\n\n                  arrayPush();\n                  RESET_VAL(); // undefined allows [,,,] to be 4 values and [1,2,3,] to be 4 values with an undefined at end.\n                } else if (parse_context == CONTEXT_OBJECT_FIELD_VALUE) {\n                  // after an array value, it will have returned to OBJECT_FIELD anyway\n                  //log('_DEBUG_PARSING', \"comma after field value, push field to object: %s\", val.name );\n                  parse_context = CONTEXT_OBJECT_FIELD;\n\n                  if (val.value_type != VALUE_UNSET) {\n                    objectPush();\n                    RESET_VAL();\n                  } else throwError(\"Unexpected comma after object field name\", cInt);\n                } else {\n                  status = false;\n                  throwError(\"bad context; excessive commas while parsing;\", cInt); // fault\n                }\n\n                negative = false;\n                break;\n\n              default:\n                if (parse_context == CONTEXT_OBJECT_FIELD) {\n                  switch (cInt) {\n                    case 96: //'`':\n\n                    case 34: //'\"':\n\n                    case 39:\n                      //'\\'':\n                      if (word == WORD_POS_RESET) {\n                        if (val.value_type != VALUE_UNSET) throwError(\"String begin after previous value\", cInt);\n                        const string_status = gatherString(cInt); //log('_DEBUG_PARSING', \"string gather for object field name :\", val.string, string_status );\n\n                        if (string_status) {\n                          val.value_type = VALUE_STRING;\n                        } else {\n                          gatheringStringFirstChar = cInt;\n                          gatheringString = true;\n                        }\n                      } else {\n                        throwError(\"fault while parsing; quote not at start of field name\", cInt);\n                      }\n\n                      break;\n\n                    case 10:\n                      //'\\n':\n                      pos.line++;\n                      pos.col = 1;\n                    // fall through to normal space handling - just updated line/col position\n\n                    case 13: //'\\r':\n\n                    case 32: //' ':\n\n                    case 160: //&nbsp:\n\n                    case 9: //'\\t':\n\n                    case 0xFEFF:\n                      // ZWNBS is WS though\n                      if (word == WORD_POS_END) {\n                        // allow collect new keyword\n                        word = WORD_POS_RESET;\n                      } else if (word == WORD_POS_FIELD) {\n                        word = WORD_POS_AFTER_FIELD;\n                      } // skip whitespace\n\n\n                      break;\n\n                    default:\n                      if (word == WORD_POS_AFTER_FIELD) {\n                        status = false;\n                        throwError(\"fault while parsing; character unexpected\", cInt);\n                      }\n\n                      if (word == WORD_POS_RESET) word = WORD_POS_FIELD;\n                      val.string += str;\n                      break;\n                    // default\n                  }\n                } else switch (cInt) {\n                  case 96: //'`':\n\n                  case 34: //'\"':\n\n                  case 39:\n                    {\n                      //'\\'':\n                      if (val.value_type === VALUE_UNSET) {\n                        const string_status = gatherString(cInt); //log('_DEBUG_PARSING', \"string gather for object field value :\", val.string, string_status, completed, input.n, buf.length );\n\n                        if (string_status) {\n                          val.value_type = VALUE_STRING;\n                          word = WORD_POS_END;\n                        } else {\n                          gatheringStringFirstChar = cInt;\n                          gatheringString = true;\n                        }\n                      } else throwError(\"String unexpected\", cInt);\n\n                      break;\n                    }\n\n                  case 10:\n                    //'\\n':\n                    pos.line++;\n                    pos.col = 1;\n                  // Fallthrough\n\n                  case 32: //' ':\n\n                  case 160: // &nbsp\n\n                  case 9: //'\\t':\n\n                  case 13: //'\\r':\n\n                  case 0xFEFF:\n                    //'\\uFEFF':\n                    if (word == WORD_POS_END) {\n                      word = WORD_POS_RESET;\n\n                      if (parse_context == CONTEXT_UNKNOWN) {\n                        completed = true;\n                      }\n\n                      break;\n                    }\n\n                    if (word !== WORD_POS_RESET) {\n                      // breaking in the middle of gathering a keyword.\n                      status = false;\n                      throwError(\"fault parsing whitespace\", cInt);\n                    }\n\n                    break;\n                  //----------------------------------------------------------\n                  //  catch characters for true/false/null/undefined which are values outside of quotes\n\n                  case 116:\n                    //'t':\n                    if (word == WORD_POS_RESET) word = WORD_POS_TRUE_1;else if (word == WORD_POS_INFINITY_6) word = WORD_POS_INFINITY_7;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 114:\n                    //'r':\n                    if (word == WORD_POS_TRUE_1) word = WORD_POS_TRUE_2;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 117:\n                    //'u':\n                    if (word == WORD_POS_TRUE_2) word = WORD_POS_TRUE_3;else if (word == WORD_POS_NULL_1) word = WORD_POS_NULL_2;else if (word == WORD_POS_RESET) word = WORD_POS_UNDEFINED_1;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 101:\n                    //'e':\n                    if (word == WORD_POS_TRUE_3) {\n                      val.value_type = VALUE_TRUE;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_FALSE_4) {\n                      val.value_type = VALUE_FALSE;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_UNDEFINED_3) word = WORD_POS_UNDEFINED_4;else if (word == WORD_POS_UNDEFINED_7) word = WORD_POS_UNDEFINED_8;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n\n                    break;\n\n                  case 110:\n                    //'n':\n                    if (word == WORD_POS_RESET) word = WORD_POS_NULL_1;else if (word == WORD_POS_UNDEFINED_1) word = WORD_POS_UNDEFINED_2;else if (word == WORD_POS_UNDEFINED_6) word = WORD_POS_UNDEFINED_7;else if (word == WORD_POS_INFINITY_1) word = WORD_POS_INFINITY_2;else if (word == WORD_POS_INFINITY_4) word = WORD_POS_INFINITY_5;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 100:\n                    //'d':\n                    if (word == WORD_POS_UNDEFINED_2) word = WORD_POS_UNDEFINED_3;else if (word == WORD_POS_UNDEFINED_8) {\n                      val.value_type = VALUE_UNDEFINED;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 105:\n                    //'i':\n                    if (word == WORD_POS_UNDEFINED_5) word = WORD_POS_UNDEFINED_6;else if (word == WORD_POS_INFINITY_3) word = WORD_POS_INFINITY_4;else if (word == WORD_POS_INFINITY_5) word = WORD_POS_INFINITY_6;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 108:\n                    //'l':\n                    if (word == WORD_POS_NULL_2) word = WORD_POS_NULL_3;else if (word == WORD_POS_NULL_3) {\n                      val.value_type = VALUE_NULL;\n                      word = WORD_POS_END;\n                    } else if (word == WORD_POS_FALSE_2) word = WORD_POS_FALSE_3;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 102:\n                    //'f':\n                    if (word == WORD_POS_RESET) word = WORD_POS_FALSE_1;else if (word == WORD_POS_UNDEFINED_4) word = WORD_POS_UNDEFINED_5;else if (word == WORD_POS_INFINITY_2) word = WORD_POS_INFINITY_3;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 97:\n                    //'a':\n                    if (word == WORD_POS_FALSE_1) word = WORD_POS_FALSE_2;else if (word == WORD_POS_NAN_1) word = WORD_POS_NAN_2;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 115:\n                    //'s':\n                    if (word == WORD_POS_FALSE_3) word = WORD_POS_FALSE_4;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 73:\n                    //'I':\n                    if (word == WORD_POS_RESET) word = WORD_POS_INFINITY_1;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 78:\n                    //'N':\n                    if (word == WORD_POS_RESET) word = WORD_POS_NAN_1;else if (word == WORD_POS_NAN_2) {\n                      val.value_type = negative ? VALUE_NEG_NAN : VALUE_NAN;\n                      negative = false;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n\n                  case 121:\n                    //'y':\n                    if (word == WORD_POS_INFINITY_7) {\n                      val.value_type = negative ? VALUE_NEG_INFINITY : VALUE_INFINITY;\n                      negative = false;\n                      word = WORD_POS_END;\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n\n                    break;\n\n                  case 45:\n                    //'-':\n                    if (word == WORD_POS_RESET) negative = !negative;else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    } // fault\n\n                    break;\n                  //\n                  //----------------------------------------------------------\n\n                  default:\n                    if (cInt >= 48\n                    /*'0'*/\n                    && cInt <= 57\n                    /*'9'*/\n                    || cInt == 43\n                    /*'+'*/\n                    || cInt == 46\n                    /*'.'*/\n                    || cInt == 45\n                    /*'-'*/\n                    ) {\n                      fromHex = false;\n                      exponent = false;\n                      exponent_sign = false;\n                      exponent_digit = false;\n                      decimal = false;\n                      val.string = str;\n                      input.n = n;\n                      collectNumber();\n                    } else {\n                      status = false;\n                      throwError(\"fault parsing\", cInt);\n                    }\n\n                    break;\n                  // default\n                }\n\n                break;\n              // default of high level switch\n            }\n\n            if (completed) {\n              if (word == WORD_POS_END) {\n                word = WORD_POS_RESET;\n              }\n\n              break;\n            }\n          }\n\n          if (n == buf.length) {\n            dropBuffer(input);\n\n            if (gatheringString || gatheringNumber || parse_context == CONTEXT_OBJECT_FIELD) {\n              retval = 0;\n            } else {\n              if (parse_context == CONTEXT_UNKNOWN && (val.value_type != VALUE_UNSET || result)) {\n                completed = true;\n                retval = 1;\n              }\n            }\n          } else {\n            // put these back into the stack.\n            input.n = n;\n            inQueue.unshift(input);\n            retval = 2; // if returning buffers, then obviously there's more in this one.\n          }\n\n          if (completed) break;\n        }\n\n        if (completed && val.value_type != VALUE_UNSET) {\n          switch (val.value_type) {\n            case VALUE_NUMBER:\n              result = (negative ? -1 : 1) * Number(val.string);\n              break;\n\n            case VALUE_STRING:\n              result = val.string;\n              break;\n\n            case VALUE_TRUE:\n              result = true;\n              break;\n\n            case VALUE_FALSE:\n              result = false;\n              break;\n\n            case VALUE_NULL:\n              result = null;\n              break;\n\n            case VALUE_UNDEFINED:\n              result = undefined;\n              break;\n\n            case VALUE_NAN:\n              result = NaN;\n              break;\n\n            case VALUE_NEG_NAN:\n              result = -NaN;\n              break;\n\n            case VALUE_INFINITY:\n              result = Infinity;\n              break;\n\n            case VALUE_NEG_INFINITY:\n              result = -Infinity;\n              break;\n\n            case VALUE_OBJECT:\n              // never happens\n              result = val.contains;\n              break;\n\n            case VALUE_ARRAY:\n              // never happens\n              result = val.contains;\n              break;\n          }\n\n          negative = false;\n          val.string = '';\n          val.value_type = VALUE_UNSET;\n        }\n\n        completed = false;\n        return retval;\n      }\n\n    };\n  };\n\n  const _parser = [Object.freeze(JSON6.begin())];\n  let _parse_level = 0;\n\n  JSON6.parse = function (msg, reviver) {\n    //var parser = JSON6.begin();\n    const parse_level = _parse_level++;\n    if (_parser.length <= parse_level) _parser.push(Object.freeze(JSON6.begin()));\n    const parser = _parser[parse_level];\n    if (typeof msg !== \"string\") msg = String(msg);\n    parser.reset();\n\n    if (parser._write(msg, true) > 0) {\n      const result = parser.value();\n      if (typeof reviver === 'function') (function walk(holder, key) {\n        const value = holder[key];\n\n        if (value && typeof value === 'object') {\n          for (const k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k)) {\n              const v = walk(value, k);\n\n              if (v !== undefined) {\n                value[k] = v;\n              } else {\n                delete value[k];\n              }\n            }\n          }\n        }\n\n        return reviver.call(holder, key, value);\n      })({\n        '': result\n      }, '');\n      _parse_level--;\n      return result;\n    } else parser.finalError();\n\n    return undefined;\n  };\n\n  JSON6.stringify = JSON.stringify;\n});\n\nvar lib = json6;\n\nexport default lib;\n","// We want it to work in the browser, so commenting out\n// import jsonExtra from 'json5';\n// import jsonExtra from 'json-6';\n\n// We need this for the browser version to work, but this breaks nyc;\n//  see https://github.com/standard-things/esm/issues/839\n// import jsonExtra from '../node_modules/json-6/dist/index.mjs';\nimport jsonExtra from 'json-6';\n\nexport const unescapeBackslashes = (str) => {\n  return str.replace(/\\\\+/gu, (esc) => {\n    return esc.slice(0, esc.length / 2);\n  });\n};\n\nexport const parseJSONExtra = (args) => {\n  return jsonExtra.parse(\n    // Doesn't actually currently allow explicit brackets,\n    //  but in case we change our regex to allow inner brackets\n    '{' + (args || '').replace(/^\\{/u, '').replace(/\\}$/u, '') + '}'\n  );\n};\n\n// Todo: Extract to own library (RegExtras?)\nexport const processRegex = (regex, str, {\n  onMatch,\n  extra,\n  betweenMatches,\n  afterMatch,\n  escapeAtOne\n}) => {\n  let match;\n  let previousIndex = 0;\n  if (extra) {\n    betweenMatches = extra;\n    afterMatch = extra;\n    escapeAtOne = extra;\n  }\n  while ((match = regex.exec(str)) !== null) {\n    const [_, esc] = match;\n    const {lastIndex} = regex;\n\n    const startMatchPos = lastIndex - _.length;\n    if (startMatchPos > previousIndex) {\n      betweenMatches(str.slice(previousIndex, startMatchPos));\n    }\n\n    if (escapeAtOne && esc.length % 2) {\n      previousIndex = lastIndex;\n      escapeAtOne(_);\n      continue;\n    }\n    onMatch(...match);\n    previousIndex = lastIndex;\n  }\n  if (previousIndex !== str.length) { // Get text at end\n    afterMatch(str.slice(previousIndex));\n  }\n};\n","/* globals fetch, document */\nlet _fetch = typeof fetch !== 'undefined'\n  // istanbul ignore next\n  ? fetch\n  : null;\n\n/**\n * @param {fetch} f\n * @returns {void}\n */\nexport const setFetch = (f) => {\n  _fetch = f;\n};\n\n/**\n * @returns {fetch}\n */\nexport const getFetch = () => {\n  return _fetch;\n};\n\nlet _doc = typeof document !== 'undefined'\n  // istanbul ignore next\n  ? document\n  : null;\n\n/**\n * @param {document} doc\n * @returns {void}\n */\nexport const setDocument = (doc) => {\n  _doc = doc;\n};\n\n/**\n * @returns {document}\n */\nexport const getDocument = () => {\n  return _doc;\n};\n","/* globals performance */\nimport {processRegex} from './utils.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/**\n *\n * @returns {string}\n */\nfunction generateUUID () { //  Adapted from original: public domain/MIT: http://stackoverflow.com/a/8809472/271577\n  let d = Date.now();\n  /* istanbul ignore next */\n  if (typeof performance !== 'undefined' &&\n      typeof performance.now === 'function'\n  ) {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, function (c) {\n    /* eslint-disable no-bitwise */\n    const r = Math.trunc((d + Math.random() * 16) % 16);\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n    /* eslint-enable no-bitwise */\n  });\n}\n\nexport const sort = (locale, arrayOfItems, options) => {\n  return arrayOfItems.sort(new Intl.Collator(\n    locale,\n    options\n  ).compare);\n};\n\nexport const list = (locale, arrayOfItems, options) => {\n  return new Intl.ListFormat(\n    locale, options\n  ).format(arrayOfItems);\n};\n\nexport const sortListSimple = (\n  locale, arrayOfItems, listOptions, collationOptions\n) => {\n  sort(locale, arrayOfItems, collationOptions);\n  return list(locale, arrayOfItems, listOptions);\n};\n\nexport const sortList = (\n  locale, arrayOfItems, map, listOptions, collationOptions\n) => {\n  if (typeof map !== 'function') {\n    return sortListSimple(locale, arrayOfItems, map, listOptions);\n  }\n  sort(locale, arrayOfItems, collationOptions);\n\n  const randomId = generateUUID();\n\n  const placeholderArray = [...arrayOfItems].map(\n    (_, i) => `<<${randomId}${i}>>`\n  );\n  const nodes = [];\n  const push = (...args) => {\n    nodes.push(...args);\n  };\n\n  processRegex(\n    // // eslint-disable-next-line prefer-named-capture-group\n    new RegExp(`<<${randomId}(\\\\d)>>`, 'gu'),\n    list(locale, placeholderArray, listOptions), {\n      betweenMatches: push,\n      afterMatch: push,\n      onMatch (_, idx) {\n        push(map(arrayOfItems[idx], idx));\n      }\n    }\n  );\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n  return container;\n};\n","import {parseJSONExtra} from './utils.js';\nimport {sortList} from './collation.js';\n\nexport const getFormatterInfo = ({object}) => {\n  if (Array.isArray(object)) {\n    if (typeof object[1] === 'function') {\n      const [value, callback, options, extraOpts] = object;\n      return {value, callback, options, extraOpts};\n    }\n    const [value, options, extraOpts] = object;\n    return {value, options, extraOpts};\n  }\n  return {value: object};\n};\n\n/* eslint-disable max-len */\n/**\n * Callback to give replacement text based on a substitution value.\n * @callback AllSubstitutionCallback\n * @param {PlainObject} cfg\n * @param {string|Node|number|Date|RelativeTimeInfo|ListInfo|NumberInfo|DateInfo} cfg.value Contains\n *   the value returned by the individual substitution\n * @param {string} cfg.arg See `cfg.arg` of {@link SubstitutionCallback}.\n * @param {string} cfg.key The substitution key Not currently in use\n * @param {string} cfg.locale The locale\n * @returns {string|Element} The replacement text or element\n*/\n/* eslint-enable max-len */\n\n/**\n * @type {AllSubstitutionCallback}\n */\nexport const defaultAllSubstitutions = ({value, arg, key, locale}) => {\n  // Strings or DOM Nodes\n  if (\n    typeof value === 'string' || (value && typeof value === 'object' &&\n    'nodeType' in value)\n  ) {\n    return value;\n  }\n\n  let opts;\n\n  const applyArgs = ({type, options = opts, checkArgOptions = false}) => {\n    if (typeof arg === 'string') {\n      let [userType, extraArgs, argOptions] = arg.split('|');\n      // Alias\n      if (userType === 'DATE') {\n        userType = 'DATETIME';\n      }\n      if (userType === type) {\n        if (!extraArgs) {\n          options = {};\n        } else if (!checkArgOptions || argOptions) {\n          // Todo: Allow escaping and restoring of pipe symbol\n          options = {\n            ...options,\n            ...parseJSONExtra(\n              checkArgOptions && argOptions ? argOptions : extraArgs\n            )\n          };\n        }\n      }\n    }\n    return options;\n  };\n\n  if (value && typeof value === 'object') {\n    const singleKey = Object.keys(value)[0];\n    if ([\n      'number', 'date', 'datetime', 'relative', 'list', 'plural'\n    ].includes(singleKey)) {\n      let extraOpts, callback;\n      ({\n        value, options: opts, extraOpts, callback\n      } = getFormatterInfo({object: value[singleKey]}));\n\n      switch (singleKey) {\n      case 'relative':\n        // The second argument actually contains the primary options, so swap\n        [extraOpts, opts] = [opts, extraOpts];\n        return new Intl.RelativeTimeFormat(\n          locale, applyArgs({type: 'RELATIVE'})\n        ).format(value, extraOpts);\n\n      // ListFormat (with Collator)\n      case 'list':\n        if (callback) {\n          return sortList(\n            locale, value, callback,\n            applyArgs({type: 'LIST'}),\n            applyArgs({\n              type: 'LIST', options: extraOpts, checkArgOptions: true\n            })\n          );\n        }\n        return sortList(locale, value, applyArgs({type: 'LIST'}), applyArgs({\n          type: 'LIST', options: extraOpts, checkArgOptions: true\n        }));\n      default:\n        // Let `number` and `date` types drop through so their options\n        //  can be applied\n        // Let `plural` be treated as number (since value should be a number)\n        break;\n      }\n    }\n  }\n\n  // Numbers\n  if (typeof value === 'number') {\n    return new Intl.NumberFormat(\n      locale,\n      applyArgs({type: 'NUMBER'})\n    ).format(value);\n  }\n\n  // Dates\n  if (\n    value && typeof value === 'object' &&\n    typeof value.getTime === 'function'\n  ) {\n    return new Intl.DateTimeFormat(\n      locale,\n      applyArgs({type: 'DATETIME'})\n    ).format(value);\n  }\n\n  // console.log('value', value);\n  throw new TypeError('Unknown formatter');\n};\n","import {getMessageForKeyByStyle} from './index.js';\nimport {parseJSONExtra} from './utils.js';\nimport {getFormatterInfo} from './defaultAllSubstitutions.js';\n\n/**\n * Base class for formatting.\n */\nexport class Formatter {\n}\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.key\n * @param {LocaleBody} cfg.body\n * @param {string} cfg.type\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} cfg.messageStyle\n * @returns {string|Element}\n */\nconst getSubstitution = ({key, body, type, messageStyle = 'richNested'}) => {\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const substitution = messageForKey({body}, key);\n  if (!substitution) {\n    throw new Error(`Key value not found for ${type} key: (${key})`);\n  }\n  // We don't allow a substitution function here or below as comes\n  //  from locale and locale content should not pose security concerns\n  return substitution.value;\n};\n\n/**\n * Formatter for local variables.\n */\nexport class LocalFormatter extends Formatter {\n  /**\n   * @param {LocalObject} locals\n   */\n  constructor (locals) {\n    super();\n    this.locals = locals;\n  }\n  /**\n   * @param {string} key\n   * @returns {string|Element}\n   */\n  getSubstitution (key) {\n    return getSubstitution({\n      key: key.slice(1), body: this.locals, type: 'local'\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    const components = key.slice(1).split('.');\n    let parent = this.locals;\n    return this.constructor.isMatchingKey(key) && components.every((cmpt) => {\n      const result = cmpt in parent;\n      parent = parent[cmpt];\n      return result;\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('-');\n  }\n}\n\n/**\n * Formatter for regular variables.\n */\nexport class RegularFormatter extends Formatter {\n  /**\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (substitutions) {\n    super();\n    this.substitutions = substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return this.constructor.isMatchingKey(key) && key in this.substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return (/^\\w/u).test(key);\n  }\n}\n\n/**\n * Formatter for switch variables.\n */\nexport class SwitchFormatter extends Formatter {\n  /**\n   * @param {Switches} switches\n   * @param {SubstitutionObject} substitutions\n   */\n  constructor (switches, {substitutions}) {\n    super();\n    this.switches = switches;\n    this.substitutions = substitutions;\n  }\n\n  /**\n   * @param {string} key\n   * @param {PlainObject} cfg\n   * @param {string} cfg.locale\n   * @param {string[]} cfg.usedKeys\n   * @param {string} cfg.arg\n   * @param {MissingSuppliedFormattersCallback} cfg.missingSuppliedFormatters\n   * @returns {string}\n   */\n  getSubstitution (key, {locale, usedKeys, arg, missingSuppliedFormatters}) {\n    const ky = this.constructor.getKey(key).slice(1);\n    // Expression might not actually use formatter, e.g., for singular,\n    //  the conditional might just write out \"one\"\n\n    const [objKey, body, keySegment] = this.getMatch(ky);\n    usedKeys.push(keySegment);\n\n    let type, opts;\n    if (objKey && objKey.includes('|')) {\n      [, type, opts] = objKey.split('|');\n    }\n    if (!body) {\n      missingSuppliedFormatters({\n        key,\n        formatter: this\n      });\n      return '\\\\{' + key + '}';\n    }\n\n    /*\n    if (!(ky in this.substitutions)) {\n      throw new Error(`Switch expecting formatter: ${ky}`);\n    }\n    */\n\n    const getNumberFormat = (value, defaultOptions) => {\n      const numberOpts = parseJSONExtra(opts);\n      return new Intl.NumberFormat(locale, {\n        ...defaultOptions, ...numberOpts\n      }).format(value);\n    };\n\n    const getPluralFormat = (value, defaultOptions) => {\n      const pluralOpts = parseJSONExtra(opts);\n      return new Intl.PluralRules(locale, {\n        ...defaultOptions, ...pluralOpts\n      }).select(value);\n    };\n\n    const formatterValue = this.substitutions[keySegment];\n\n    let match = formatterValue;\n    if (typeof formatterValue === 'number') {\n      switch (type) {\n      case 'NUMBER':\n        match = getNumberFormat(formatterValue);\n        break;\n      case 'PLURAL':\n        match = getPluralFormat(formatterValue);\n        break;\n      default:\n        match = new Intl.PluralRules(locale).select(formatterValue);\n        break;\n      }\n    } else if (formatterValue && typeof formatterValue === 'object') {\n      const singleKey = Object.keys(formatterValue)[0];\n      if (['number', 'plural'].includes(singleKey)) {\n        const {value, options} = getFormatterInfo({\n          object: formatterValue[singleKey]\n        });\n        if (!type) {\n          type = singleKey.toUpperCase();\n        }\n        const typeMatches = singleKey.toUpperCase() === type;\n        if (!typeMatches) {\n          throw new TypeError(\n            `Expecting type \"${\n              type.toLowerCase()\n            }\"; instead found \"${singleKey}\".`\n          );\n        }\n        // eslint-disable-next-line default-case\n        switch (type) {\n        case 'NUMBER':\n          match = getNumberFormat(value, options);\n          break;\n        case 'PLURAL':\n          match = getPluralFormat(value, options);\n          break;\n        }\n      }\n    }\n\n    // We do not want the default `richNested` here as that will split\n    //  up the likes of `0.0`\n    const messageStyle = 'richNested';\n\n    const preventNesting = (s) => {\n      return s.replace(/\\\\/gu, '\\\\\\\\').replace(/\\./gu, '\\\\.');\n    };\n\n    try {\n      return getSubstitution({\n        messageStyle,\n        key: match ? preventNesting(match) : arg,\n        body,\n        type: 'switch'\n      });\n    } catch (err) {\n      try {\n        return getSubstitution({\n          messageStyle, key: '*' + preventNesting(match), body, type: 'switch'\n        });\n      } catch (error) {\n        const k = Object.keys(body).find(\n          (switchKey) => switchKey.startsWith('*')\n        );\n        if (!k) {\n          throw new Error(`No defaults found for switch ${ky}`);\n        }\n        return getSubstitution({\n          messageStyle, key: preventNesting(k), body, type: 'switch'\n        });\n      }\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return key && this.constructor.isMatchingKey(key) &&\n      Boolean(this.getMatch(key.slice(1)).length);\n  }\n\n  /**\n  * @typedef {GenericArray} SwitchMatch\n  * @property {string} 0 objKey\n  * @property {LocaleBody} 1 body\n  * @property {string} 2 keySegment\n  */\n\n  /**\n   * @param {string} ky\n   * @returns {SwitchMatch}\n   */\n  getMatch (ky) {\n    const ks = ky.split('.');\n    return ks.reduce((obj, k, i) => {\n      if (i < ks.length - 1) {\n        if (!(k in obj)) {\n          throw new Error(`Switch key \"${k}\" not found (from \"~${ky}\")`);\n        }\n        return obj[k];\n      }\n      // Todo: Should throw on encountering duplicate fundamental keys (even\n      //  if there are different arguments, that should not be allowed)\n      const ret = Object.entries(obj).find(([switchKey]) => {\n        return k === this.constructor.getKey(switchKey);\n      });\n\n      return ret ? ret.concat(k) : [];\n    }, this.switches);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('~');\n  }\n  /**\n   * @param {string} key\n   * @returns {string}\n   */\n  static getKey (key) {\n    const match = key.match(/^[^|]*/u);\n    return match && match[0];\n  }\n}\n","/**\n* @callback PromiseChainErrback\n* @param {any} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @param {string} [errorMessage=\"Reached end of values array.\"]\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\n promiseChainForValues(['a', 'b', 'c'], (val) => {\n   return new Promise(function (resolve, reject) {\n     if (val === 'a') {\n       reject(new Error('missing'));\n     }\n     setTimeout(() => {\n       resolve(val);\n     }, 100);\n   });\n });\n */\nexport const promiseChainForValues = (\n  values, errBack, errorMessage = 'Reached end of values array.'\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(\n      'The `values` argument to `promiseChainForValues` must be an array.'\n    );\n  }\n  if (typeof errBack !== 'function') {\n    throw new TypeError(\n      'The `errBack` argument to `promiseChainForValues` must be a function.'\n    );\n  }\n  return (async () => {\n    let ret;\n    let p = Promise.reject(\n      new Error('Intentionally reject so as to begin checking chain')\n    );\n    let breaking;\n    while (true) {\n      const value = values.shift();\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        ret = await p;\n        break;\n      } catch (err) {\n        if (breaking) {\n          throw new Error(errorMessage);\n        }\n        // We allow one more try\n        if (!values.length) {\n          breaking = true;\n        }\n        // // eslint-disable-next-line no-await-in-loop\n        p = errBack(value);\n      }\n    }\n    return ret;\n  })();\n};\n","/**\n* @callback SubstitutionCallback\n* @param {PlainObject} cfg\n* @param {string} cfg.arg By default, accepts the third portion of the\n*   `formattingRegex` within `insertNodes`, i.e., to allow the locale to\n*   supply arguments back to the calling script.\n* @param {string} cfg.key The substitution key\n* @returns {string|Element} The replacement text or element\n*/\n\n/**\n * May have additional properties if supplying options to an underlying\n * formatter.\n * @typedef {GenericArray} ValueArray\n * @property {string|Node|number|Date} 0 The main value\n * @property {PlainObject} [1] The options related to the main value\n * @property {PlainObject} [2] Any additional options\n*/\n\n/**\n* @typedef {PlainObject} RelativeTimeInfo\n* @property {ValueArray} relative\n*/\n\n/**\n* @typedef {PlainObject} ListInfo\n* @property {ValueArray} list\n*/\n\n/**\n* @typedef {PlainObject} NumberInfo\n* @property {ValueArray} number\n*/\n\n/**\n* @typedef {PlainObject} DateInfo\n* @property {ValueArray} date\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringBodyObject\n*/\n\n/**\n* @typedef {PlainObject} SwitchCaseInfo\n* @property {boolean} [default=false] Whether this conditional is the default\n*/\n\n/**\n* @typedef {GenericArray} SwitchCase\n* @property {string} 0 The type\n* @property {string} 1 The message\n* @property {SwitchCaseInfo} [2] Info about the switch case\n*/\n\n/**\n* @typedef {PlainObject<string, SwitchCase>} Switch\n*/\n\n/**\n* @typedef {PlainObject<{string, Switch}>} Switches\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} [message] The locale message with any formatting\n*   place-holders; defaults to use of any single conditional\n* @property {string} [description] A description to add translators\n* @property {Switches} [switches] Conditionals\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringBodyObject\n*/\n\n/**\n * Takes a base path and locale and gives a URL.\n * @callback LocaleResolver\n * @param {string} localesBasePath (Trailing slash optional)\n * @param {string} locale BCP-47 language string\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|SubstitutionCallback>}\n*   SubstitutionObject\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (localesBasePath, locale) => {\n  if (typeof localesBasePath !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `localesBasePath`.'\n    );\n  }\n  if (typeof locale !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `locale`.'\n    );\n  }\n  if ((/[./\\\\]/u).test(locale)) {\n    throw new TypeError(\n      'Locales cannot use file-reserved characters, `.`, `/` or `\\\\`'\n    );\n  }\n  return `${localesBasePath.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n","import {\n  LocalFormatter, RegularFormatter, SwitchFormatter\n} from './Formatter.js';\nimport {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {unescapeBackslashes, parseJSONExtra, processRegex} from './utils.js';\n\n/* eslint-disable max-len */\n/**\n * Callback to return a string or array of nodes and strings based on a localized\n * string, substitutions object, and other metadata.\n * @callback InsertNodesCallback\n * @param {PlainObject} cfg\n * @param {string} cfg.string The localized string\n * @param {boolean} [cfg.dom] If substitutions known to contain DOM, can be set\n *   to `true` to optimize\n * @param {string[]} [cfg.usedKeys=[]] Array for tracking which keys have been used\n * @param {SubstitutionObject} cfg.substitutions The formatting substitutions object\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions] The\n *   callback or array composed thereof for applying to each substitution.\n * @param {string} locale The successfully resolved locale\n * @param {Integer} [maximumLocalNestingDepth=3] Depth of local variable resolution to\n *   check before reporting a recursion error\n * @param {MissingSuppliedFormattersCallback} [cfg.missingSuppliedFormatters] Callback\n *   supplied key to throw if the supplied key is present (if\n *   `throwOnMissingSuppliedFormatters` is enabled). Defaults to no-op.\n * @param {CheckExtraSuppliedFormattersCallback} [cfg.checkExtraSuppliedFormatters] No\n *   argument callback to check if any formatters are not present in `string`\n *   (if `throwOnExtraSuppliedFormatters` is enabled). Defaults to no-op.\n * @returns {string|Array<Node|string>}\n */\n\n/**\n * @type {InsertNodesCallback}\n */\nexport const defaultInsertNodes = ({\n  /* eslint-enable max-len */\n  string, dom, usedKeys, substitutions, allSubstitutions, locale,\n  locals, switches,\n  maximumLocalNestingDepth = 3,\n  missingSuppliedFormatters,\n  checkExtraSuppliedFormatters\n}) => {\n  if (typeof maximumLocalNestingDepth !== 'number') {\n    throw new TypeError('`maximumLocalNestingDepth` must be a number.');\n  }\n  const localFormatter = new LocalFormatter(locals);\n  const regularFormatter = new RegularFormatter(substitutions);\n  const switchFormatter = new SwitchFormatter(switches, {substitutions});\n\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  const formattingRegex = /(\\\\*)\\{((?:[^}]|\\\\\\})*?)(?:(\\|)([^}]*))?\\}/gu;\n  if (allSubstitutions) {\n    allSubstitutions = Array.isArray(allSubstitutions)\n      ? allSubstitutions\n      : [allSubstitutions];\n  }\n\n  const getSubstitution = ({key, arg, substs}) => {\n    let substitution;\n    const isLocalKey = localFormatter.constructor.isMatchingKey(key);\n    if (isLocalKey) {\n      substitution = localFormatter.getSubstitution(key);\n    } else if (switchFormatter.constructor.isMatchingKey(key)) {\n      substitution = switchFormatter.getSubstitution(key, {\n        locale, usedKeys, arg,\n        missingSuppliedFormatters\n      });\n    } else {\n      substitution = substs[key];\n      if (typeof substitution === 'function') {\n        substitution = substitution({arg, key});\n      }\n    }\n    // Todo: Could support resolving locals within arguments\n    // Todo: Even for `null` `allSubstitutions`, we could have\n    //  a mode to throw for non-string/non-DOM (non-numbers?),\n    //  or whatever is not likely intended as a target for `toString()`.\n    if (allSubstitutions) {\n      substitution = allSubstitutions.reduce((subst, allSubst) => {\n        return allSubst({\n          value: subst, arg, key, locale\n        });\n      }, substitution);\n    } else if (arg && arg.match(/^(?:NUMBER|DATE(?:TIME)?|RELATIVE|LIST)(?:\\||$)/u)) {\n      substitution = defaultAllSubstitutions({\n        value: substitution, arg, key, locale\n      });\n    }\n    return substitution;\n  };\n\n  let recursiveLocalCount = 1;\n  const checkLocalVars = ({substitution, ky, arg, processSubsts}) => {\n    if (\n      typeof substitution === 'string' &&\n      substitution.includes('{')\n    ) {\n      if (recursiveLocalCount++ > maximumLocalNestingDepth) {\n        throw new TypeError('Too much recursion in local variables.');\n      }\n\n      if (localFormatter.constructor.isMatchingKey(ky)) {\n        let extraSubsts = substitutions;\n        let localFormatters;\n        if (arg) {\n          localFormatters = parseJSONExtra(arg);\n          extraSubsts = {\n            ...substitutions,\n            ...localFormatters\n          };\n        }\n        substitution = processSubsts({\n          str: substitution, substs: extraSubsts,\n          formatter: localFormatter\n        });\n        if (localFormatters) {\n          checkExtraSuppliedFormatters({substitutions: localFormatters});\n        }\n      } else if (switchFormatter.constructor.isMatchingKey(ky)) {\n        substitution = processSubsts({\n          str: substitution\n        });\n      }\n    }\n    return substitution;\n  };\n\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    // Run this block to optimize non-DOM substitutions\n    let returnsDOM = false;\n    const replace = ({\n      str, substs = substitutions,\n      formatter = regularFormatter\n    }) => {\n      return str.replace(formattingRegex, (_, esc, ky, pipe, arg) => {\n        if (esc.length % 2) {\n          return _;\n        }\n        if (missingSuppliedFormatters({\n          key: ky,\n          formatter\n        })) {\n          return _;\n        }\n        let substitution = getSubstitution({key: ky, arg, substs});\n\n        substitution = checkLocalVars({\n          substitution, ky, arg, processSubsts: replace\n        });\n\n        returnsDOM = returnsDOM ||\n          (substitution && typeof substitution === 'object' &&\n          'nodeType' in substitution);\n        usedKeys.push(ky);\n        return esc + substitution;\n      });\n    };\n    const ret = replace({str: string});\n    if (!returnsDOM) {\n      checkExtraSuppliedFormatters({substitutions});\n      usedKeys.length = 0;\n      return unescapeBackslashes(ret);\n    }\n    usedKeys.length = 0;\n  }\n\n  recursiveLocalCount = 1;\n  const processSubstitutions = ({\n    str, substs = substitutions, formatter = regularFormatter\n  }) => {\n    const nodes = [];\n\n    // Copy to ensure we are resetting index on each instance (manually\n    // resetting on `formattingRegex` is problematic with recursion that\n    // uses the same regex copy)\n    const regex = new RegExp(formattingRegex, 'gu');\n\n    const push = (...args) => {\n      nodes.push(...args);\n    };\n\n    processRegex(regex, str, {\n      extra: push,\n      onMatch (_, esc, ky, pipe, arg) {\n        if (missingSuppliedFormatters({\n          key: ky, formatter\n        })) {\n          push(_);\n        } else {\n          if (esc.length) {\n            push(esc);\n          }\n\n          let substitution = getSubstitution({key: ky, arg, substs});\n          substitution = checkLocalVars({\n            substitution, ky, arg, processSubsts: processSubstitutions\n          });\n          if (Array.isArray(substitution)) {\n            push(...substitution);\n          } else if (\n            // Clone so that multiple instances may be added (and no\n            // side effects to user code)\n            substitution && typeof substitution === 'object' &&\n            'nodeType' in substitution\n          ) {\n            push(substitution.cloneNode(true));\n          } else {\n            push(substitution);\n          }\n        }\n        usedKeys.push(ky);\n      }\n    });\n    return nodes;\n  };\n  const nodes = processSubstitutions({str: string});\n\n  checkExtraSuppliedFormatters({substitutions});\n  usedKeys.length = 0;\n  return nodes.map((node) => {\n    if (typeof node === 'string') {\n      return unescapeBackslashes(node);\n    }\n    return node;\n  });\n};\n","import {unescapeBackslashes, processRegex} from './utils.js';\n\n/**\n* @typedef {LocaleBody} LocalObject\n*/\n\n/**\n * May also contain language code and direction, translator name and\n * contact, etc., but no defaults currently apply besides reserving `locals`\n * @typedef {PlainObject} LocaleHead\n * @property {LocalObject} locals\n*/\n\n/**\n* @typedef {LocaleStringBodyObject|PlainLocaleStringBodyObject|PlainObject}\n* LocaleBody\n*/\n\n/**\n* @typedef {PlainObject} LocaleObject\n* @property {LocaleHead} [head]\n* @property {LocaleBody} body\n*/\n\n/**\n* @typedef {PlainObject} MessageStyleCallbackResult\n* @property {string} value Regardless of message style, will contain the\n*   string result\n* @property {LocaleStringSubObject} [info] Full info on the localized item\n*   (for rich message styles only)\n*/\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|MessageStyleCallbackResult} If `false`, will resort to default\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  /* eslint-enable max-len */\n  messageStyle = 'richNested'\n} = {}) => {\n  // Todo: Support `plainNested` style\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'richNested'\n      ? (mainObj, key) => {\n        const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n        const keys = [];\n        // eslint-disable-next-line prefer-named-capture-group\n        const possiblyEscapedCharPattern = /(\\\\*)\\./gu;\n        const mergeWithPreviousOrStart = (val) => {\n          if (!keys.length) {\n            keys[0] = '';\n          }\n          keys[keys.length - 1] += val;\n        };\n        processRegex(possiblyEscapedCharPattern, key, {\n          // If odd, this is just an escaped dot, so merge content with\n          //   any previous\n          extra: mergeWithPreviousOrStart,\n          onMatch (_, esc) {\n            // If even, there are no backslashes, or they are just escaped\n            //  backslashes and not an escaped dot, so start anew, though\n            //  first merge any backslashes\n            mergeWithPreviousOrStart(esc);\n            keys.push('');\n          }\n        });\n        const keysUnescaped = keys.map((ky) => {\n          return unescapeBackslashes(ky);\n        });\n\n        let ret = false;\n        let currObj = obj;\n        keysUnescaped.some((ky, i, kys) => {\n          if (!currObj || typeof currObj !== 'object') {\n            return true;\n          }\n          if (\n            // If specified key is too deep, we should fail\n            i === kys.length - 1 &&\n            ky in currObj && currObj[ky] && typeof currObj[ky] === 'object' &&\n            'message' in currObj[ky] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof currObj[ky].message === 'string'\n          ) {\n            ret = {\n              value: currObj[ky].message,\n              info: currObj[ky]\n            };\n          }\n          currObj = currObj[ky];\n\n          return false;\n        });\n        return ret;\n      }\n      : (messageStyle === 'rich'\n        ? (mainObj, key) => {\n          const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n          if (\n            obj && typeof obj === 'object' &&\n            key in obj && obj[key] && typeof obj[key] === 'object' &&\n            'message' in obj[key] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof obj[key].message === 'string'\n          ) {\n            return {\n              value: obj[key].message,\n              info: obj[key]\n            };\n          }\n          return false;\n        }\n        : (messageStyle === 'plain'\n          ? (mainObj, key) => {\n            const obj = mainObj && typeof mainObj === 'object' && mainObj.body;\n            if (\n              obj && typeof obj === 'object' &&\n              key in obj && obj[key] && typeof obj[key] === 'string'\n            ) {\n              return {\n                value: obj[key]\n              };\n            }\n            return false;\n          }\n          : (() => {\n            throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n          })())\n      )\n    );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message] If present, this string will be the return value.\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings; used to find a default if no string `message` is provided.\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n} = {}) => {\n  if (typeof key !== 'string') {\n    throw new TypeError(\n      'An options object with a `key` string is expected on ' +\n      '`getStringFromMessageAndDefaults`'\n    );\n  }\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  let str;\n  if (typeof message === 'string') {\n    str = message;\n  } else if (\n    defaults === false || defaults === undefined || defaults === null\n  ) {\n    str = false;\n  } else if (defaults && typeof defaults === 'object') {\n    str = messageForKey({body: defaults}, key);\n    if (str) {\n      str = str.value;\n    }\n  } else {\n    throw new TypeError(\n      `Default locale strings must resolve to \\`false\\`, ` +\n      `nullish, or an object!`\n    );\n  }\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n","import {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {defaultInsertNodes} from './defaultInsertNodes.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/* eslint-disable max-len */\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {string} cfg.locale The (possibly already resolved) locale for use by\n *   configuring formatters\n * @param {LocalObject} [cfg.locals]\n * @param {LocalObject} [cfg.switches]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {?(AllSubstitutionCallback|AllSubstitutionCallback[])} [cfg.allSubstitutions=[defaultAllSubstitutions]]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  /* eslint-enable max-len */\n  string,\n  locale,\n  locals,\n  switches,\n  maximumLocalNestingDepth,\n  allSubstitutions = [\n    defaultAllSubstitutions\n  ],\n  insertNodes = defaultInsertNodes,\n  substitutions = false,\n  dom = false,\n  forceNodeReturn = false,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true\n} = {}) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'An options object with a `string` property set to a string must ' +\n      'be provided for `getDOMForLocaleString`.'\n    );\n  }\n  const stringOrTextNode = (str) => {\n    const _doc = getDocument();\n    return forceNodeReturn ? _doc.createTextNode(str) : str;\n  };\n\n  const usedKeys = [];\n\n  /**\n  * @callback CheckExtraSuppliedFormattersCallback\n  * @param {SubstitutionObject} substs\n  * @throws {Error} Upon an extra formatting key being found\n  * @returns {void}\n  */\n\n  /**\n   * @type {CheckExtraSuppliedFormattersCallback}\n   */\n  const checkExtraSuppliedFormatters = ({\n    substitutions: substs\n  }) => {\n    if (throwOnExtraSuppliedFormatters) {\n      Object.keys(substs).forEach((key) => {\n        if (!usedKeys.includes(key)) {\n          throw new Error(`Extra formatting key: ${key}`);\n        }\n      });\n    }\n  };\n\n  /**\n  * @callback MissingSuppliedFormattersCallback\n  * @param {string} key\n  * @param {SubstitutionObject} substs\n  * @throws {Error} If missing formatting key\n  * @returns {boolean}\n  */\n  /**\n   * @type {MissingSuppliedFormattersCallback}\n   */\n  const missingSuppliedFormatters = ({\n    key, formatter\n  }) => {\n    const matching = formatter.isMatch(key);\n    if (formatter.constructor.isMatchingKey(key) && !matching) {\n      if (throwOnMissingSuppliedFormatters) {\n        throw new Error(`Missing formatting key: ${key}`);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  if (\n    !substitutions && !allSubstitutions &&\n    !throwOnMissingSuppliedFormatters\n  ) {\n    return stringOrTextNode(string);\n  }\n  if (!substitutions) {\n    substitutions = {};\n  }\n\n  const nodes = insertNodes({\n    string, dom, usedKeys, substitutions, allSubstitutions, locale,\n    locals, switches,\n    missingSuppliedFormatters,\n    checkExtraSuppliedFormatters\n  });\n  if (typeof nodes === 'string') {\n    return stringOrTextNode(nodes);\n  }\n\n  const _doc = getDocument();\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n\n  return container;\n};\n","/* globals intlDomLocale */\n\nimport {defaultLocaleResolver} from './defaultLocaleResolver.js';\nimport {promiseChainForValues} from './promiseChainForValues.js';\nimport {getFetch} from './shared.js';\n\nexport {setFetch, getFetch} from './shared.js';\n\n/**\n * Takes a locale and returns a new locale to check.\n * @callback LocaleMatcher\n * @param {string} locale The failed locale\n * @throws {Error} If there are no further hyphens left to check\n * @returns {string|Promise<string>} The new locale to check\n*/\n\n/**\n * @type {LocaleMatcher}\n */\nexport const defaultLocaleMatcher = (locale) => {\n  if (!locale.includes('-')) {\n    throw new Error('Locale not available');\n  }\n  // Try without hyphen, i.e., the \"lookup\" algorithm:\n  // See https://tools.ietf.org/html/rfc4647#section-3.4 and\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\n  return locale.replace(/-[^-]*$/u, '');\n};\n\n/**\n * @param {PlainObject} cfg\n * @param {string} cfg.locale\n * @param {string[]} cfg.locales\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleMatcher]\n * @returns {string|false}\n */\nexport const getMatchingLocale = ({\n  locale, locales, localeResolver = defaultLocaleMatcher\n}) => {\n  try {\n    while (!locales.includes(locale)) {\n      // Catch as `defaultLocaleMatcher` will throw if no hyphen found\n      locale = localeResolver(locale);\n    }\n  } catch (err) {\n    return false;\n  }\n  return locale;\n};\n\n/**\n* @typedef {PlainObject} LocaleObjectInfo\n* @property {LocaleObject} strings The successfully retrieved locale strings\n* @property {string} locale The successfully resolved locale\n*/\n\n/**\n * @callback LocaleStringFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<LocaleObjectInfo>}\n */\n\n/**\n *\n * @type {LocaleStringFinder}\n */\nexport const findLocaleStrings = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n};\n\n/**\n * @callback LocaleFinder\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher]\n * @returns {Promise<string>} Resolves to the successfully resolved locale\n */\n\n/**\n *\n * @type {LocaleFinder}\n */\nexport const findLocale = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return _findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher,\n    headOnly: true\n  });\n};\n\n/**\n * @type {LocaleStringFinder|LocaleFinder} Also has a `headOnly` boolean\n *  property to determine whether to make a simple HEAD and resolve to\n *  the locale rather than locale and contents\n */\nconst _findLocale = async ({\n  locales = typeof intlDomLocale !== 'undefined'\n    ? [intlDomLocale]\n    : typeof navigator === 'undefined' ? [] : navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.',\n  localeMatcher = 'lookup',\n  headOnly = false\n}) => {\n  /**\n   * @callback getLocale\n   * @throws {SyntaxError|TypeError|Error}\n   * @param {string} locale\n   * @returns {Promise<LocaleObjectInfo>}\n   */\n  async function getLocale (locale) {\n    if (typeof locale !== 'string') {\n      throw new TypeError('Non-string locale type');\n    }\n    const url = localeResolver(localesBasePath, locale);\n    if (typeof url !== 'string') {\n      throw new TypeError(\n        '`localeResolver` expected to resolve to (URL) string.'\n      );\n    }\n    try {\n      const _fetch = getFetch();\n      const resp = await (headOnly\n        ? _fetch(url, {\n          method: 'HEAD'\n        })\n        : _fetch(url)\n      );\n\n      if (resp.status === 404) {\n        // Don't allow browser (tested in Firefox) to continue\n        //  and give `SyntaxError` with missing file or we won't be\n        //  able to try without the hyphen\n        throw new Error('Trying again');\n      }\n      if (headOnly) {\n        return locale;\n      }\n      const strings = await (resp.json());\n      return {\n        locale,\n        strings\n      };\n    } catch (err) {\n      if (err.name === 'SyntaxError') {\n        throw err;\n      }\n      const newLocale = await localeMatcher(locale);\n      return getLocale(newLocale);\n    }\n  }\n  if (localeMatcher === 'lookup') {\n    localeMatcher = defaultLocaleMatcher;\n  } else if (typeof localeMatcher !== 'function') {\n    throw new TypeError('`localeMatcher` must be \"lookup\" or a function!');\n  }\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    getLocale,\n    'No matching locale found!'\n  );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\nimport {findLocaleStrings} from './findLocaleStrings.js';\nimport {getDOMForLocaleString} from './getDOMForLocaleString.js';\nimport {\n  getStringFromMessageAndDefaults\n} from './getStringFromMessageAndDefaults.js';\nimport {sort, sortList, list} from './collation.js';\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present.\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {LocaleObject} cfg.strings\n * @param {string} cfg.resolvedLocale\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18nServer = function i18nServer ({\n  /* eslint-enable max-len */\n  strings,\n  resolvedLocale,\n  messageStyle,\n  allSubstitutions: defaultAllSubstitutionsValue,\n  insertNodes,\n  defaults: defaultDefaults,\n  substitutions: defaultSubstitutions,\n  maximumLocalNestingDepth,\n  dom: domDefaults = false,\n  forceNodeReturn: forceNodeReturnDefault = false,\n  throwOnMissingSuppliedFormatters:\n    throwOnMissingSuppliedFormattersDefault = true,\n  throwOnExtraSuppliedFormatters:\n    throwOnExtraSuppliedFormattersDefault = true\n}) {\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const formatter = (key, substitutions, {\n    allSubstitutions = defaultAllSubstitutionsValue,\n    defaults = defaultDefaults,\n    dom = domDefaults,\n    forceNodeReturn = forceNodeReturnDefault,\n    throwOnMissingSuppliedFormatters = throwOnMissingSuppliedFormattersDefault,\n    throwOnExtraSuppliedFormatters = throwOnExtraSuppliedFormattersDefault\n  } = {}) => {\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message: (message && message.value) || false,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      locals: strings.head && strings.head.locals,\n      switches: strings.head && strings.head.switches,\n      locale: resolvedLocale,\n      maximumLocalNestingDepth,\n      allSubstitutions,\n      insertNodes,\n      substitutions: {...defaultSubstitutions, ...substitutions},\n      dom,\n      forceNodeReturn,\n      throwOnMissingSuppliedFormatters,\n      throwOnExtraSuppliedFormatters\n    });\n  };\n\n  formatter.resolvedLocale = resolvedLocale;\n  formatter.strings = strings;\n\n  formatter.sort = (...args) => {\n    return sort(resolvedLocale, ...args);\n  };\n\n  formatter.sortList = (...args) => {\n    return sortList(\n      resolvedLocale, ...args\n    );\n  };\n\n  formatter.list = (...args) => {\n    return list(\n      resolvedLocale, ...args\n    );\n  };\n\n  return formatter;\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=[\"en-US\"]]\n * @param {LocaleStringFinder} [cfg.localeStringFinder=findLocaleStrings]\n * @param {string} [cfg.localesBasePath=\".\"]\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"lookup\"|LocaleMatcher} [cfg.localeMatcher=\"lookup\"]\n * @param {\"richNested\"|\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle=\"richNested\"]\n * @param {?AllSubstitutionCallback|AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {InsertNodesCallback} [cfg.insertNodes=defaultInsertNodes]\n * @param {false|null|undefined|LocaleObject} [cfg.defaults]\n * @param {false|SubstitutionObject} [cfg.substitutions={}]\n * @param {Integer} [cfg.maximumLocalNestingDepth=3]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localeStringFinder = findLocaleStrings,\n  localesBasePath,\n  localeResolver,\n  localeMatcher,\n  messageStyle,\n  allSubstitutions,\n  insertNodes,\n  defaults,\n  substitutions,\n  maximumLocalNestingDepth,\n  dom,\n  forceNodeReturn,\n  throwOnMissingSuppliedFormatters,\n  throwOnExtraSuppliedFormatters\n} = {}) {\n  const {strings, locale: resolvedLocale} = await localeStringFinder({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n\n  return i18nServer({\n    strings,\n    resolvedLocale,\n    messageStyle,\n    allSubstitutions,\n    insertNodes,\n    defaults,\n    substitutions,\n    maximumLocalNestingDepth,\n    dom,\n    forceNodeReturn,\n    throwOnMissingSuppliedFormatters,\n    throwOnExtraSuppliedFormatters\n  });\n};\n"],"names":["lib","fn","basedir","module","path","exports","require","base","Error","commonjsRequire","createCommonjsModule","WORD_POS_END","contexts","getContext","pop","context","elements","element_array","dropContext","ctx","push","buffers","dropBuffer","buf","JSON6","escape","string","output","n","length","begin","cb","reviver","val","name","value_type","contains","pos","line","col","word","status","negative","result","parse_context","comment","fromHex","decimal","exponent","exponent_sign","exponent_digit","gatheringStringFirstChar","gatheringString","gatheringNumber","stringEscape","cr_escaped","unicodeWide","stringUnicode","stringHex","hex_char","hex_char_len","completed","context_stack","first","last","saved","node","recover","this","next","prior","inQueue","shift","unshift","throwEndError","leader","finalError","console","log","value","r","undefined","reset","save","write","msg","retcode","String","_write","walk","holder","key","k","Object","prototype","hasOwnProperty","call","v","complete_at_end","input","retval","throwError","c","fromCodePoint","substr","RESET_VAL","arrayPush","Number","NaN","Infinity","objectPush","gatherString","start_c","str","charAt","cInt","codePointAt","collectNumber","_n","getBuffer","old_context","tmpobj","tmparr","_parser","freeze","_parse_level","parse","parse_level","parser","stringify","JSON","unescapeBackslashes","replace","esc","slice","parseJSONExtra","args","jsonExtra","processRegex","regex","match","onMatch","extra","betweenMatches","afterMatch","escapeAtOne","previousIndex","exec","_","lastIndex","startMatchPos","_fetch","fetch","getFetch","_doc","document","getDocument","sort","locale","arrayOfItems","options","Intl","Collator","compare","list","ListFormat","format","sortList","map","listOptions","collationOptions","sortListSimple","d","randomId","Date","now","performance","Math","trunc","random","floor","toString","placeholderArray","_toConsumableArray","i","nodes","RegExp","idx","container","createDocumentFragment","append","getFormatterInfo","object","Array","isArray","callback","extraOpts","defaultAllSubstitutions","opts","arg","_typeof","applyArgs","type","checkArgOptions","split","userType","extraArgs","argOptions","singleKey","keys","includes","RelativeTimeFormat","NumberFormat","getTime","DateTimeFormat","TypeError","Formatter","getSubstitution","body","messageStyle","substitution","getMessageForKeyByStyle","messageForKey","LocalFormatter","locals","components","parent","constructor","isMatchingKey","every","cmpt","startsWith","RegularFormatter","substitutions","test","SwitchFormatter","switches","usedKeys","missingSuppliedFormatters","ky","getKey","getMatch","objKey","keySegment","formatter","getNumberFormat","defaultOptions","numberOpts","getPluralFormat","pluralOpts","PluralRules","select","formatterValue","toUpperCase","toLowerCase","preventNesting","s","err","error","find","switchKey","Boolean","ks","reduce","obj","ret","entries","_this4","concat","then","direct","Promise","resolve","e","pact","state","o","_settle","bind","observer","_Pact","onFulfilled","onRejected","_this","thenable","update","stage","shouldContinue","_isSettledPact","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","f","arguments","apply","promiseChainForValues","values","errBack","errorMessage","_async","breaking","p","defaultLocaleResolver","localesBasePath","defaultInsertNodes","dom","allSubstitutions","maximumLocalNestingDepth","checkExtraSuppliedFormatters","localFormatter","regularFormatter","switchFormatter","formattingRegex","substs","subst","allSubst","recursiveLocalCount","checkLocalVars","processSubsts","localFormatters","extraSubsts","returnsDOM","pipe","processSubstitutions","cloneNode","mainObj","mergeWithPreviousOrStart","keysUnescaped","currObj","some","kys","message","info","getStringFromMessageAndDefaults","defaults","getDOMForLocaleString","insertNodes","forceNodeReturn","throwOnMissingSuppliedFormatters","throwOnExtraSuppliedFormatters","stringOrTextNode","createTextNode","forEach","matching","isMatch","defaultLocaleMatcher","findLocaleStrings","locales","defaultLocales","localeResolver","localeMatcher","_findLocale","getLocale","url","headOnly","method","resp","json","strings","intlDomLocale","navigator","languages","i18nServer","resolvedLocale","defaultAllSubstitutionsValue","defaultDefaults","defaultSubstitutions","domDefaults","forceNodeReturnDefault","throwOnMissingSuppliedFormattersDefault","throwOnExtraSuppliedFormattersDefault","head","localeStringFinder","doc"],"mappings":"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"}