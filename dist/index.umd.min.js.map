{"version":3,"file":"index.umd.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n* @callback PromiseChainErrback\n* @param {any} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @param {string} [errorMessage=\"Reached end of values array.\"]\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\n promiseChainForValues(['a', 'b', 'c'], (val) => {\n   return new Promise(function (resolve, reject) {\n     if (val === 'a') {\n       reject(new Error('missing'));\n     }\n     setTimeout(() => {\n       resolve(val);\n     }, 100);\n   });\n });\n */\nexport const promiseChainForValues = (\n  values, errBack, errorMessage = 'Reached end of values array.'\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(\n      'The `values` argument to `promiseChainForValues` must be an array.'\n    );\n  }\n  if (typeof errBack !== 'function') {\n    throw new TypeError(\n      'The `errBack` argument to `promiseChainForValues` must be a function.'\n    );\n  }\n  return (async () => {\n    let ret;\n    let p = Promise.reject(\n      new Error('Intentionally reject so as to begin checking chain')\n    );\n    let breaking;\n    while (true) {\n      const value = values.shift();\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        ret = await p;\n        break;\n      } catch (err) {\n        if (breaking) {\n          throw new Error(errorMessage);\n        }\n        // We allow one more try\n        if (!values.length) {\n          breaking = true;\n        }\n        // // eslint-disable-next-line no-await-in-loop\n        p = errBack(value);\n      }\n    }\n    return ret;\n  })();\n};\n\n/**\n* @callback SubstitutionCallback\n* @param {string} arg Accepts the third portion of the `bracketRegex` of\n*   `i18n`, i.e., to allow the locale to supply arguments back to the\n*   calling script.\n* @returns {string} The replacement text\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringObject\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} message The locale message with any formatting\n*   place-holders\n* @property {string} description A description to add translators\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringObject\n*/\n\n/**\n * @callback LocaleResolver\n * @param {string} localesBasePath (Trailing slash optional)\n * @param {string} locale BCP-47 language string\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|SubstitutionCallback>}\n*   SubstitutionObject\n*/\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (localesBasePath, locale) => {\n  if (typeof localesBasePath !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `localesBasePath`.'\n    );\n  }\n  if (typeof locale !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `locale`.'\n    );\n  }\n  return `${localesBasePath.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleStringObject|PlainLocaleStringObject|PlainObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|string} If `false`, will resort to default\n*/\n\n/**\n * @param {PlainObject} [cfg]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  messageStyle = 'rich'\n} = {}) => {\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'rich'\n      ? (obj, key) => {\n        if (key in obj && obj[key] && 'message' in obj[key] &&\n          // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n          typeof obj[key].message === 'string'\n        ) {\n          return obj[key].message;\n        }\n        return false;\n      }\n      : (messageStyle === 'plain'\n        ? (obj, key) => {\n          if (key in obj && obj[key] && typeof obj[key] === 'string') {\n            return obj[key];\n          }\n          return false;\n        }\n        : (() => {\n          throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n        })()\n      )\n    );\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message]\n * @param {false|LocaleStringObject|PlainLocaleStringObject|PlainObject} [cfg.defaults]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n} = {}) => {\n  if (typeof key !== 'string') {\n    throw new TypeError(\n      'An options object with a `key` string is expected on ' +\n      '`getStringFromMessageAndDefaults`'\n    );\n  }\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  const str = typeof message === 'string'\n    ? message\n    : (defaults === false\n      ? false\n      : (defaults && typeof defaults === 'object'\n        ? messageForKey(defaults, key)\n        : (() => {\n          throw new TypeError(\n            `Default locale strings must resolve to \\`false\\` or an object!`\n          );\n        })()\n      )\n    );\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @param {RegExp} [cfg.bracketRegex=/\\{([^}]*?)(?:\\|([^}]*))?\\}/gu]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  string,\n  substitutions = false,\n  dom = false,\n  forceNodeReturn = false,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true,\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  bracketRegex = /(\\\\*)\\{([^}]*?)(?:\\|([^}]*))?\\}/gu\n} = {}) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'An options object with a `string` property set to a string must ' +\n      'be provided for `getDOMForLocaleString`.'\n    );\n  }\n  const stringOrTextNode = (str) => {\n    return forceNodeReturn ? document.createTextNode(str) : str;\n  };\n\n  const usedKeys = [];\n  const checkExtraSuppliedFormatters = () => {\n    if (throwOnExtraSuppliedFormatters) {\n      Object.keys(substitutions).forEach((key) => {\n        if (!usedKeys.includes(key)) {\n          throw new Error(`Extra formatting key: ${key}`);\n        }\n      });\n    }\n  };\n  const checkMissingSuppliedFormatters = (ky) => {\n    if (throwOnMissingSuppliedFormatters && !(ky in substitutions)) {\n      throw new Error(`Missing formatting key: ${ky}`);\n    }\n  };\n\n  if (!substitutions && !throwOnMissingSuppliedFormatters) {\n    return stringOrTextNode(string);\n  }\n  if (!substitutions) {\n    substitutions = {};\n  }\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    let returnsDOM = false;\n    // Run this block to optimize non-DOM substitutions\n    const ret = string.replace(bracketRegex, (_, esc, ky, arg) => {\n      if (esc.length % 2) {\n        // Ignore odd sequences of escape sequences\n        return _;\n      }\n      checkMissingSuppliedFormatters(ky);\n      let substitution = substitutions[ky];\n      if (typeof substitution === 'function') {\n        substitution = substitution(arg);\n      }\n      returnsDOM = returnsDOM ||\n        (substitution && substitution.nodeType === 1);\n      usedKeys.push(ky);\n      return esc + substitution;\n    });\n    checkExtraSuppliedFormatters();\n    if (!returnsDOM) {\n      return stringOrTextNode(ret);\n    }\n    usedKeys.length = 0;\n  }\n  const nodes = [];\n  let result;\n  let previousIndex = 0;\n  while ((result = bracketRegex.exec(string)) !== null) {\n    const [, esc, ky, arg] = result;\n\n    const {lastIndex} = bracketRegex;\n    if (esc % 2) {\n      // Ignore odd sequences of escape sequences\n      continue;\n    }\n    const startBracketPos = lastIndex - ky.length - 2;\n    if (startBracketPos > previousIndex) {\n      nodes.push(string.slice(previousIndex, startBracketPos));\n    }\n    if (esc.length) {\n      nodes.push(esc);\n    }\n\n    checkMissingSuppliedFormatters(ky);\n    let substitution = substitutions[ky];\n    if (typeof substitution === 'function') {\n      substitution = substitution(arg);\n    }\n    nodes.push(substitution);\n\n    previousIndex = lastIndex;\n    usedKeys.push(ky);\n  }\n  if (previousIndex !== string.length) { // Get text at end\n    nodes.push(string.slice(previousIndex));\n  }\n\n  checkExtraSuppliedFormatters();\n\n  const container = document.createDocumentFragment();\n\n  // console.log('nodes', nodes);\n  container.append(...nodes);\n  return container;\n};\n\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @returns {Promise<LocaleStringObject|PlainLocaleStringObject|PlainObject>}\n */\nexport const findLocaleStrings = async ({\n  locales = navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.'\n} = {}) => {\n  // eslint-disable-next-line no-return-await\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    async function getLocale (locale) {\n      if (typeof locale !== 'string') {\n        throw new TypeError('Non-string locale type');\n      }\n      const url = localeResolver(localesBasePath, locale);\n      if (typeof url !== 'string') {\n        throw new TypeError(\n          '`localeResolver` expected to resolve to (URL) string.'\n        );\n      }\n      try {\n        const resp = await fetch(url);\n        if (resp.status === 404) {\n          // Don't allow browser (tested in Firefox) to continue\n          //  and give `SyntaxError` with missing file or we won't be\n          //  able to try without the hyphen\n          throw new Error('Trying again');\n        }\n        return await (resp.json());\n      } catch (err) {\n        if (err.name === 'SyntaxError') {\n          throw err;\n        }\n        if (!locale.includes('-')) {\n          throw new Error('Locale not available');\n        }\n        // Try without hyphen\n        return getLocale(locale.replace(/-.*$/u, ''));\n      }\n    },\n    'No matching locale found!'\n  );\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @param {RegExp} [cfg.bracketRegex=/\\{([^}]*?)(?:\\|([^}]*))?\\}/gu]\n * @param {false|LocaleStringObject|PlainLocaleStringObject|PlainObject} [cfg.defaults]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localesBasePath,\n  localeResolver,\n  messageStyle,\n  bracketRegex,\n  defaults: defaultDefaults,\n  dom: domDefaults = false,\n  forceNodeReturn: forceNodeReturnDefault = false,\n  throwOnMissingSuppliedFormatters:\n    throwOnMissingSuppliedFormattersDefault = true,\n  throwOnExtraSuppliedFormatters:\n    throwOnExtraSuppliedFormattersDefault = true\n} = {}) {\n  const strings = await findLocaleStrings({\n    locales, defaultLocales, localeResolver, localesBasePath\n  });\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  return (key, substitutions, {\n    defaults = defaultDefaults,\n    dom = domDefaults,\n    forceNodeReturn = forceNodeReturnDefault,\n    throwOnMissingSuppliedFormatters = throwOnMissingSuppliedFormattersDefault,\n    throwOnExtraSuppliedFormatters = throwOnExtraSuppliedFormattersDefault\n  } = {}) => {\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      substitutions,\n      dom,\n      forceNodeReturn,\n      throwOnMissingSuppliedFormatters,\n      throwOnExtraSuppliedFormatters,\n      bracketRegex\n    });\n  };\n};\n"],"names":["value","then","direct","Promise","resolve","body","recover","result","e","pact","state","s","o","_settle","bind","v","observer","_Pact","prototype","onFulfilled","onRejected","this","callback","_this","thenable","test","update","stage","shouldContinue","_isSettledPact","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","f","args","i","arguments","length","apply","promiseChainForValues","values","errBack","errorMessage","Array","isArray","TypeError","_async","ret","breaking","p","Error","shift","defaultLocaleResolver","localesBasePath","locale","replace","getMessageForKeyByStyle","messageStyle","obj","key","message","getStringFromMessageAndDefaults","defaults","messageForKey","str","_typeof","getDOMForLocaleString","string","substitutions","dom","forceNodeReturn","throwOnMissingSuppliedFormatters","throwOnExtraSuppliedFormatters","bracketRegex","stringOrTextNode","document","createTextNode","usedKeys","checkExtraSuppliedFormatters","Object","keys","forEach","includes","checkMissingSuppliedFormatters","ky","returnsDOM","_","esc","arg","substitution","nodeType","push","nodes","previousIndex","exec","lastIndex","startBracketPos","slice","container","createDocumentFragment","append","findLocaleStrings","locales","navigator","languages","defaultLocales","localeResolver","getLocale","url","fetch","resp","status","json","err","name","defaultDefaults","domDefaults","forceNodeReturnDefault","throwOnMissingSuppliedFormattersDefault","throwOnExtraSuppliedFormattersDefault","strings"],"mappings":"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"}