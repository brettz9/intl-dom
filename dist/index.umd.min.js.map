{"version":3,"file":"index.umd.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n* @callback PromiseChainErrback\n* @param {any} errBack\n* @returns {Promise<any>|any}\n*/\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\n promiseChainForValues(['a', 'b', 'c'], (val) => {\n   return new Promise(function (resolve, reject) {\n     if (val === 'a') {\n       reject(new Error('missing'));\n     }\n     setTimeout(() => {\n       resolve(val);\n     }, 100);\n   });\n });\n */\nexport const promiseChainForValues = (values, errBack) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(\n      'The `values` argument to `promiseChainForValues` must be an array.'\n    );\n  }\n  if (typeof errBack !== 'function') {\n    throw new TypeError(\n      'The `errBack` argument to `promiseChainForValues` must be a function.'\n    );\n  }\n  return (async () => {\n    let ret;\n    let p = Promise.reject(\n      new Error('Intentionally reject so as to begin checking chain')\n    );\n    while (true) {\n      const value = values.shift();\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        ret = await p;\n        break;\n      } catch (err) {\n        p = errBack(value);\n      }\n    }\n    return ret;\n  })();\n};\n\n/**\n* @callback SubstitutionCallback\n* @param {string} arg Accepts the third portion of the `bracketRegex` of\n*   `i18n`, i.e., to allow the locale to supply arguments back to the\n*   calling script.\n* @returns {string} The replacement text\n*/\n\n/**\n* @typedef {Object<string, string>} PlainLocaleStringObject\n*/\n\n/**\n* @typedef {PlainObject} LocaleStringSubObject\n* @property {string} message The locale message with any formatting\n*   place-holders\n* @property {string} description A description to add translators\n*/\n\n/**\n* @typedef {PlainObject<string, LocaleStringSubObject>} LocaleStringObject\n*/\n\n/**\n * @callback LocaleResolver\n * @param {string} localesBasePth (Trailing slash optional)\n * @param {string} locale BCP-47 language string\n * @returns {string} URL of the locale file to be fetched\n*/\n\n/**\n* @typedef {PlainObject<string, string|Element|SubstitutionCallback>}\n*   SubstitutionObject\n*/\n\n/**\n * Checks a key (against an object of strings). Optionally\n *  accepts an object of substitutions which are used when finding text\n *  within curly brackets (pipe symbol not allowed in its keys); the\n *  substitutions may be DOM elements as well as strings and may be\n *  functions which return the same (being provided the text after the\n *  pipe within brackets as the single argument).) Optionally accepts a\n *  config object, with the optional key \"dom\" which if set to `true`\n *  optimizes when DOM elements are (known to be) present\n * @callback I18NCallback\n * @param {string} key Key to check against object of strings\n * @param {false|SubstitutionObject} [substitutions=false]\n * @param {PlainObject} [cfg={}]\n * @param {boolean} [cfg.dom=false]\n * @returns {string|DocumentFragment}\n*/\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (localesBasePath, locale) => {\n  if (typeof localesBasePath !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `localesBasePath`.'\n    );\n  }\n  if (typeof locale !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `locale`.'\n    );\n  }\n  return `${localesBasePath.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleStringObject|PlainLocaleStringObject|PlainObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|string} If `false`, will resort to default\n*/\n\n/**\n * @param {PlainObject} [cfg]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  messageStyle = 'rich'\n} = {}) => {\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'rich'\n      ? (obj, key) => {\n        if (key in obj && obj[key] && 'message' in obj[key] &&\n          // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n          typeof obj[key].message === 'string'\n        ) {\n          return obj[key].message;\n        }\n        return false;\n      }\n      : (messageStyle === 'plain'\n        ? (obj, key) => {\n          if (key in obj && obj[key] && typeof obj[key] === 'string') {\n            return obj[key];\n          }\n          return false;\n        }\n        : (() => {\n          throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n        })()\n      )\n    );\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} cfg\n * @param {string} [cfg.message]\n * @param {false|LocaleStringObject|PlainLocaleStringObject|PlainObject} [cfg.defaults]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @param {MessageStyleCallback} [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  /* eslint-enable max-len */\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n} = {}) => {\n  if (typeof key !== 'string') {\n    throw new TypeError(\n      'An options object with a `key` string is expected on ' +\n      '`getStringFromMessageAndDefaults`'\n    );\n  }\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  const str = typeof message === 'string'\n    ? message\n    : (defaults === false\n      ? false\n      : (defaults && typeof defaults === 'object'\n        ? messageForKey(defaults, key)\n        : (() => {\n          throw new TypeError(\n            `Default locale strings must resolve to \\`false\\` or an object!`\n          );\n        })()\n      )\n    );\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n\n/**\n *\n * @param {PlainObject} cfg\n * @param {string} cfg.string\n * @param {false|SubstitutionObject} [cfg.substitutions=false]\n * @param {boolean} [cfg.dom=false]\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @param {RegExp} [cfg.bracketRegex=/\\{([^}]*?)(?:\\|([^}]*))?\\}/gu]\n * @returns {string|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  string,\n  substitutions = false,\n  dom = false,\n  forceNodeReturn = false,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true,\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line prefer-named-capture-group, unicorn/no-unsafe-regex\n  bracketRegex = /(\\\\*)\\{([^}]*?)(?:\\|([^}]*))?\\}/gu\n} = {}) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'An options object with a `string` property set to a string must ' +\n      'be provided for `getDOMForLocaleString`.'\n    );\n  }\n  const stringOrTextNode = (str) => {\n    return forceNodeReturn ? document.createTextNode(str) : str;\n  };\n\n  const usedKeys = [];\n  const checkExtraSuppliedFormatters = () => {\n    if (throwOnExtraSuppliedFormatters) {\n      Object.keys(substitutions).forEach((key) => {\n        if (!usedKeys.includes(key)) {\n          throw new Error(`Extra formatting key: ${key}`);\n        }\n      });\n    }\n  };\n  const checkMissingSuppliedFormatters = (ky) => {\n    if (throwOnMissingSuppliedFormatters && !(ky in substitutions)) {\n      throw new Error(`Missing formatting key ${ky}`);\n    }\n  };\n\n  if (!substitutions && !throwOnMissingSuppliedFormatters) {\n    return stringOrTextNode(string);\n  }\n  if (!substitutions) {\n    substitutions = {};\n  }\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    let returnsDOM = false;\n    // Run this block to optimize non-DOM substitutions\n    const ret = string.replace(bracketRegex, (_, esc, ky, arg) => {\n      if (esc.length % 2) {\n        // Ignore odd sequences of escape sequences\n        return _;\n      }\n      checkMissingSuppliedFormatters(ky);\n      let substitution = substitutions[ky];\n      if (typeof substitution === 'function') {\n        substitution = substitution(arg);\n      }\n      returnsDOM = returnsDOM ||\n        (substitution && substitution.nodeType === 1);\n      usedKeys.push(ky);\n      return esc + substitution;\n    });\n    checkExtraSuppliedFormatters();\n    if (!returnsDOM) {\n      return stringOrTextNode(ret);\n    }\n    usedKeys.length = 0;\n  }\n  const nodes = [];\n  let result;\n  let previousIndex = 0;\n  while ((result = bracketRegex.exec(string)) !== null) {\n    const [, esc, ky, arg] = result;\n\n    const {lastIndex} = bracketRegex;\n    if (esc % 2) {\n      // Ignore odd sequences of escape sequences\n      continue;\n    }\n    const startBracketPos = lastIndex - ky.length - 2;\n    if (startBracketPos > previousIndex) {\n      nodes.push(string.slice(previousIndex, startBracketPos));\n    }\n    if (esc.length) {\n      nodes.push(esc);\n    }\n\n    checkMissingSuppliedFormatters(ky);\n    let substitution = substitutions[ky];\n    if (typeof substitution === 'function') {\n      substitution = substitution(arg);\n    }\n    nodes.push(substitution);\n\n    previousIndex = lastIndex;\n    usedKeys.push(ky);\n  }\n  if (previousIndex !== string.length) { // Get text at end\n    nodes.push(string.slice(previousIndex));\n  }\n\n  checkExtraSuppliedFormatters();\n\n  const container = document.createDocumentFragment();\n\n  // console.log('nodes', nodes);\n  container.append(...nodes);\n  return container;\n};\n\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @returns {Promise<LocaleStringObject|PlainLocaleStringObject|PlainObject>}\n */\nexport const findLocaleStrings = async ({\n  locales = navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.'\n} = {}) => {\n  // eslint-disable-next-line no-return-await\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    async function getLocale (locale) {\n      const url = localeResolver(localesBasePath, locale);\n      try {\n        return await (await fetch(url)).json();\n      } catch (err) {\n        if (!locale.includes('-')) {\n          throw new Error('Locale not available');\n        }\n        // Try without hyphen\n        return getLocale(locale.replace(/-.*$/u, ''));\n      }\n    }\n  );\n};\n\n/* eslint-disable max-len */\n/**\n * @param {PlainObject} [cfg={}]\n * @param {string[]} [cfg.locales=navigator.languages] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales=['en-US']]\n * @param {string} [cfg.localesBasePath='.']\n * @param {LocaleResolver} [cfg.localeResolver=defaultLocaleResolver]\n * @param {false|LocaleStringObject|PlainLocaleStringObject|PlainObject} [cfg.defaults]\n * @param {\"rich\"|\"plain\"|MessageStyleCallback} [cfg.messageStyle='rich']\n * @param {boolean} [cfg.forceNodeReturn=false]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters=true]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters=true]\n * @param {RegExp} [cfg.bracketRegex=/\\{([^}]*?)(?:\\|([^}]*))?\\}/gu]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  /* eslint-enable max-len */\n  locales,\n  defaultLocales,\n  localesBasePath,\n  localeResolver,\n  defaults,\n  messageStyle,\n  forceNodeReturn,\n  throwOnMissingSuppliedFormatters,\n  throwOnExtraSuppliedFormatters,\n  bracketRegex\n} = {}) {\n  const strings = await findLocaleStrings({\n    locales, defaultLocales, localeResolver, localesBasePath\n  });\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  return (key, substitutions, {dom} = {}) => {\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      substitutions,\n      dom,\n      forceNodeReturn,\n      throwOnMissingSuppliedFormatters,\n      throwOnExtraSuppliedFormatters,\n      bracketRegex\n    });\n  };\n};\n"],"names":["promiseChainForValues","values","errBack","Array","isArray","TypeError","_asyncToGenerator","p","Promise","reject","Error","value","shift","ret","defaultLocaleResolver","localesBasePath","locale","replace","getMessageForKeyByStyle","messageStyle","obj","key","message","getStringFromMessageAndDefaults","defaults","messageForKey","str","_typeof","getDOMForLocaleString","string","substitutions","dom","forceNodeReturn","throwOnMissingSuppliedFormatters","throwOnExtraSuppliedFormatters","bracketRegex","stringOrTextNode","document","createTextNode","usedKeys","checkExtraSuppliedFormatters","Object","keys","forEach","includes","checkMissingSuppliedFormatters","ky","returnsDOM","_","esc","arg","length","substitution","nodeType","push","result","nodes","previousIndex","exec","lastIndex","startBracketPos","slice","container","createDocumentFragment","append","findLocaleStrings","locales","navigator","languages","defaultLocales","localeResolver","url","fetch","json","getLocale","i18n","strings"],"mappings":"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"}