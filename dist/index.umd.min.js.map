{"version":3,"file":"index.umd.min.js","sources":["../src/utils.js","../src/shared.js","../src/collation.js","../src/defaultAllSubstitutions.js","../src/Formatter.js","../src/promiseChainForValues.js","../src/defaultLocaleResolver.js","../src/defaultInsertNodes.js","../src/defaultKeyCheckerConverter.js","../src/getMessageForKeyByStyle.js","../src/getStringFromMessageAndDefaults.js","../src/getDOMForLocaleString.js","../src/findLocaleStrings.js","../src/i18n.js"],"sourcesContent":["// We want it to work in the browser, so commenting out\n// import jsonExtra from 'json5';\n// import jsonExtra from 'json-6';\n\n/**\n * @typedef {any} JSON6\n */\n\n// @ts-expect-error Need typing for JSON6\nlet _jsonExtra = globalThis.jsonExtra;\n\n/**\n * @param {JSON6} __jsonExtra\n */\nexport const setJSONExtra = (__jsonExtra) => {\n  _jsonExtra = __jsonExtra;\n};\n\n/**\n * @param {string} str\n * @returns {string}\n */\nexport const unescapeBackslashes = (str) => {\n  return str.replaceAll(/\\\\+/gu, (esc) => {\n    return esc.slice(0, esc.length / 2);\n  });\n};\n\n/**\n * @typedef {any} AnyValue\n */\n\n/**\n * @param {string} args\n * @returns {AnyValue}\n */\nexport const parseJSONExtra = (args) => {\n  return _jsonExtra.parse(\n    // Doesn't actually currently allow explicit brackets,\n    //  but in case we change our regex to allow inner brackets\n    '{' + (args || '').replace(/^\\{/u, '').replace(/\\}$/u, '') + '}'\n  );\n};\n\n// Todo: Extract to own library (RegExtras?)\n\n/**\n * @callback BetweenMatches\n * @param {string} str\n * @returns {void}\n */\n\n/**\n * @callback AfterMatch\n * @param {string} str\n * @returns {void}\n */\n\n/**\n * @callback EscapeAtOne\n * @param {string} str\n * @returns {void}\n */\n\n/**\n * @param {RegExp} regex\n * @param {string} str\n * @param {{\n *   onMatch: (...arg0: string[]) => void,\n *   extra?: BetweenMatches|AfterMatch|EscapeAtOne\n *   betweenMatches?: BetweenMatches,\n *   afterMatch?: AfterMatch,\n *   escapeAtOne?: EscapeAtOne\n * }} cfg\n */\nexport const processRegex = (regex, str, {\n  onMatch,\n  extra,\n  betweenMatches,\n  afterMatch,\n  escapeAtOne\n}) => {\n  let match;\n  let previousIndex = 0;\n  if (extra) {\n    betweenMatches = extra;\n    afterMatch = extra;\n    escapeAtOne = extra;\n  }\n  if (!betweenMatches || !afterMatch) {\n    throw new Error(\n      'You must have `extra` or `betweenMatches` and `afterMatch` arguments.'\n    );\n  }\n  while ((match = regex.exec(str)) !== null) {\n    const [_, esc] = match;\n    const {lastIndex} = regex;\n\n    const startMatchPos = lastIndex - _.length;\n    if (startMatchPos > previousIndex) {\n      betweenMatches(str.slice(previousIndex, startMatchPos));\n    }\n\n    if (escapeAtOne && esc.length % 2) {\n      previousIndex = lastIndex;\n      escapeAtOne(_);\n      continue;\n    }\n    onMatch(...match);\n    previousIndex = lastIndex;\n  }\n  if (previousIndex !== str.length) { // Get text at end\n    afterMatch(str.slice(previousIndex));\n  }\n};\n","/* globals document -- Polyglot variable */\n\n/**\n * @typedef {(\n *   input: RequestInfo|URL, init?: RequestInit\n * ) => Promise<Response>} Fetch\n */\n/**\n * @type {null|Fetch}\n */\nlet _fetch = typeof fetch !== 'undefined'\n  ? fetch\n  /* c8 ignore next */\n  : null;\n\n/**\n * @param {Fetch} f\n * @returns {void}\n */\nexport const setFetch = (f) => {\n  _fetch = f;\n};\n\n/**\n * @returns {Fetch|null}\n */\nexport const getFetch = () => {\n  return _fetch;\n};\n\n/** @type {Document|null} */\nlet _doc = typeof document !== 'undefined'\n  /* c8 ignore next */\n  ? document\n  : null;\n\n/**\n * @param {Document} doc\n * @returns {void}\n */\nexport const setDocument = (doc) => {\n  _doc = doc;\n};\n\n/**\n * @returns {Document|null}\n */\nexport const getDocument = () => {\n  return _doc;\n};\n","import {processRegex} from './utils.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/**\n *\n * @returns {string}\n */\nfunction generateUUID () { //  Adapted from original: public domain/MIT: http://stackoverflow.com/a/8809472/271577\n  let d = Date.now();\n  /* c8 ignore next 5 */\n  if (typeof performance !== 'undefined' &&\n      typeof performance.now === 'function'\n  ) {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replaceAll(/[xy]/gu, function (c) {\n    /* eslint-disable no-bitwise, sonarjs/pseudo-random -- Convenient */\n    const r = Math.trunc((d + (Math.random() * 16)) % 16);\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : ((r & 0x3) | 0x8)).toString(16);\n    /* eslint-enable no-bitwise, sonarjs/pseudo-random -- Convenient */\n  });\n}\n\n/**\n *\n * @param {string} locale\n * @param {string[]} arrayOfItems\n * @param {Intl.CollatorOptions|undefined} options\n * @returns {string[]}\n */\nexport const sort = (locale, arrayOfItems, options) => {\n  return arrayOfItems.sort(new Intl.Collator(\n    locale,\n    options\n  ).compare);\n};\n\n/**\n *\n * @param {string} locale\n * @param {string[]} arrayOfItems\n * @param {Intl.ListFormatOptions|undefined} [options]\n * @returns {string}\n */\nexport const list = (locale, arrayOfItems, options) => {\n  return new Intl.ListFormat(\n    locale, options\n  ).format(arrayOfItems);\n};\n\n/**\n *\n * @param {string} locale\n * @param {string[]} arrayOfItems\n * @param {Intl.ListFormatOptions|undefined} [listOptions]\n * @param {Intl.CollatorOptions|undefined} [collationOptions]\n * @returns {string}\n */\nexport const sortListSimple = (\n  locale, arrayOfItems, listOptions, collationOptions\n) => {\n  sort(locale, arrayOfItems, collationOptions);\n  return list(locale, arrayOfItems, listOptions);\n};\n\n/**\n * @typedef {number} Integer\n */\n\n/**\n *\n * @param {string} locale\n * @param {string[]} arrayOfItems\n * @param {((str: string, idx: Integer) => any)|\n *   Intl.ListFormatOptions|undefined} map\n * @param {Intl.ListFormatOptions|undefined} [listOptions]\n * @param {Intl.CollatorOptions|undefined} [collationOptions]\n * @returns {DocumentFragment|string}\n */\nexport const sortList = (\n  locale, arrayOfItems, map, listOptions, collationOptions\n) => {\n  if (typeof map !== 'function') {\n    return sortListSimple(\n      locale, /** @type {string[]} */ (arrayOfItems), map, listOptions\n    );\n  }\n  sort(locale, arrayOfItems, collationOptions);\n\n  const randomId = generateUUID();\n\n  const placeholderArray = [...arrayOfItems].map(\n    (_, i) => `<<${randomId}${i}>>`\n  );\n\n  /** @type {(string|Node)[]} */\n  const nodes = [];\n\n  /**\n   * @param {string} arg\n   * @returns {void}\n   */\n  const push = (arg) => {\n    nodes.push(arg);\n  };\n\n  processRegex(\n    // // eslint-disable-next-line prefer-named-capture-group\n    new RegExp(`<<${randomId}(\\\\d)>>`, 'gu'),\n    list(locale, placeholderArray, listOptions),\n    {\n      betweenMatches: push,\n      afterMatch: push,\n      onMatch (_, idx) {\n        push(map(arrayOfItems[Number(idx)], Number(idx)));\n      }\n    }\n  );\n  const _doc = /** @type {Document} */ (getDocument());\n  const container = _doc.createDocumentFragment();\n  container.append(...nodes);\n  return container;\n};\n","import {parseJSONExtra} from './utils.js';\nimport {sortList} from './collation.js';\n\n/**\n * @typedef {number} Integer\n */\n\n/**\n * @param {{\n *   object: import('./defaultLocaleResolver.js').DateRangeValueArray|\n *     import('./defaultLocaleResolver.js').ListValueArray|\n *     import('./defaultLocaleResolver.js').RelativeValueArray|\n *     import('./defaultLocaleResolver.js').ValueArray\n * }} cfg\n * @returns {{\n *   value: number|string|string[]|Date,\n *   options?: Intl.NumberFormatOptions|Intl.PluralRulesOptions|\n *     string|Date|number,\n *   extraOpts?: object,\n *   callback?: (item: string, i: Integer) => Element\n * }}\n */\nexport const getFormatterInfo = ({object}) => {\n  if (Array.isArray(object)) {\n    if (typeof object[1] === 'function') {\n      const [\n        value, callback, options, extraOpts\n      ] =\n        /**\n         * @type {[\n         *   string[], (item: string, i: Integer) => Element, object, object\n         * ]}\n         */ (object);\n      return {value, callback, options, extraOpts};\n    }\n    const [value, options, extraOpts] = object;\n    return {value, options, extraOpts};\n  }\n  return {value: object};\n};\n\n/**\n * Callback to give replacement text based on a substitution value.\n *\n * `value` - contains the value returned by the individual substitution.\n * `arg` - See `cfg.arg` of {@link SubstitutionCallback}.\n * `key` - The substitution key Not currently in use\n * `locale` - The locale.\n * @typedef {(info: {\n *   value: import('./defaultLocaleResolver.js').SubstitutionObjectValue\n *   arg?: string,\n *   key?: string,\n *   locale?: string\n * }) => string|Node} AllSubstitutionCallback\n*/\n\n/**\n * @type {AllSubstitutionCallback}\n */\nexport const defaultAllSubstitutions = ({value, arg, /* , key */ locale}) => {\n  // Strings or DOM Nodes\n  if (\n    typeof value === 'string' || (value && typeof value === 'object' &&\n    'nodeType' in value)\n  ) {\n    return value;\n  }\n\n  /** @type {object|string|Date|number|undefined} */\n  let opts;\n\n  /**\n   * @param {{\n   *   type: string,\n   *   options?: object,\n   *   checkArgOptions?: boolean;\n   * }} cfg\n   * @returns {object|undefined}\n   */\n  const applyArgs = ({\n    type,\n    options = /** @type {object|undefined} */ (\n      opts\n    ),\n    checkArgOptions = false\n  }) => {\n    if (typeof arg === 'string') {\n      // eslint-disable-next-line prefer-const -- Convenient\n      let [userType, extraArgs, argOptions] = arg.split('|');\n      // Alias\n      if (userType === 'DATE') {\n        userType = 'DATETIME';\n      }\n      if (userType === type) {\n        if (!extraArgs) {\n          options = {};\n        } else if (!checkArgOptions || argOptions) {\n          // Todo: Allow escaping and restoring of pipe symbol\n          options = {\n            ...options,\n            ...parseJSONExtra(\n              checkArgOptions && argOptions ? argOptions : extraArgs\n            )\n          };\n        }\n      }\n    }\n    return options;\n  };\n\n  let expectsDatetime = false;\n  if (value && typeof value === 'object' && !Array.isArray(value)) {\n    const singleKey = Object.keys(value)[0];\n    if ([\n      'number', 'date', 'datetime', 'dateRange', 'datetimeRange', 'relative',\n      'region', 'language', 'script', 'currency',\n      'list', 'plural'\n    ].includes(singleKey)) {\n      let extraOpts, callback;\n      /**\n       * @typedef {any} AnyValue\n       */\n\n      const obj = /** @type {unknown} */ (\n        /** @type {AnyValue} */\n        (value)[\n          /**\n            * @type {\"number\"|\"date\"|\"datetime\"|\"dateRange\"|\n            *   \"datetimeRange\"|\"relative\"|\"region\"|\"language\"|\n            *   \"script\"|\"currency\"|\"list\"|\"plural\"}\n            */\n          (singleKey)\n        ]\n      );\n\n      ({\n        value, options: opts, extraOpts, callback\n      } = getFormatterInfo({\n        object:\n          /**\n           * @type {import('./defaultLocaleResolver.js').DateRangeValueArray|\n           *   import('./defaultLocaleResolver.js').ListValueArray|\n           *   import('./defaultLocaleResolver.js').RelativeValueArray|\n           *   import('./defaultLocaleResolver.js').ValueArray\n           * }\n           */\n          (obj)\n      }));\n\n      switch (singleKey) {\n      case 'date': case 'datetime':\n        expectsDatetime = true;\n        break;\n      case 'dateRange': case 'datetimeRange': {\n        const dtf = new Intl.DateTimeFormat(\n          locale,\n          applyArgs({type: 'DATERANGE', options: extraOpts})\n        );\n\n        return dtf.formatRange(\n          ...(\n          /** @type {[Date, Date]} */\n            ([\n              /** @type {number|Date} */\n              (value),\n              /** @type {Date} */\n              (opts)\n            ].map((val) => {\n              return typeof val === 'number' ? new Date(val) : val;\n            }))\n          )\n        );\n      } case 'region': case 'language': case 'script': case 'currency':\n        return /** @type {string} */ (new Intl.DisplayNames(\n          locale,\n          {\n            ...applyArgs({type: singleKey.toUpperCase()}),\n            type: singleKey\n          }\n        ).of(/** @type {string} */ (value)));\n      case 'relative':\n        // The second argument actually contains the primary options, so swap\n        // eslint-disable-next-line @stylistic/max-len -- Long\n        [extraOpts, opts] = /** @type {[Intl.RelativeTimeFormatUnit, object?]} */ (\n          [opts, extraOpts]\n        );\n        return new Intl.RelativeTimeFormat(\n          locale, applyArgs({type: 'RELATIVE'})\n        ).format(/** @type {number} */ (value), extraOpts);\n\n      // ListFormat (with Collator)\n      case 'list':\n        if (callback) {\n          return sortList(\n            /** @type {string} */ (locale),\n            /** @type {string[]} */\n            (value),\n            callback,\n            applyArgs({type: 'LIST'}),\n            applyArgs({\n              type: 'LIST', options: extraOpts, checkArgOptions: true\n            })\n          );\n        }\n        return sortList(\n          /** @type {string} */ (locale),\n          /** @type {string[]} */\n          (value),\n          applyArgs({type: 'LIST'}),\n          applyArgs({\n            type: 'LIST', options: extraOpts, checkArgOptions: true\n          })\n        );\n      default:\n        // Let `number` and `date` types drop through so their options\n        //  can be applied\n        // Let `plural` be treated as number (since value should be a number)\n        break;\n      }\n    }\n  }\n\n  // Dates\n  if (\n    value\n  ) {\n    if (\n      typeof value === 'number' &&\n      (expectsDatetime || (/^DATE(?:TIME)(?:\\||$)/u).test(\n        /** @type {string} */ (arg)\n      ))\n    ) {\n      value = new Date(value);\n    }\n    if (typeof value === 'object' && 'getTime' in value &&\n        typeof value.getTime === 'function') {\n      return new Intl.DateTimeFormat(\n        locale,\n        applyArgs({type: 'DATETIME'})\n      ).format(value);\n    }\n  }\n\n  // Date range\n  if (Array.isArray(value)) {\n    const extraOpts = /** @type {Intl.DateTimeFormatOptions|undefined} */ (\n      value[2]\n    );\n    return new Intl.DateTimeFormat(\n      locale,\n      applyArgs({type: 'DATERANGE', options: extraOpts})\n    ).formatRange(...(\n      /** @type {[Date, Date]} */\n      (value.slice(0, 2).map((val) => {\n        return typeof val === 'number' ? new Date(val) : val;\n      }))\n    ));\n  }\n\n  // Numbers\n  if (typeof value === 'number') {\n    return new Intl.NumberFormat(\n      locale,\n      applyArgs({type: 'NUMBER'})\n    ).format(value);\n  }\n\n  // console.log('value', value);\n  throw new TypeError('Unknown formatter');\n};\n","import {getMessageForKeyByStyle} from './index.js';\nimport {parseJSONExtra} from './utils.js';\nimport {getFormatterInfo} from './defaultAllSubstitutions.js';\n\n/**\n * Base class for formatting.\n */\nexport class Formatter {\n}\n\n/**\n * @param {object} cfg\n * @param {string} cfg.key\n * @param {import('./getMessageForKeyByStyle.js').LocaleBody} cfg.body\n * @param {string} cfg.type\n * @param {\"richNested\"|\"rich\"|\"plain\"|\n *   \"plainNested\"|import('./getMessageForKeyByStyle.js').\n *   MessageStyleCallback} [cfg.messageStyle]\n * @returns {string}\n */\nconst getSubstitution = ({key, body, type, messageStyle = 'richNested'}) => {\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n  const substitution = messageForKey({body}, key);\n  if (!substitution) {\n    throw new Error(`Key value not found for ${type} key: (${key})`);\n  }\n  // We don't allow a substitution function here or below as comes\n  //  from locale and locale content should not pose security concerns\n  return substitution.value;\n};\n\n/**\n * Formatter for local variables.\n */\nexport class LocalFormatter extends Formatter {\n  /**\n   * @param {import('./getMessageForKeyByStyle.js').LocalObject} locals\n   */\n  constructor (locals) {\n    super();\n    this.locals = locals;\n  }\n  /**\n   * @param {string} key\n   * @returns {string|Element}\n   */\n  getSubstitution (key) {\n    return getSubstitution({\n      key: key.slice(1), body: this.locals, type: 'local'\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    const components = key.slice(1).split('.');\n    /** @type {import('./getMessageForKeyByStyle.js').LocaleBody} */\n    let parent = this.locals;\n    return /** @type {typeof LocalFormatter} */ (\n      this.constructor\n    ).isMatchingKey(key) && components.every((cmpt) => {\n      const result = cmpt in parent;\n      parent =\n        /**\n         * @type {import('./defaultLocaleResolver.js').\n         *     RichNestedLocaleStringBodyObject|\n         *   import('./defaultLocaleResolver.js').\n         *     PlainNestedLocaleStringBodyObject|\n         *   import('./defaultLocaleResolver.js').RichLocaleStringSubObject\n         * }\n         */ (\n          /**\n           * @type {import('./defaultLocaleResolver.js').\n           *     RichNestedLocaleStringBodyObject|\n           *   import('./defaultLocaleResolver.js').\n           *     PlainNestedLocaleStringBodyObject\n           * }\n           */ (parent)[cmpt]\n        );\n      return result;\n    });\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('-');\n  }\n}\n\n/**\n * Formatter for regular variables.\n */\nexport class RegularFormatter extends Formatter {\n  /**\n   * @param {import('./defaultLocaleResolver.js').SubstitutionObject\n   * } substitutions\n   */\n  constructor (substitutions) {\n    super();\n    this.substitutions = substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return /** @type {typeof RegularFormatter} */ (\n      this.constructor\n    ).isMatchingKey(key) && key in this.substitutions;\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return (/^\\w/u).test(key);\n  }\n}\n\n/**\n * Formatter for switch variables.\n */\nexport class SwitchFormatter extends Formatter {\n  /**\n   * @param {import('./defaultLocaleResolver.js').Switches} switches\n   * @param {object} cfg\n   * @param {import('./defaultLocaleResolver.js').\n   *   SubstitutionObject} cfg.substitutions\n   */\n  constructor (switches, {substitutions}) {\n    super();\n    this.switches = switches;\n    this.substitutions = substitutions;\n  }\n\n  /**\n   * @param {string} key\n   * @param {object} cfg\n   * @param {string} cfg.locale\n   * @param {(string|undefined)[]} cfg.usedKeys\n   * @param {string} cfg.arg\n   * @param {import('./getDOMForLocaleString.js').\n   *   MissingSuppliedFormattersCallback} cfg.missingSuppliedFormatters\n   * @returns {string}\n   */\n  getSubstitution (key, {locale, usedKeys, arg, missingSuppliedFormatters}) {\n    const ky = /** @type {typeof SwitchFormatter} */ (\n      this.constructor\n    ).getKey(key).slice(1);\n    // Expression might not actually use formatter, e.g., for singular,\n    //  the conditional might just write out \"one\"\n\n    const [objKey, body, keySegment] = this.getMatch(ky);\n    usedKeys.push(keySegment);\n\n    let type;\n    /** @type {string} */\n    let opts;\n    if (objKey && objKey.includes('|')) {\n      [, type, opts] = objKey.split('|');\n    }\n    if (!body) {\n      missingSuppliedFormatters({\n        key,\n        formatter: this\n      });\n      return String.raw`\\{` + key + '}';\n    }\n\n    /*\n    if (!(ky in this.substitutions)) {\n      throw new Error(`Switch expecting formatter: ${ky}`);\n    }\n    */\n\n    /**\n     * @param {number} value\n     * @param {Intl.NumberFormatOptions|undefined} [defaultOptions]\n     * @returns {string}\n     */\n    const getNumberFormat = (value, defaultOptions) => {\n      const numberOpts = parseJSONExtra(opts);\n      return new Intl.NumberFormat(locale, {\n        ...defaultOptions, ...numberOpts\n      }).format(value);\n    };\n\n    /**\n     * @param {number} value\n     * @param {Intl.PluralRulesOptions|undefined} [defaultOptions]\n     * @returns {Intl.LDMLPluralRule}\n     */\n    const getPluralFormat = (value, defaultOptions) => {\n      const pluralOpts = parseJSONExtra(opts);\n      return new Intl.PluralRules(locale, {\n        ...defaultOptions, ...pluralOpts\n      }).select(value);\n    };\n    const formatterValue = this.substitutions[\n      /** @type {string} */ (keySegment)\n    ];\n\n    let match = formatterValue;\n    if (typeof formatterValue === 'number') {\n      switch (type) {\n      case 'NUMBER':\n        match = getNumberFormat(formatterValue);\n        break;\n      case 'PLURAL':\n        match = getPluralFormat(formatterValue);\n        break;\n      default:\n        match = new Intl.PluralRules(locale).select(formatterValue);\n        break;\n      }\n    } else if (formatterValue && typeof formatterValue === 'object') {\n      const singleKey = Object.keys(formatterValue)[0];\n      if (['number', 'plural'].includes(singleKey)) {\n        const {value, options} = getFormatterInfo({\n          object:\n          /**\n           * @type {import('./defaultLocaleResolver.js').NumberInfo|\n           *   import('./defaultLocaleResolver.js').PluralInfo}\n           */\n          // @ts-expect-error Ok\n          (formatterValue)[\n            /** @type {\"number\"|\"plural\"} */ (singleKey)\n          ]\n        });\n        if (!type) {\n          type = singleKey.toUpperCase();\n        }\n        const typeMatches = singleKey.toUpperCase() === type;\n        if (!typeMatches) {\n          throw new TypeError(\n            `Expecting type \"${\n              type.toLowerCase()\n            }\"; instead found \"${singleKey}\".`\n          );\n        }\n        // eslint-disable-next-line default-case -- Just two cases\n        switch (type) {\n        case 'NUMBER':\n          match = getNumberFormat(\n            /** @type {number} */ (value),\n            /** @type {Intl.NumberFormatOptions} */\n            (options)\n          );\n          break;\n        case 'PLURAL':\n          match = getPluralFormat(\n            /** @type {number} */ (value),\n            /** @type {Intl.PluralRulesOptions} */\n            (options)\n          );\n          break;\n        }\n      }\n    }\n\n    // We do not want the default `richNested` here as that will split\n    //  up the likes of `0.0`\n    const messageStyle = 'richNested';\n\n    /**\n     * @param {string} s\n     * @returns {string}\n     */\n    const preventNesting = (s) => {\n      return s.replaceAll('\\\\', '\\\\\\\\').replaceAll('.', String.raw`\\.`);\n    };\n\n    try {\n      return getSubstitution({\n        messageStyle,\n        key: match ? preventNesting(/** @type {string} */ (match)) : arg,\n        body,\n        type: 'switch'\n      });\n    // eslint-disable-next-line no-unused-vars -- Ok\n    } catch (err) {\n      try {\n        return getSubstitution({\n          messageStyle,\n          key: '*' +\n            preventNesting(/** @type {string} */ (match)),\n          body,\n          type: 'switch'\n        });\n      // eslint-disable-next-line no-unused-vars -- Ok\n      } catch (error) {\n        const k = Object.keys(body).find(\n          (switchKey) => switchKey.startsWith('*')\n        );\n        if (!k) {\n          throw new Error(`No defaults found for switch ${ky}`);\n        }\n        return getSubstitution({\n          messageStyle, key: preventNesting(k), body, type: 'switch'\n        });\n      }\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  isMatch (key) {\n    return Boolean(\n      key && /** @type {typeof SwitchFormatter} */ (\n        this.constructor\n      ).isMatchingKey(key) &&\n        this.getMatch(key.slice(1)).length\n    );\n  }\n\n  /**\n  * @typedef {[\n  *   objKey?: string,\n  *   body?: import('./getMessageForKeyByStyle.js').LocaleBody,\n  *   keySegment?: string\n  * ]} SwitchMatch\n  */\n\n  /**\n   * @typedef {number} Integer\n   */\n\n  /**\n   * @param {string} ky\n   * @returns {SwitchMatch}\n   */\n  getMatch (ky) {\n    const ks = ky.split('.');\n    const returnValue = /** @type {unknown} */ (ks.reduce(\n      /**\n       * @param {import('./defaultLocaleResolver.js').SwitchArrays|\n       *   import('./defaultLocaleResolver.js').SwitchArray} obj\n       * @param {string} k\n       * @param {Integer} i\n       * @throws {Error}\n       * @returns {SwitchMatch|\n       *   import('./defaultLocaleResolver.js').SwitchCaseArray|\n       *   import('./defaultLocaleResolver.js').SwitchArray}\n       */\n      // @ts-expect-error It works\n      (obj, k, i) => {\n        if (i < ks.length - 1) {\n          if (!(k in obj)) {\n            throw new Error(`Switch key \"${k}\" not found (from \"~${ky}\")`);\n          }\n          return obj[k];\n        }\n        // Todo: Should throw on encountering duplicate fundamental keys (even\n        //  if there are different arguments, that should not be allowed)\n        const ret = Object.entries(obj).find(([switchKey]) => {\n          return k === /** @type {typeof SwitchFormatter} */ (\n            this.constructor\n          ).getKey(switchKey);\n        });\n\n        return ret ? [...ret, k] : [];\n      }, this.switches\n    ));\n\n    return /** @type {SwitchMatch} */ (returnValue);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  static isMatchingKey (key) {\n    return key.startsWith('~');\n  }\n  /**\n   * @param {string} key\n   * @returns {string}\n   */\n  static getKey (key) {\n    const match = key.match(/^[^|]*/u);\n    return /** @type {string} */ (match && match[0]);\n  }\n}\n","/**\n * @typedef {(value: any) => Promise<any>|any} PromiseChainErrback\n */\n\n/**\n * The given array will have its items processed in series; if the supplied\n *  `errBack` (which is guaranteed to run at least once), when passed the\n *  current item, returns a `Promise` or value that resolves, that value will\n *  be used for the return result of this function and no other items in\n *  the array will continue to be processed; if it rejects, however, the\n *  next item will be processed with `errBack`.\n * Accept an array of values to pass to an errback which should return\n *  a promise (or final result value) which resolves to a result or which\n *  rejects so that the next item in the array can be checked in series.\n * @param {Array<any>} values Array of values\n * @param {PromiseChainErrback} errBack Accepts an item of the array as its\n *   single argument\n * @param {string} [errorMessage]\n * @returns {Promise<any>} Either resolves to a value derived from an item in\n *  the array or rejects if all items reject\n * @example\npromiseChainForValues(['a', 'b', 'c'], (val) => {\n  return new Promise(function (resolve, reject) {\n    if (val === 'a') {\n      reject(new Error('missing'));\n    }\n    setTimeout(() => {\n      resolve(val);\n    }, 100);\n  });\n});\n */\nexport const promiseChainForValues = (\n  values, errBack, errorMessage = 'Reached end of values array.'\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(\n      'The `values` argument to `promiseChainForValues` must be an array.'\n    );\n  }\n  if (typeof errBack !== 'function') {\n    throw new TypeError(\n      'The `errBack` argument to `promiseChainForValues` must be a function.'\n    );\n  }\n  return (async () => {\n    let ret;\n    let p = Promise.reject(\n      new Error('Intentionally reject so as to begin checking chain')\n    );\n    let breaking;\n    while (true) {\n      const value = values.shift();\n      try {\n        // eslint-disable-next-line no-await-in-loop -- Ok?\n        ret = await p;\n        break;\n      // eslint-disable-next-line no-unused-vars -- Ok\n      } catch (err) {\n        if (breaking) {\n          throw new Error(errorMessage);\n        }\n        // We allow one more try\n        if (!values.length) {\n          breaking = true;\n        }\n        // // eslint-disable-next-line no-await-in-loop\n        p = errBack(value);\n      }\n    }\n    return ret;\n  })();\n};\n","/**\n* `arg` - By default, accepts the third portion of the\n*   `formattingRegex` within `insertNodes`, i.e., to allow the locale to\n*   supply arguments back to the calling script.\n* `key` - The substitution key.\n* @callback SubstitutionCallback\n* @param {{\n*   arg: string,\n*   key: string\n* }} cfg\n* @returns {string|Element} The replacement text or element\n*/\n\n/**\n * May have additional properties if supplying options to an underlying\n * formatter.\n * The first value is the main value.\n * The second are the options related to the main value.\n * The third are any additional options.\n * @typedef {[string|number|Date, object?, object?]} ValueArray\n */\n\n/**\n * @typedef {number} Integer\n */\n\n/**\n * @typedef {[\n *   string[],\n *   (((item: string, i: Integer) => Element)|object)?,\n *   object?,\n *   object?\n * ]} ListValueArray\n */\n\n/**\n * @typedef {[\n *   Date|number, Date|number, Intl.DateTimeFormatOptions|undefined\n * ]} DateRangeValueArray\n */\n\n/**\n * @typedef {[number, Intl.RelativeTimeFormatUnit, object?]} RelativeValueArray\n */\n\n/**\n * @typedef {object} RelativeTimeInfo\n * @property {RelativeValueArray} relative\n */\n\n/**\n * @typedef {object} ListInfo\n * @property {ListValueArray} list\n */\n\n/**\n * @typedef {object} NumberInfo\n * @property {ValueArray|number} number\n */\n\n/**\n * @typedef {object} DateInfo\n * @property {ValueArray} date\n */\n\n/**\n * @typedef {object} DateTimeInfo\n * @property {ValueArray} datetime\n */\n\n/**\n * @typedef {object} DateRangeInfo\n * @property {DateRangeValueArray} dateRange\n */\n\n/**\n * @typedef {object} DatetimeRangeInfo\n * @property {DateRangeValueArray} datetimeRange\n */\n\n/**\n * @typedef {object} RegionInfo\n * @property {ValueArray} region\n */\n\n/**\n * @typedef {object} LanguageInfo\n * @property {ValueArray} language\n */\n\n/**\n * @typedef {object} ScriptInfo\n * @property {ValueArray} script\n */\n\n/**\n * @typedef {object} CurrencyInfo\n * @property {ValueArray} currency\n */\n\n/**\n * @typedef {object} PluralInfo\n * @property {ValueArray} plural\n */\n\n/**\n * @typedef {{[key: string]: string}} PlainLocaleStringBodyObject\n */\n\n/**\n * @typedef {{\n *   [key: string]: string|PlainNestedLocaleStringBodyObject\n * }} PlainNestedLocaleStringBodyObject\n */\n\n/**\n * @typedef {object} SwitchCaseInfo\n * @property {boolean} [default=false] Whether this conditional is the default\n */\n\n/**\n * Contains the type, the message, and optional info about the switch case.\n * @typedef {[string, string, SwitchCaseInfo?]} SwitchCaseArray\n */\n\n/**\n * @typedef {Object<string, SwitchCaseArray>} SwitchArray\n */\n\n/**\n * @typedef {Object<string, SwitchArray>} SwitchArrays\n */\n\n/**\n * @typedef {object} SwitchCase\n * @property {string} message The locale message with any formatting\n *   place-holders; defaults to use of any single conditional\n * @property {string} [description] A description to add for translators\n */\n\n/**\n * @typedef {Object<string, SwitchCase>} Switch\n */\n\n/**\n * @typedef {Object<string, Switch>} Switches\n */\n\n/**\n * @typedef {object} RichLocaleStringSubObject\n * @property {string} message The locale message with any formatting\n *   place-holders; defaults to use of any single conditional\n * @property {string} [description] A description to add for translators\n * @property {Switches} [switches] Conditionals\n */\n\n/**\n * @typedef {{\n *   [key: string]: RichLocaleStringSubObject\n * }} RichLocaleStringBodyObject\n */\n\n/**\n * @typedef {{\n *   [key: string]: RichLocaleStringSubObject|RichNestedLocaleStringBodyObject\n * }} RichNestedLocaleStringBodyObject\n */\n\n/**\n * Takes a base path and locale and gives a URL.\n * @callback LocaleResolver\n * @param {string} localesBasePath (Trailing slash optional)\n * @param {string} locale BCP-47 language string\n * @returns {string|false} URL of the locale file to be fetched\n */\n\n/**\n * @typedef {[\n *   Date|number, Date|number, (Intl.DateTimeFormatOptions|undefined)?\n * ]} DateRange\n */\n\n/**\n * @typedef {string|string[]|number|Date|DateRange|\n *     Element|Node|SubstitutionCallback|\n *     NumberInfo|PluralInfo|CurrencyInfo|LanguageInfo|ScriptInfo|\n *     DatetimeRangeInfo|DateRangeInfo|RegionInfo|DateTimeInfo|DateInfo|\n *     ListInfo|RelativeTimeInfo\n * } SubstitutionObjectValue\n */\n\n/**\n * @typedef {{\n *   [key: string]: SubstitutionObjectValue\n * }} SubstitutionObject\n */\n\n/**\n * @type {LocaleResolver}\n */\nexport const defaultLocaleResolver = (localesBasePath, locale) => {\n  if (typeof localesBasePath !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `localesBasePath`.'\n    );\n  }\n  if (typeof locale !== 'string') {\n    throw new TypeError(\n      '`defaultLocaleResolver` expects a string `locale`.'\n    );\n  }\n  if ((/[./\\\\]/u).test(locale)) {\n    throw new TypeError(\n      'Locales cannot use file-reserved characters, `.`, `/` or `\\\\`'\n    );\n  }\n  return `${localesBasePath.replace(/\\/$/u, '')}/_locales/${locale}/messages.json`;\n};\n","import {\n  LocalFormatter, RegularFormatter, SwitchFormatter\n} from './Formatter.js';\nimport {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {unescapeBackslashes, parseJSONExtra, processRegex} from './utils.js';\n\n/**\n * @typedef {number} Integer\n */\n\n/**\n * @callback Replace\n * @param {{\n *   str: string,\n *   substs?: import('./defaultLocaleResolver.js').SubstitutionObject,\n *   formatter?: import('./Formatter.js').RegularFormatter|\n *     import('./Formatter.js').LocalFormatter|\n *     import('./Formatter.js').SwitchFormatter\n * }} cfg\n * @returns {string}\n */\n\n/**\n * @callback ProcessSubstitutions\n * @param {{\n *   str: string,\n *   substs?: import('./defaultLocaleResolver.js').SubstitutionObject,\n *   formatter?: import('./Formatter.js').RegularFormatter|\n *     import('./Formatter.js').LocalFormatter|\n *     import('./Formatter.js').SwitchFormatter\n * }} cfg\n * @returns {(string|Node)[]}\n */\n\n/**\n * Callback to return a string or array of nodes and strings based on\n *   a localized string, substitutions object, and other metadata.\n *\n * `string` - The localized string.\n * `dom` - If substitutions known to contain DOM, can be set\n *    to `true` to optimize.\n * `usedKeys` - Array for tracking which keys have been used. Defaults\n *   to empty array.\n * `substitutions` - The formatting substitutions object.\n * `allSubstitutions` - The\n *   callback or array composed thereof for applying to each substitution.\n * `locale` - The successfully resolved locale\n * `locals` - The local section.\n * `switches` - The switch section.\n * `maximumLocalNestingDepth` - Depth of local variable resolution to\n *   check before reporting a recursion error. Defaults to 3.\n * `missingSuppliedFormatters` - Callback\n *   supplied key to throw if the supplied key is present (if\n *   `throwOnMissingSuppliedFormatters` is enabled). Defaults to no-op.\n * `checkExtraSuppliedFormatters` - No\n *   argument callback to check if any formatters are not present in `string`\n *   (if `throwOnExtraSuppliedFormatters` is enabled). Defaults to no-op.\n * @typedef {(cfg: {\n *   string: string,\n *   dom?: boolean,\n *   usedKeys: string[],\n *   substitutions: import('./defaultLocaleResolver.js').SubstitutionObject,\n *   allSubstitutions?: ?(\n *     import('./defaultAllSubstitutions.js').AllSubstitutionCallback|\n *     import('./defaultAllSubstitutions.js').AllSubstitutionCallback[]\n *   )\n *   locale: string|undefined,\n *   locals?: import('./getMessageForKeyByStyle.js').LocalObject|undefined,\n *   switches: import('./defaultLocaleResolver.js').Switches|undefined,\n *   maximumLocalNestingDepth?: Integer,\n *   missingSuppliedFormatters: import('./getDOMForLocaleString.js').\n *     MissingSuppliedFormattersCallback,\n *   checkExtraSuppliedFormatters: import('./getDOMForLocaleString.js').\n *     CheckExtraSuppliedFormattersCallback\n * }) => string|(Node|string)[]} InsertNodesCallback\n */\n\n/**\n * @type {InsertNodesCallback}\n */\nexport const defaultInsertNodes = ({\n  string, dom, usedKeys, substitutions, allSubstitutions, locale,\n  locals, switches,\n  maximumLocalNestingDepth = 3,\n  missingSuppliedFormatters,\n  checkExtraSuppliedFormatters\n}) => {\n  if (typeof maximumLocalNestingDepth !== 'number') {\n    throw new TypeError('`maximumLocalNestingDepth` must be a number.');\n  }\n\n  const addFunctionKeys = () => {\n    Object.entries(substitutions).forEach(([key, value]) => {\n      if (typeof value === 'function') {\n        usedKeys.push(key);\n      }\n    });\n  };\n  addFunctionKeys();\n\n  const localFormatter = new LocalFormatter(\n    /** @type {import('./getMessageForKeyByStyle.js').LocalObject} */ (locals)\n  );\n  const regularFormatter = new RegularFormatter(substitutions);\n  const switchFormatter = new SwitchFormatter(\n    /** @type {import('./defaultLocaleResolver.js').Switches} */\n    (switches),\n    {substitutions}\n  );\n\n  // eslint-disable-next-line prefer-named-capture-group -- Convenient for now\n  const formattingRegex = /(\\\\*)\\{((?:[^}]|\\\\\\})*?)(?:(\\|)([^}]*))?\\}/gu;\n  if (allSubstitutions) {\n    allSubstitutions = Array.isArray(allSubstitutions)\n      ? allSubstitutions\n      : [allSubstitutions];\n  }\n\n  /**\n   * @param {{\n   *   key: string,\n   *   arg: string,\n   *   substs: import('./defaultLocaleResolver.js').SubstitutionObject\n   * }} cfg\n   * @returns {string|Node}\n   */\n  const getSubstitution = ({key, arg, substs}) => {\n    /** @type {import('./defaultLocaleResolver.js').SubstitutionObjectValue} */\n    let substitution;\n    const isLocalKey =\n      /**\n       * @type {typeof import('./Formatter.js').LocalFormatter}\n       */ (\n        localFormatter.constructor\n      ).isMatchingKey(key);\n    if (isLocalKey) {\n      substitution = localFormatter.getSubstitution(key);\n    } else if (\n      /**\n       * @type {typeof import('./Formatter.js').SwitchFormatter}\n       */ (switchFormatter.constructor).isMatchingKey(key)\n    ) {\n      substitution = switchFormatter.getSubstitution(key, {\n        // eslint-disable-next-line object-shorthand -- TS casting\n        locale: /** @type {string} */ (locale),\n        usedKeys,\n        arg,\n        missingSuppliedFormatters\n      });\n    } else {\n      substitution = substs[key];\n      if (typeof substitution === 'function') {\n        substitution = substitution({arg, key});\n      }\n    }\n    // Todo: Could support resolving locals within arguments\n    // Todo: Even for `null` `allSubstitutions`, we could have\n    //  a mode to throw for non-string/non-DOM (non-numbers?),\n    //  or whatever is not likely intended as a target for `toString()`.\n    if (allSubstitutions) {\n      substitution = /** @type {string|Node} */ (\n        /**\n         * @type {import('./defaultAllSubstitutions.js').\n         *   AllSubstitutionCallback[]\n         * }\n         */ (\n          allSubstitutions\n        ).reduce(\n          /**\n           * @param {import('./defaultLocaleResolver.js').\n           *   SubstitutionObjectValue} subst\n           * @param {import('./defaultAllSubstitutions.js').\n           *   AllSubstitutionCallback} allSubst\n           * @returns {string|Node}\n           */\n          (subst, allSubst) => {\n            return allSubst({\n              value: subst,\n              arg,\n              key,\n              locale\n            });\n          }, substitution\n        ));\n    } else if (arg && (/^(?:NUMBER|DATE(?:TIME|RANGE|TIMERANGE)?|REGION|LANGUAGE|SCRIPT|CURRENCY|RELATIVE|LIST)(?:\\||$)/u).test(arg)) {\n      substitution = defaultAllSubstitutions({\n        value: substitution, arg, key, locale\n      });\n    }\n\n    // Change this and return type if other substitutions possible\n    return /** @type {string|Node} */ (substitution);\n  };\n\n  let recursiveLocalCount = 1;\n  /**\n   * @param {{\n   *   substitution: string|Node,\n   *   ky: string,\n   *   arg: string,\n   *   processSubsts: Replace|ProcessSubstitutions\n   * }} cfg\n   * @returns {number|string|Node|(string|Node)[]}\n   */\n  const checkLocalVars = ({substitution, ky, arg, processSubsts}) => {\n    /** @type {number|string|Node|(string|Node)[]} */\n    let subst = substitution;\n    if (\n      typeof substitution === 'string' &&\n      substitution.includes('{')\n    ) {\n      if (recursiveLocalCount++ > maximumLocalNestingDepth) {\n        throw new TypeError('Too much recursion in local variables.');\n      }\n\n      if (\n        /** @type {typeof import('./Formatter.js').LocalFormatter} */ (\n          localFormatter.constructor\n        ).isMatchingKey(ky)\n      ) {\n        let extraSubsts = substitutions;\n        let localFormatters;\n        if (arg) {\n          localFormatters = parseJSONExtra(arg);\n          extraSubsts = {\n            ...substitutions,\n            ...localFormatters\n          };\n        }\n        subst = processSubsts({\n          str: substitution, substs: extraSubsts,\n          formatter: localFormatter\n        });\n        if (localFormatters) {\n          checkExtraSuppliedFormatters({substitutions: localFormatters});\n        }\n      } else if (\n        /** @type {typeof import('./Formatter.js').SwitchFormatter} */\n        (switchFormatter.constructor).isMatchingKey(ky)\n      ) {\n        subst = processSubsts({\n          str: substitution\n        });\n      }\n    }\n\n    return subst;\n  };\n\n  // Give chance to avoid this block when known to contain DOM\n  if (!dom) {\n    // Run this block to optimize non-DOM substitutions\n    let returnsDOM = false;\n\n    /** @type {Replace} */\n    const replace = ({\n      str, substs = substitutions,\n      formatter = regularFormatter\n    }) => {\n      return str.replaceAll(\n        formattingRegex,\n        /**\n         * @param {string} _\n         * @param {string} esc\n         * @param {string} ky\n         * @param {string} pipe\n         * @param {string} arg\n         * @returns {string}\n         */\n        (_, esc, ky, pipe, arg) => {\n          if (esc.length % 2) {\n            return _;\n          }\n          if (missingSuppliedFormatters({\n            key: ky,\n            formatter\n          })) {\n            return _;\n          }\n          /** @type {string|number|Node|(string|Node)[]} */\n          let substitution = getSubstitution({key: ky, arg, substs});\n\n          substitution = checkLocalVars({\n            substitution, ky, arg, processSubsts: replace\n          });\n\n          returnsDOM = returnsDOM ||\n            (substitution !== null && typeof substitution === 'object' &&\n            'nodeType' in substitution);\n          usedKeys.push(ky);\n          return esc + substitution;\n        }\n      );\n    };\n    const ret = replace({str: string});\n    if (!returnsDOM) {\n      checkExtraSuppliedFormatters({substitutions});\n      usedKeys.length = 0;\n      addFunctionKeys();\n      return unescapeBackslashes(ret);\n    }\n    usedKeys.length = 0;\n    addFunctionKeys();\n  }\n\n  recursiveLocalCount = 1;\n\n  /** @type {ProcessSubstitutions} */\n  const processSubstitutions = ({\n    str, substs = substitutions, formatter = regularFormatter\n  }) => {\n    /** @type {(string|Node)[]} */\n    const nodes = [];\n\n    // Copy to ensure we are resetting index on each instance (manually\n    // resetting on `formattingRegex` is problematic with recursion that\n    // uses the same regex copy)\n    const regex = new RegExp(formattingRegex, 'gu');\n\n    /**\n     * @param {...(string|Node)} args\n     */\n    const push = (...args) => {\n      nodes.push(...args);\n    };\n\n    processRegex(regex, str, {\n      extra: push,\n      onMatch (_, esc, ky, pipe, arg) {\n        if (missingSuppliedFormatters({\n          key: ky, formatter\n        })) {\n          push(_);\n        } else {\n          if (esc.length) {\n            push(esc);\n          }\n\n          /** @type {string|number|Node|(string|Node)[]} */\n          let substitution = getSubstitution({key: ky, arg, substs});\n          substitution = checkLocalVars({\n            substitution, ky, arg, processSubsts: processSubstitutions\n          });\n          if (Array.isArray(substitution)) {\n            push(...substitution);\n          } else if (\n            // Clone so that multiple instances may be added (and no\n            // side effects to user code)\n            substitution && typeof substitution === 'object' &&\n            'nodeType' in substitution\n          ) {\n            push(substitution.cloneNode(true));\n          } else {\n            // Why no number here?\n            push(/** @type {string} */ (substitution));\n          }\n        }\n        usedKeys.push(ky);\n      }\n    });\n    return nodes;\n  };\n  const nodes = processSubstitutions({str: string});\n\n  checkExtraSuppliedFormatters({substitutions});\n  usedKeys.length = 0;\n  return nodes.map((node) => {\n    if (typeof node === 'string') {\n      return unescapeBackslashes(node);\n    }\n    return node;\n  });\n};\n","/**\n * @callback KeyCheckerConverterCallback\n * @param {string|string[]} key By default may be an array (if the type ends\n *   with \"Nested\") or a string, but a non-default validator may do otherwise.\n * @param {\"plain\"|\"plainNested\"|\"rich\"|\n *   \"richNested\"|\n *   import('./getMessageForKeyByStyle.js').MessageStyleCallback\n * } messageStyle\n * @throws {TypeError}\n * @returns {string} The converted (or unconverted) key\n */\n\n/**\n * @type {KeyCheckerConverterCallback}\n */\nexport function defaultKeyCheckerConverter (key, messageStyle) {\n  if (Array.isArray(key) &&\n    key.every((k) => {\n      return typeof k === 'string';\n    }) &&\n    typeof messageStyle === 'string' && messageStyle.endsWith('Nested')\n  ) {\n    return key.map((k) => {\n      return k.replaceAll(/(?<backslashes>\\\\+)/gu, String.raw`\\$<backslashes>`).\n        replaceAll('.', String.raw`\\.`);\n    }).join('.');\n  }\n  if (typeof key !== 'string') {\n    throw new TypeError(\n      '`key` is expected to be a string (or array of strings for nested style)'\n    );\n  }\n\n  return key;\n}\n","import {unescapeBackslashes, processRegex} from './utils.js';\n\n/**\n* @typedef {LocaleBody} LocalObject\n*/\n\n/**\n * May also contain language code and direction, translator name and\n * contact, etc., but no defaults currently apply besides reserving `locals`\n * @typedef {object} LocaleHead\n * @property {LocalObject} [locals]\n * @property {import('./defaultLocaleResolver.js').Switches} [switches]\n*/\n\n/**\n * @typedef {import('./defaultLocaleResolver.js').\n *   RichNestedLocaleStringBodyObject|\n *   import('./defaultLocaleResolver.js').RichLocaleStringBodyObject|\n *   import('./defaultLocaleResolver.js').PlainLocaleStringBodyObject|\n *   import('./defaultLocaleResolver.js').PlainNestedLocaleStringBodyObject|\n *   object\n * } LocaleBody\n */\n\n/**\n* @typedef {object} LocaleObject\n* @property {LocaleHead} [head]\n* @property {LocaleBody} body\n*/\n\n/**\n* @typedef {object} MessageStyleCallbackResult\n* @property {string} value Regardless of message style, will contain\n*    the string result\n* @property {import(\n*  './defaultLocaleResolver.js'\n*  ).RichLocaleStringSubObject} [info] Full info on the localized item\n*   (for rich message styles only)\n*/\n\n/**\n* @callback MessageStyleCallback\n* @param {LocaleObject} obj The exact\n*   format depends on the `cfg.defaults` of `i18n`\n* @param {string} key\n* @returns {false|MessageStyleCallbackResult} If `false`, will resort to default\n*/\n\n/* eslint-disable @stylistic/max-len -- Long */\n/**\n * @param {object} [cfg]\n * @param {\"richNested\"|\"rich\"|\"plain\"|\"plainNested\"|MessageStyleCallback} [cfg.messageStyle]\n * @returns {MessageStyleCallback}\n */\nexport const getMessageForKeyByStyle = ({\n  /* eslint-enable @stylistic/max-len -- Long */\n  messageStyle = 'richNested'\n} = {}) => {\n  return typeof messageStyle === 'function'\n    ? messageStyle\n    : (messageStyle === 'richNested'\n      ? (mainObj, key) => {\n        const obj =\n          /**\n           * @type {import('./defaultLocaleResolver.js').\n           *   RichNestedLocaleStringBodyObject\n           * }\n           */ (\n            mainObj && typeof mainObj === 'object' && mainObj.body\n          );\n\n        /**\n         * @type {string[]}\n         */\n        const keys = [];\n        // eslint-disable-next-line @stylistic/max-len -- Long\n        // eslint-disable-next-line prefer-named-capture-group -- Convenient for now\n        const possiblyEscapedCharPattern = /(\\\\*)\\./gu;\n\n        /**\n         * @param {string} val\n         * @returns {void}\n         */\n        const mergeWithPreviousOrStart = (val) => {\n          if (!keys.length) {\n            keys[0] = '';\n          }\n          keys[keys.length - 1] += val;\n        };\n        processRegex(possiblyEscapedCharPattern, key, {\n          // If odd, this is just an escaped dot, so merge content with\n          //   any previous\n          extra: mergeWithPreviousOrStart,\n          onMatch (_, esc) {\n            // If even, there are no backslashes, or they are just escaped\n            //  backslashes and not an escaped dot, so start anew, though\n            //  first merge any backslashes\n            mergeWithPreviousOrStart(esc);\n            keys.push('');\n          }\n        });\n        const keysUnescaped = keys.map((ky) => {\n          return unescapeBackslashes(ky);\n        });\n\n        /**\n         * @type {false|{\n         *   value: string|undefined,\n         *   info: import('./defaultLocaleResolver.js').\n         *     RichLocaleStringSubObject\n         * }}\n         */\n        let ret = false;\n        let currObj = obj;\n        keysUnescaped.some((ky, i, kys) => {\n          if (!currObj || typeof currObj !== 'object') {\n            return true;\n          }\n          if (\n            // If specified key is too deep, we should fail\n            i === kys.length - 1 && ky in currObj &&\n            currObj[ky] && typeof currObj[ky] === 'object' &&\n            'message' in currObj[ky] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof currObj[ky].message === 'string'\n          ) {\n            ret = {\n              value: /** @type {string} */ (currObj[ky].message),\n              info:\n              /**\n               * @type {import('./defaultLocaleResolver.js').\n               *   RichLocaleStringSubObject}\n               */ (currObj[ky])\n            };\n          }\n          currObj =\n            /**\n             * @type {import('./defaultLocaleResolver.js').\n             *   RichNestedLocaleStringBodyObject\n             * }\n             */ (currObj[ky]);\n\n          return false;\n        });\n        return ret;\n      }\n      : (messageStyle === 'rich'\n        ? (mainObj, key) => {\n          const obj =\n            /**\n             * @type {import('./defaultLocaleResolver.js').\n             *   RichLocaleStringBodyObject\n             * }\n             */ (mainObj && typeof mainObj === 'object' && mainObj.body);\n          if (\n            obj && typeof obj === 'object' &&\n            key in obj && obj[key] && typeof obj[key] === 'object' &&\n            'message' in obj[key] &&\n            // NECESSARY FOR SECURITY ON UNTRUSTED LOCALES\n            typeof obj[key].message === 'string'\n          ) {\n            return {\n              value: obj[key].message,\n              info: obj[key]\n            };\n          }\n          return false;\n        }\n        : (messageStyle === 'plain'\n          ? (mainObj, key) => {\n            const obj =\n              /**\n               * @type {import('./defaultLocaleResolver.js').\n               *   PlainLocaleStringBodyObject\n               * }\n               */ (\n                mainObj && typeof mainObj === 'object' && mainObj.body\n              );\n            if (\n              obj && typeof obj === 'object' &&\n              key in obj && obj[key] && typeof obj[key] === 'string'\n            ) {\n              return {\n                value: obj[key]\n              };\n            }\n            return false;\n          }\n          : (messageStyle === 'plainNested'\n            ? (mainObj, key) => {\n              const obj =\n                /**\n                 * @type {import('./defaultLocaleResolver.js').\n                 *   PlainNestedLocaleStringBodyObject\n                 * }\n                 */ (\n                  mainObj && typeof mainObj === 'object' && mainObj.body\n                );\n              if (obj && typeof obj === 'object') {\n                // Should really be counting that it is an odd number\n                //  of backslashes only\n                const keys = key.split(/(?<!\\\\)\\./u);\n                const value = keys.reduce(\n                  /**\n                   * @param {null|string|import('./defaultLocaleResolver.js').\n                   *   PlainNestedLocaleStringBodyObject} o\n                   * @param {string} k\n                   * @returns {null|string|import('./defaultLocaleResolver.js').\n                   *   PlainNestedLocaleStringBodyObject}\n                   */\n                  (o, k) => {\n                    if (o && typeof o === 'object' && o[k]) {\n                      return o[k];\n                    }\n                    return null;\n                  }, obj\n                );\n                if (value && typeof value === 'string') {\n                  return {value};\n                }\n              }\n              return false;\n            }\n            : (() => {\n              throw new TypeError(`Unknown \\`messageStyle\\` ${messageStyle}`);\n            })()))\n      )\n    );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\n\n/**\n * @param {object} cfg\n * @param {string|false} [cfg.message] If present, this string will be\n *   the return value.\n * @param {false|null|undefined|\n *   import('./getMessageForKeyByStyle.js').LocaleObject\n * } [cfg.defaults]\n * @param {\"richNested\"|\"rich\"|\"plain\"|\"plainNested\"|\n *   import('./getMessageForKeyByStyle.js').MessageStyleCallback\n * } [cfg.messageStyle]\n * @param {import('./getMessageForKeyByStyle.js').\n *   MessageStyleCallback\n * } [cfg.messageForKey] Defaults to getting `MessageStyleCallback` based\n *   on `messageStyle`\n * @param {string} cfg.key Key to check against object of strings;\n *   used to find a default if no string `message` is provided.\n * @returns {string}\n */\nexport const getStringFromMessageAndDefaults = ({\n  message,\n  defaults,\n  messageStyle,\n  messageForKey = getMessageForKeyByStyle({messageStyle}),\n  key\n}) => {\n  // NECESSARY CHECK FOR SECURITY ON UNTRUSTED LOCALES\n  /** @type {string|false} */\n  let str;\n  if (typeof message === 'string') {\n    str = message;\n  } else if (\n    defaults === false || defaults === undefined || defaults === null\n  ) {\n    str = false;\n  } else if (defaults && typeof defaults === 'object') {\n    const msg = messageForKey(defaults, key);\n    str = msg ? msg.value : msg;\n  } else {\n    throw new TypeError(\n      `Default locale strings must resolve to \\`false\\`, ` +\n      `nullish, or an object!`\n    );\n  }\n  if (str === false) {\n    throw new Error(`Key value not found for key: (${key})`);\n  }\n  return str;\n};\n","import {defaultAllSubstitutions} from './defaultAllSubstitutions.js';\nimport {defaultInsertNodes} from './defaultInsertNodes.js';\nimport {getDocument} from './shared.js';\n\nexport {setDocument, getDocument} from './shared.js';\n\n/**\n * @typedef {number} Integer\n */\n\n/**\n * @callback CheckExtraSuppliedFormattersCallback\n * @param {import('./defaultLocaleResolver.js').SubstitutionObject|{\n *   substitutions: import('./defaultLocaleResolver.js').SubstitutionObject\n * }} substs (Why is an arg. of `substitutions` being passed in?)\n * @throws {Error} Upon an extra formatting key being found\n * @returns {void}\n */\n\n/**\n * @typedef {(\n *   cfg: {\n *     key: string,\n *     formatter: import('./Formatter.js').LocalFormatter|\n *       import('./Formatter.js').RegularFormatter|\n *       import('./Formatter.js').SwitchFormatter\n *   }\n * ) => boolean} MissingSuppliedFormattersCallback\n */\n\n/**\n *\n * @param {object} cfg\n * @param {string} cfg.string\n * @param {string} [cfg.locale] The (possibly already resolved) locale\n *   for use by configuring formatters\n * @param {import('./getMessageForKeyByStyle.js').LocalObject} [cfg.locals]\n * @param {import('./defaultLocaleResolver.js').Switches} [cfg.switches]\n * @param {Integer} [cfg.maximumLocalNestingDepth]\n * @param {?(import('./defaultAllSubstitutions.js').AllSubstitutionCallback|\n *   import('./defaultAllSubstitutions.js').AllSubstitutionCallback[])\n * } [cfg.allSubstitutions]\n * @param {import('./defaultInsertNodes.js').InsertNodesCallback\n * } [cfg.insertNodes]\n * @param {false|import('./defaultLocaleResolver.js').SubstitutionObject\n * } [cfg.substitutions]\n * @param {boolean} [cfg.dom]\n * @param {boolean} [cfg.forceNodeReturn]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters]\n * @returns {string|Text|DocumentFragment}\n */\nexport const getDOMForLocaleString = ({\n  string,\n  locale,\n  locals,\n  switches,\n  // eslint-disable-next-line no-unused-vars -- Not currently used\n  maximumLocalNestingDepth,\n  allSubstitutions = [\n    defaultAllSubstitutions\n  ],\n  insertNodes = defaultInsertNodes,\n  substitutions = false,\n  dom = false,\n  forceNodeReturn = false,\n  throwOnMissingSuppliedFormatters = true,\n  throwOnExtraSuppliedFormatters = true\n}) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'An options object with a `string` property set to a string must ' +\n      'be provided for `getDOMForLocaleString`.'\n    );\n  }\n\n  /**\n   * @param {string} str\n   * @returns {Text|string}\n   */\n  const stringOrTextNode = (str) => {\n    const _doc = getDocument();\n    return forceNodeReturn\n      ? /** @type {Document} */ (\n        _doc\n      ).createTextNode(str)\n      : str;\n  };\n\n  /** @type {string[]} */\n  const usedKeys = [];\n\n  /**\n   * @type {CheckExtraSuppliedFormattersCallback}\n   */\n  const checkExtraSuppliedFormatters = ({\n    substitutions: substs\n  }) => {\n    if (throwOnExtraSuppliedFormatters) {\n      Object.keys(substs).forEach((key) => {\n        if (!usedKeys.includes(key)) {\n          throw new Error(`Extra formatting key: ${key}`);\n        }\n      });\n    }\n  };\n\n  /**\n   * @type {MissingSuppliedFormattersCallback}\n   */\n  const missingSuppliedFormatters = ({\n    key, formatter\n  }) => {\n    const matching = formatter.isMatch(key);\n    if (\n      /**\n       * @type {typeof import('./Formatter.js').LocalFormatter|\n       *       typeof import('./Formatter.js').RegularFormatter|\n       *       typeof import('./Formatter.js').SwitchFormatter}\n       */ (\n        formatter.constructor\n      ).isMatchingKey(key) && !matching\n    ) {\n      if (throwOnMissingSuppliedFormatters) {\n        throw new Error(`Missing formatting key: ${key}`);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  if (\n    !substitutions && !allSubstitutions &&\n    !throwOnMissingSuppliedFormatters\n  ) {\n    return stringOrTextNode(string);\n  }\n  if (!substitutions) {\n    substitutions = {};\n  }\n\n  const nodes = insertNodes({\n    string, dom, usedKeys, substitutions, allSubstitutions, locale,\n    locals,\n    switches,\n    missingSuppliedFormatters,\n    checkExtraSuppliedFormatters\n  });\n  if (typeof nodes === 'string') {\n    return stringOrTextNode(nodes);\n  }\n\n  const _doc = getDocument();\n  const container = /** @type {Document} */ (_doc).createDocumentFragment();\n  container.append(...nodes);\n\n  return container;\n};\n","/* globals intlDomLocale -- Allow global setting */\n\nimport {defaultLocaleResolver} from './defaultLocaleResolver.js';\nimport {promiseChainForValues} from './promiseChainForValues.js';\nimport {getFetch} from './shared.js';\n\nexport {setFetch, getFetch} from './shared.js';\n\n/**\n * Takes a locale and returns a new locale to check.\n * @callback LocaleMatcher\n * @param {string} locale The failed locale\n * @throws {Error} If there are no further hyphens left to check\n * @returns {string|Promise<string>} The new locale to check\n*/\n\n/**\n * @type {LocaleMatcher}\n */\nexport const defaultLocaleMatcher = (locale) => {\n  if (!locale.includes('-')) {\n    throw new Error('Locale not available');\n  }\n  // Try without hyphen, i.e., the \"lookup\" algorithm:\n  // See https://tools.ietf.org/html/rfc4647#section-3.4 and\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\n  return locale.replace(/-[^-]*$/u, '');\n};\n\n/**\n * @param {object} cfg\n * @param {string} cfg.locale\n * @param {string[]} cfg.locales\n * @param {LocaleMatcher} [cfg.localeMatcher]\n * @returns {string|false}\n */\nexport const getMatchingLocale = ({\n  locale, locales, localeMatcher = defaultLocaleMatcher\n}) => {\n  try {\n    while (!locales.includes(locale)) {\n      // Catch as `defaultLocaleMatcher` will throw if no hyphen found\n      locale = localeMatcher(locale);\n    }\n  // eslint-disable-next-line no-unused-vars -- Ok\n  } catch (err) {\n    return false;\n  }\n  return locale;\n};\n\n/**\n * @typedef {object} LocaleObjectInfo\n * @property {import('./getMessageForKeyByStyle.js').\n *   LocaleObject} strings The successfully retrieved locale strings\n * @property {string} locale The successfully resolved locale\n */\n\n/**\n * @typedef {{\n *   locales?: string[],\n *   defaultLocales?: string[],\n *   localesBasePath?: string,\n *   localeResolver?: import('./defaultLocaleResolver.js').LocaleResolver,\n *   localeMatcher?: \"lookup\"|LocaleMatcher\n * }} LocaleStringArgs\n */\n\n/**\n * `locales` - BCP-47 language strings. Defaults to `navigator.languages`.\n * `defaultLocales` - Defaults to [\"en-US\"].\n * `localesBasePath` - Defaults to `.`.\n * `localeResolver` - Defaults to `defaultLocaleResolver`.\n * @typedef {(\n *   cfg?: LocaleStringArgs\n * ) => Promise<LocaleObjectInfo>} LocaleStringFinder\n */\n\n/**\n *\n * @type {LocaleStringFinder}\n */\nexport const findLocaleStrings = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return /** @type {Promise<LocaleObjectInfo>} */ (_findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  }));\n};\n\n/**\n * Resolves to the successfully resolved locale.\n * `locales` - BCP-47 language strings. Defaults to `navigator.languages`.\n * `defaultLocales` - Defaults to [\"en-US\"].\n * `localesBasePath` - Defaults to `.`.\n * `localeResolver` - Defaults to `defaultLocaleResolver`.\n * `localeMatcher`.\n * @typedef {(cfg?: LocaleStringArgs) => Promise<string>} LocaleFinder\n */\n\n/**\n *\n * @type {LocaleFinder}\n */\nexport const findLocale = ({\n  locales,\n  defaultLocales,\n  localeResolver,\n  localesBasePath,\n  localeMatcher\n} = {}) => {\n  return /** @type {Promise<string>} */ (_findLocale({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher,\n    headOnly: true\n  }));\n};\n\n/**\n * @type {(\n *   cfg: LocaleStringArgs & {\n *     headOnly?: boolean\n *   }\n * ) => Promise<string|LocaleObjectInfo>} Also has a `headOnly` boolean\n *  property to determine whether to make a simple HEAD and resolve to\n *  the locale rather than locale and contents\n */\nconst _findLocale = async ({\n  locales = typeof intlDomLocale !== 'undefined'\n    ? [intlDomLocale]\n    : typeof navigator === 'undefined' ? [] : navigator.languages,\n  defaultLocales = ['en-US'],\n  localeResolver = defaultLocaleResolver,\n  localesBasePath = '.',\n  localeMatcher = 'lookup',\n  headOnly = false\n}) => {\n  /**\n   * @callback getLocale\n   * @throws {SyntaxError|TypeError|Error}\n   * @param {string} locale\n   * @returns {Promise<LocaleObjectInfo|string>}\n   */\n  async function getLocale (locale) {\n    if (typeof locale !== 'string') {\n      throw new TypeError('Non-string locale type');\n    }\n    const url = localeResolver(localesBasePath, locale);\n    if (typeof url !== 'string') {\n      throw new TypeError(\n        '`localeResolver` expected to resolve to (URL) string.'\n      );\n    }\n    try {\n      const _fetch = /** @type {import('./shared.js').Fetch} */ (getFetch());\n      const resp = await (headOnly\n        ? _fetch(url, {\n          method: 'HEAD'\n        })\n        : _fetch(url)\n      );\n\n      if (resp.status === 404) {\n        // Don't allow browser (tested in Firefox) to continue\n        //  and give `SyntaxError` with missing file or we won't be\n        //  able to try without the hyphen\n        throw new Error('Trying again');\n      }\n      if (headOnly) {\n        return locale;\n      }\n      const strings = await (resp.json());\n      return {\n        locale,\n        strings\n      };\n    } catch (err) {\n      if (/** @type {Error} */ (err).name === 'SyntaxError') {\n        throw err;\n      }\n      const newLocale = await /** @type {LocaleMatcher} */ (\n        localeMatcher\n      )(locale);\n      return getLocale(newLocale);\n    }\n  }\n  if (localeMatcher === 'lookup') {\n    localeMatcher = defaultLocaleMatcher;\n  } else if (typeof localeMatcher !== 'function') {\n    throw new TypeError('`localeMatcher` must be \"lookup\" or a function!');\n  }\n  return await promiseChainForValues(\n    [...locales, ...defaultLocales],\n    getLocale,\n    'No matching locale found for ' + [...locales, ...defaultLocales].join(', ')\n  );\n};\n","import {getMessageForKeyByStyle} from './getMessageForKeyByStyle.js';\nimport {findLocaleStrings} from './findLocaleStrings.js';\nimport {getDOMForLocaleString} from './getDOMForLocaleString.js';\nimport {\n  getStringFromMessageAndDefaults\n} from './getStringFromMessageAndDefaults.js';\nimport {sort, sortList, list} from './collation.js';\nimport {defaultKeyCheckerConverter} from './defaultKeyCheckerConverter.js';\n\n/**\n * @typedef {import('./index.js').Sort} Sort\n */\n/**\n * @typedef {import('./index.js').SortList} SortList\n */\n/**\n * @typedef {import('./index.js').List} List\n */\n\n/**\n * @typedef {import('./index.js').I18NCallback} I18NCallback\n */\n\n/**\n * @param {object} cfg\n * @param {import('./getMessageForKeyByStyle.js').LocaleObject} cfg.strings\n * @param {string} cfg.resolvedLocale\n * @param {\"richNested\"|\"rich\"|\"plain\"|\"plainNested\"|\n *   import('./getMessageForKeyByStyle.js').\n *     MessageStyleCallback} [cfg.messageStyle]\n * @param {?import('./defaultAllSubstitutions.js').AllSubstitutionCallback|\n *   import('./defaultAllSubstitutions.js').\n *     AllSubstitutionCallback[]} [cfg.allSubstitutions]\n * @param {import('./defaultInsertNodes.js').\n *   InsertNodesCallback} [cfg.insertNodes]\n * @param {import('./defaultKeyCheckerConverter.js').\n *   KeyCheckerConverterCallback} [cfg.keyCheckerConverter]\n * @param {false|null|undefined|\n *   import('./getMessageForKeyByStyle.js').LocaleObject} [cfg.defaults]\n * @param {false|import('./defaultLocaleResolver.js').\n *   SubstitutionObject} [cfg.substitutions]\n * @param {Integer} [cfg.maximumLocalNestingDepth]\n * @param {boolean} [cfg.dom]\n * @param {boolean} [cfg.forceNodeReturn]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters]\n * @returns {I18NCallback} Rejects if no suitable locale is found.\n */\nexport const i18nServer = function i18nServer ({\n  strings,\n  resolvedLocale,\n  messageStyle = 'richNested',\n  allSubstitutions: defaultAllSubstitutionsValue,\n  insertNodes,\n  keyCheckerConverter = defaultKeyCheckerConverter,\n  defaults: defaultDefaults,\n  substitutions: defaultSubstitutions,\n  maximumLocalNestingDepth,\n  dom: domDefaults = false,\n  forceNodeReturn: forceNodeReturnDefault = false,\n  throwOnMissingSuppliedFormatters:\n    throwOnMissingSuppliedFormattersDefault = true,\n  throwOnExtraSuppliedFormatters:\n    throwOnExtraSuppliedFormattersDefault = true\n}) {\n  if (!strings || typeof strings !== 'object') {\n    throw new TypeError(`Locale strings must be an object!`);\n  }\n  const messageForKey = getMessageForKeyByStyle({messageStyle});\n\n  /**\n   * @type {I18NCallback}\n   */\n  const formatter = (key, substitutions, {\n    allSubstitutions = defaultAllSubstitutionsValue,\n    defaults = defaultDefaults,\n    dom = domDefaults,\n    forceNodeReturn = forceNodeReturnDefault,\n    throwOnMissingSuppliedFormatters = throwOnMissingSuppliedFormattersDefault,\n    throwOnExtraSuppliedFormatters = throwOnExtraSuppliedFormattersDefault\n  } = {}) => {\n    key = /** @type {string} */ (keyCheckerConverter(key, messageStyle));\n    const message = messageForKey(strings, key);\n    const string = getStringFromMessageAndDefaults({\n      message: message && typeof message.value === 'string'\n        ? message.value\n        : false,\n      defaults,\n      messageForKey,\n      key\n    });\n\n    return getDOMForLocaleString({\n      string,\n      locals: strings.head && strings.head.locals,\n      switches: strings.head && strings.head.switches,\n      locale: resolvedLocale,\n      maximumLocalNestingDepth,\n      allSubstitutions,\n      insertNodes,\n      substitutions: {...defaultSubstitutions, ...substitutions},\n      dom,\n      forceNodeReturn,\n      throwOnMissingSuppliedFormatters,\n      throwOnExtraSuppliedFormatters\n    });\n  };\n\n  formatter.resolvedLocale = resolvedLocale;\n  formatter.strings = strings;\n\n  /** @type {Sort} */\n  formatter.sort = (arrayOfItems, options) => {\n    return sort(resolvedLocale, arrayOfItems, options);\n  };\n\n  /** @type {SortList} */\n  formatter.sortList = (arrayOfItems, map, listOptions, collationOptions) => {\n    return sortList(\n      resolvedLocale, arrayOfItems, map, listOptions, collationOptions\n    );\n  };\n\n  /** @type {List} */\n  formatter.list = (arrayOfItems, options) => {\n    return list(\n      resolvedLocale, arrayOfItems, options\n    );\n  };\n\n  return formatter;\n};\n\n/**\n * @typedef {number} Integer\n */\n\n/**\n * @param {object} [cfg]\n * @param {string[]} [cfg.locales] BCP-47 language strings\n * @param {string[]} [cfg.defaultLocales]\n * @param {import('./findLocaleStrings.js').\n *   LocaleStringFinder} [cfg.localeStringFinder]\n * @param {string} [cfg.localesBasePath]\n * @param {import('./defaultLocaleResolver.js').\n *   LocaleResolver} [cfg.localeResolver]\n * @param {\"lookup\"|import('./findLocaleStrings.js').\n *   LocaleMatcher} [cfg.localeMatcher]\n * @param {\"richNested\"|\"rich\"|\"plain\"|\"plainNested\"|\n *   import('./getMessageForKeyByStyle.js').\n *     MessageStyleCallback} [cfg.messageStyle]\n * @param {?(import('./defaultAllSubstitutions.js').AllSubstitutionCallback|\n *   import('./defaultAllSubstitutions.js').\n *     AllSubstitutionCallback[])} [cfg.allSubstitutions]\n * @param {import('./defaultInsertNodes.js').\n *   InsertNodesCallback} [cfg.insertNodes]\n * @param {import('./defaultKeyCheckerConverter.js').\n *   KeyCheckerConverterCallback} [cfg.keyCheckerConverter]\n * @param {false|null|undefined|\n *   import('./getMessageForKeyByStyle.js').LocaleObject} [cfg.defaults]\n * @param {false|\n *   import('./defaultLocaleResolver.js').\n *     SubstitutionObject} [cfg.substitutions]\n * @param {Integer} [cfg.maximumLocalNestingDepth]\n * @param {boolean} [cfg.dom]\n * @param {boolean} [cfg.forceNodeReturn]\n * @param {boolean} [cfg.throwOnMissingSuppliedFormatters]\n * @param {boolean} [cfg.throwOnExtraSuppliedFormatters]\n * @returns {Promise<I18NCallback>} Rejects if no suitable locale is found.\n */\nexport const i18n = async function i18n ({\n  locales,\n  defaultLocales,\n  localeStringFinder = findLocaleStrings,\n  localesBasePath,\n  localeResolver,\n  localeMatcher,\n  messageStyle,\n  allSubstitutions,\n  insertNodes,\n  keyCheckerConverter,\n  defaults,\n  substitutions,\n  maximumLocalNestingDepth,\n  dom,\n  forceNodeReturn,\n  throwOnMissingSuppliedFormatters,\n  throwOnExtraSuppliedFormatters\n} = {}) {\n  const {strings, locale: resolvedLocale} = await localeStringFinder({\n    locales, defaultLocales, localeResolver, localesBasePath, localeMatcher\n  });\n  if (!defaults && defaultLocales) {\n    let defaultLocale;\n    ({strings: defaults, locale: defaultLocale} = await localeStringFinder({\n      locales: defaultLocales,\n      defaultLocales: [],\n      localeResolver, localesBasePath, localeMatcher\n    }));\n    if (defaultLocale === resolvedLocale) {\n      defaults = null; // No need to fall back\n    }\n  }\n\n  return i18nServer({\n    strings,\n    resolvedLocale,\n    messageStyle,\n    allSubstitutions,\n    insertNodes,\n    keyCheckerConverter,\n    defaults,\n    substitutions,\n    maximumLocalNestingDepth,\n    dom,\n    forceNodeReturn,\n    throwOnMissingSuppliedFormatters,\n    throwOnExtraSuppliedFormatters\n  });\n};\n"],"names":["_jsonExtra","globalThis","jsonExtra","unescapeBackslashes","str","replaceAll","esc","slice","length","parseJSONExtra","args","parse","replace","processRegex","regex","_ref","match","onMatch","extra","betweenMatches","afterMatch","escapeAtOne","previousIndex","Error","exec","_match2","_slicedToArray","_","lastIndex","startMatchPos","apply","_toConsumableArray","_fetch","fetch","getFetch","_doc","document","getDocument","sort","locale","arrayOfItems","options","Intl","Collator","compare","list","ListFormat","format","sortList","map","listOptions","collationOptions","sortListSimple","d","randomId","Date","now","performance","c","r","Math","trunc","random","floor","toString","placeholderArray","i","concat","nodes","push","arg","RegExp","idx","Number","container","createDocumentFragment","append","getFormatterInfo","object","Array","isArray","_object","value","callback","extraOpts","_object2","defaultAllSubstitutions","_ref2","opts","_typeof","applyArgs","_ref3","type","_ref3$options","_ref3$checkArgOptions","checkArgOptions","_arg$split2","split","userType","extraArgs","argOptions","_objectSpread","expectsDatetime","singleKey","Object","keys","includes","obj","_getFormatterInfo","dtf","DateTimeFormat","formatRange","val","DisplayNames","toUpperCase","of","_ref4","RelativeTimeFormat","test","getTime","_Intl$DateTimeFormat","NumberFormat","TypeError","Formatter","_createClass","_classCallCheck","getSubstitution","key","body","_ref$messageStyle","messageStyle","substitution","getMessageForKeyByStyle","messageForKey","LocalFormatter","_Formatter","locals","_this","_callSuper","this","_inherits","components","parent","constructor","isMatchingKey","every","cmpt","result","startsWith","RegularFormatter","_Formatter2","substitutions","_this2","SwitchFormatter","_Formatter3","switches","_this3","usedKeys","missingSuppliedFormatters","ky","getKey","_this$getMatch2","getMatch","objKey","keySegment","_objKey$split2","formatter","String","raw","_templateObject","_taggedTemplateLiteral","getNumberFormat","defaultOptions","numberOpts","getPluralFormat","pluralOpts","PluralRules","select","formatterValue","toLowerCase","preventNesting","s","_templateObject2","err","error","k","find","switchKey","Boolean","_this4","ks","reduce","ret","entries","_settle","pact","state","_Pact","o","bind","v","then","observer","prototype","onFulfilled","onRejected","e","_isSettledPact","thenable","promiseChainForValues","values","errBack","f","errorMessage","arguments","undefined","breaking","_interrupt","p","Promise","reject","update","stage","shouldContinue","_resumeAfterTest","_resumeAfterBody","updateValue","_for","shift","recover","_catch","resolve","_await","_p","_result2","defaultLocaleResolver","localesBasePath","defaultInsertNodes","string","dom","allSubstitutions","_ref$maximumLocalNest","maximumLocalNestingDepth","checkExtraSuppliedFormatters","addFunctionKeys","forEach","localFormatter","regularFormatter","switchFormatter","formattingRegex","substs","subst","allSubst","recursiveLocalCount","checkLocalVars","_ref5","processSubsts","localFormatters","extraSubsts","returnsDOM","_ref6","_ref6$substs","_ref6$formatter","pipe","processSubstitutions","_ref7","_ref7$substs","_ref7$formatter","cloneNode","node","defaultKeyCheckerConverter","endsWith","_wrapRegExp","backslashes","join","mainObj","mergeWithPreviousOrStart","keysUnescaped","currObj","some","kys","message","info","getStringFromMessageAndDefaults","defaults","_ref$messageForKey","msg","getDOMForLocaleString","_ref$allSubstitutions","_ref$insertNodes","insertNodes","_ref$substitutions","_ref$dom","_ref$forceNodeReturn","forceNodeReturn","_ref$throwOnMissingSu","throwOnMissingSuppliedFormatters","_ref$throwOnExtraSupp","throwOnExtraSuppliedFormatters","stringOrTextNode","createTextNode","matching","isMatch","direct","_async","defaultLocaleMatcher","findLocaleStrings","locales","defaultLocales","localeResolver","localeMatcher","_findLocale","getLocale","url","headOnly","method","resp","status","json","strings","name","_ref4$locales","intlDomLocale","navigator","languages","_ref4$defaultLocales","_ref4$localeResolver","_ref4$localesBasePath","_ref4$localeMatcher","_ref4$headOnly","i18nServer","resolvedLocale","defaultAllSubstitutionsValue","_ref$keyCheckerConver","keyCheckerConverter","defaultDefaults","defaultSubstitutions","domDefaults","forceNodeReturnDefault","throwOnMissingSuppliedFormattersDefault","throwOnExtraSuppliedFormattersDefault","_ref2$allSubstitution","_ref2$defaults","_ref2$dom","_ref2$forceNodeReturn","_ref2$throwOnMissingS","_ref2$throwOnExtraSup","head","_ref$localeMatcher","i18n","_ref3$localeStringFin","localeStringFinder","_localeStringFinder","doc","__jsonExtra"],"mappings":"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"}